/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2
 *
 *     -  From the grammar source file : SimpleBashSQL.g
 *     -                            On : 2015-10-23 01:44:42
 *     -                for the parser : SimpleBashSQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

#ifndef MYHEAD
#define MYHEAD
 #include "SimpleBashSQLLexer.hpp" 
 #include <assert.h>
 #include <iostream>
 #include "thequery.hpp"
 using namespace std;

#endif

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SimpleBashSQLParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8* SimpleBashSQLParserTokenNames[81+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALCHAR",
        (ANTLR_UINT8*) "ALPHA",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "DIGIT",
        (ANTLR_UINT8*) "ESCAPED",
        (ANTLR_UINT8*) "LETTER",
        (ANTLR_UINT8*) "NUMBER",
        (ANTLR_UINT8*) "OPTS",
        (ANTLR_UINT8*) "PIPE",
        (ANTLR_UINT8*) "SONDER",
        (ANTLR_UINT8*) "WHITESPACE",
        (ANTLR_UINT8*) "WORD",
        (ANTLR_UINT8*) "'!'",
        (ANTLR_UINT8*) "'!='",
        (ANTLR_UINT8*) "'\"'",
        (ANTLR_UINT8*) "'#!/bin/bash'",
        (ANTLR_UINT8*) "'#'",
        (ANTLR_UINT8*) "'&&'",
        (ANTLR_UINT8*) "'&'",
        (ANTLR_UINT8*) "'&>'",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "'*'",
        (ANTLR_UINT8*) "'*='",
        (ANTLR_UINT8*) "'+'",
        (ANTLR_UINT8*) "'+='",
        (ANTLR_UINT8*) "'- '",
        (ANTLR_UINT8*) "'-'",
        (ANTLR_UINT8*) "'-1'",
        (ANTLR_UINT8*) "'-2'",
        (ANTLR_UINT8*) "'-='",
        (ANTLR_UINT8*) "'/'",
        (ANTLR_UINT8*) "';'",
        (ANTLR_UINT8*) "';;'",
        (ANTLR_UINT8*) "'<&'",
        (ANTLR_UINT8*) "'<'",
        (ANTLR_UINT8*) "'<<'",
        (ANTLR_UINT8*) "'<<-'",
        (ANTLR_UINT8*) "'<<<'",
        (ANTLR_UINT8*) "'<='",
        (ANTLR_UINT8*) "'<>'",
        (ANTLR_UINT8*) "'='",
        (ANTLR_UINT8*) "'=='",
        (ANTLR_UINT8*) "'>&'",
        (ANTLR_UINT8*) "'>'",
        (ANTLR_UINT8*) "'>='",
        (ANTLR_UINT8*) "'>>'",
        (ANTLR_UINT8*) "'>|'",
        (ANTLR_UINT8*) "'\\''",
        (ANTLR_UINT8*) "'\\n'",
        (ANTLR_UINT8*) "'awk'",
        (ANTLR_UINT8*) "'case'",
        (ANTLR_UINT8*) "'cat'",
        (ANTLR_UINT8*) "'cut'",
        (ANTLR_UINT8*) "'datamash'",
        (ANTLR_UINT8*) "'do'",
        (ANTLR_UINT8*) "'done'",
        (ANTLR_UINT8*) "'elif'",
        (ANTLR_UINT8*) "'else'",
        (ANTLR_UINT8*) "'esac'",
        (ANTLR_UINT8*) "'fi'",
        (ANTLR_UINT8*) "'for'",
        (ANTLR_UINT8*) "'function'",
        (ANTLR_UINT8*) "'grep'",
        (ANTLR_UINT8*) "'head'",
        (ANTLR_UINT8*) "'if'",
        (ANTLR_UINT8*) "'in'",
        (ANTLR_UINT8*) "'join'",
        (ANTLR_UINT8*) "'print'",
        (ANTLR_UINT8*) "'sort'",
        (ANTLR_UINT8*) "'tail'",
        (ANTLR_UINT8*) "'tee'",
        (ANTLR_UINT8*) "'then'",
        (ANTLR_UINT8*) "'uniq'",
        (ANTLR_UINT8*) "'until'",
        (ANTLR_UINT8*) "'wc -l'",
        (ANTLR_UINT8*) "'while'",
        (ANTLR_UINT8*) "'{'",
        (ANTLR_UINT8*) "'||'",
        (ANTLR_UINT8*) "'}'",
        (ANTLR_UINT8*) "'~/'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SimpleBashSQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SimpleBashSQLParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SimpleBashSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SimpleBashSQLParser::SimpleBashSQLParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SimpleBashSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SimpleBashSQLParser::SimpleBashSQLParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SimpleBashSQLParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SimpleBashSQLParserTokenNames );


}

void
SimpleBashSQLParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SimpleBashSQLParser::~SimpleBashSQLParser()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SimpleBashSQLParserTokenNames;
}


    	TheQuery *lastquery=NULL;
    	char tobeprint=1;
    	/*when it should work as a bashscript, a sqltool is needed*/
    	string sqltool="";
    /*------------------------------------------------------------------
     * Methods for Bash commands
     *------------------------------------------------------------------*/

    	/** grep: parse pattern for grep as a condition for WHERE
    		the columns will be linked with '||'
    		fromopts: opts like -v verbose to include */
    	int zugrep(std::string pattern, int fromopts, TheQuery *abfrage)
    	{
    		stringstream condition;
    		condition << "$1";

    		for(int i=2; i<=abfrage->getColumnsCount(); i++){
    			condition << " || $" << i;
    		}
    		condition << " like '%" << pattern << "%'";
    		if(fromopts==0)
    			abfrage->addCondition(condition.str());
    		else if(fromopts==1)
    			abfrage->addCondition("NOT("+condition.str()+")");

    	}
    	
    	/** parses a list from bash options like d1,2,4-6
    		into a vector like 1,2,4,5,6 returns the vector */
    	std::vector<int> parseListe(char*e)
    	{
    		std::vector<int> mylist;
    		int a,b,ret;
    		do{
    			e++;
    			ret=sscanf(e,"%d-%d",&a,&b);
    			/* a is first field, b the last*/
    			if(ret==0)/*error*/
    				return mylist;
    			/* all columns from a till b */
    			else if(ret==2){
    				for(;a<=b;a++){
    				   mylist.push_back(a);
    				}
    			}else{
    				/*only one selected*/
    				mylist.push_back(a);
    			}
    			while((*e>='0' && *e<='9')||*e=='-')
    				e++;
    		}while(*e==',');

    		return mylist;
    	}

    	/* sort */
    	int optssort(char* e, TheQuery* q){
    		/*until last character*/
    		while(*++e!=0){
    			switch (*e){
    			case 'k':
    				q->addOrder(parseListe(e));
    				break;
    			case 'u':
    				q->setDistinct();
    				break;
    			case 'r':
    				//strcat(q->orderby,"desc");
    				break;
    			}
    		}
    		return 1;
    	}
    	
    	/*  cut */
    	int optscut(char* e, TheQuery* q){
    		/*until last character*/
    		while(*++e!=0){
    			switch (*e){
    			case 'f':
    				q->addSelect(parseListe(e));
    				break;
    			}
    		}
    		return 1;
    	}

    	/*  cut */
    	int optsdatamash(char* e, TheQuery* q){
    		/*until last character*/
    		while(*++e!=0){
    			switch (*e){
    			case 'g':
    				q->addGroup(parseListe(e));
    				break;
    			}
    		}
    		return 1;
    	}

    	/*  grep */
    	int optsgrep(char* e, TheQuery* q){
    		int ret = 0;
    		/*until last character*/
    		while(*++e!=0){
    			switch (*e){
    			case 'v':
    				ret=1;
    				break;
    			case 'c':
    				q->addSelect("count(*)");
    				break;
    			}
    		}
    		return ret;
    	}

    	/*  join */
    	int optsjoin(char* e, TheQuery* q){
    		/*until last character*/
    		/*while(*++e!=0){
    			switch (*e){
    			case 'f':
    				parseListe(e,q->felder);
    				break;
    			}
    		}*/
    		return 1;
    	}

    	/*  uniq */
    	int optsuniq(char* e, TheQuery* q){
    		/*until last character*/
    		while(*++e!=0){
    			switch (*e){
    			case 'c':
    				q->addSelect("count(*)");
    				break;
    			}
    		}
    		return 1;
    	}

    	/*  cut */
    	int optswc(char* e, TheQuery* q){
    		/*until last character*/
    		while(*++e!=0){
    			switch (*e){
    			case 'l':
    				break;
    			}
    		}
    		return 1;
    	}
    	/*replaces each appearance of oldStr with newStr in str*/
    	void replace_inline_grammar(std::string& str, const std::string& oldStr, const std::string& newStr)
    	{
    	  size_t pos = 0;
    	  while((pos = str.find(oldStr, pos)) != std::string::npos)
    	  {
    	    str.replace(pos, oldStr.length(), newStr);
    	    pos += newStr.length();
    	  }
    	}

    	void printhelp()
    	{
    		cout << " Usage: " << endl;
    		cout << " simplebashsql scriptname [sqltool] " << endl;
    	}

    /*------------------------------------------------------------------
     * Main
     *------------------------------------------------------------------*/
    	int main(int argc, char * argv[])
     	{
    		if(argc<2){
    			printf("%s: missing operand\n",argv[0]);
    			printhelp();
    			return 1;
    		}else if(argc>2){
    			/*second parameter is the sqltool*/
    			sqltool = argv[2];
    		}

    		ANTLR_UINT8* fName = (ANTLR_UINT8*) argv[1];
    		SimpleBashSQLLexer::InputStreamType input(fName, ANTLR_ENC_8BIT);
    		SimpleBashSQLLexer lxr(&input); // TLexerNew is generated by ANTLR
    		SimpleBashSQLParser::TokenStreamType tstream(ANTLR_SIZE_HINT, lxr.get_tokSource() );
    		SimpleBashSQLParser psr(&tstream); // TParserNew is generated by ANTLR3
    		psr.file();
    		return 0;
    	}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_newline_in_file69_bits[]	= { ANTLR_UINT64_LIT(0x07ED9240019D8402), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_newline_in_file69( FOLLOW_newline_in_file69_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_53_in_newline78_bits[]	= { ANTLR_UINT64_LIT(0x07ED924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_53_in_newline78( FOLLOW_53_in_newline78_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_simple_list_in_newline82_bits[]	= { ANTLR_UINT64_LIT(0x0020001000400000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_simple_list_in_newline82( FOLLOW_simple_list_in_newline82_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_newline85_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_newline85( FOLLOW_set_in_newline85_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_comment_in_newline100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_comment_in_newline100( FOLLOW_comment_in_newline100_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_comment109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000012) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_20_in_comment109( FOLLOW_20_in_comment109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_alchar_in_comment111_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000012) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_alchar_in_comment111( FOLLOW_alchar_in_comment111_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_19_in_comment117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_19_in_comment117( FOLLOW_19_in_comment117_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_simple_list135_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001848400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_16_in_simple_list135( FOLLOW_16_in_simple_list135_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_pipeline_cmd_in_simple_list139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200002), ANTLR_UINT64_LIT(0x0000000000040000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_pipeline_cmd_in_simple_list139( FOLLOW_pipeline_cmd_in_simple_list139_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_simple_list143_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001848400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_simple_list143( FOLLOW_set_in_simple_list143_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_pipeline_cmd_in_simple_list151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200002), ANTLR_UINT64_LIT(0x0000000000040000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_pipeline_cmd_in_simple_list151( FOLLOW_pipeline_cmd_in_simple_list151_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_command_in_pipeline_cmd166_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_command_in_pipeline_cmd166( FOLLOW_command_in_pipeline_cmd166_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_PIPE_in_pipeline_cmd177_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001848400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_PIPE_in_pipeline_cmd177( FOLLOW_PIPE_in_pipeline_cmd177_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_command_in_pipeline_cmd181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_command_in_pipeline_cmd181( FOLLOW_command_in_pipeline_cmd181_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_cmd_in_command208_bits[]	= { ANTLR_UINT64_LIT(0x000D924000800402) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_cmd_in_command208( FOLLOW_cmd_in_command208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_other_redir_in_command211_bits[]	= { ANTLR_UINT64_LIT(0x000D924000800402) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_other_redir_in_command211( FOLLOW_other_redir_in_command211_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_to_redir_in_command213_bits[]	= { ANTLR_UINT64_LIT(0x000D924000800402) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_to_redir_in_command213( FOLLOW_to_redir_in_command213_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_shell_cmd_in_command219_bits[]	= { ANTLR_UINT64_LIT(0x000897C000800402) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_shell_cmd_in_command219( FOLLOW_shell_cmd_in_command219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_redirection_in_command222_bits[]	= { ANTLR_UINT64_LIT(0x000897C000800402) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_redirection_in_command222( FOLLOW_redirection_in_command222_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_24_in_subshell230_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_24_in_subshell230( FOLLOW_24_in_subshell230_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_subshell232_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_subshell232( FOLLOW_compound_list_in_subshell232_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_25_in_subshell235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_25_in_subshell235( FOLLOW_25_in_subshell235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_simple_list_in_compound_list245_bits[]	= { ANTLR_UINT64_LIT(0x0020001000400002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_simple_list_in_compound_list245( FOLLOW_simple_list_in_compound_list245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_compound_list252_bits[]	= { ANTLR_UINT64_LIT(0x07ED924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_compound_list252( FOLLOW_set_in_compound_list252_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_53_in_compound_list265_bits[]	= { ANTLR_UINT64_LIT(0x07ED924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_53_in_compound_list265( FOLLOW_53_in_compound_list265_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_simple_list_in_compound_list269_bits[]	= { ANTLR_UINT64_LIT(0x0020001000400002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_simple_list_in_compound_list269( FOLLOW_simple_list_in_compound_list269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_redirection280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_redirection280( FOLLOW_from_redir_in_redirection280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_other_redir_in_redirection284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_other_redir_in_redirection284( FOLLOW_other_redir_in_redirection284_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_to_redir292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_to_redir292( FOLLOW_set_in_to_redir292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_to_redir298_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_to_redir298( FOLLOW_word_in_to_redir298_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_from_redir315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_from_redir315( FOLLOW_set_in_from_redir315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_from_redir323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_from_redir323( FOLLOW_word_in_from_redir323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_39_in_from_redir334_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_39_in_from_redir334( FOLLOW_39_in_from_redir334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_subshell_in_from_redir336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_subshell_in_from_redir336( FOLLOW_subshell_in_from_redir336_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir371_bits[]	= { ANTLR_UINT64_LIT(0x0001000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir371( FOLLOW_number_in_other_redir371_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_48_in_other_redir373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_48_in_other_redir373( FOLLOW_48_in_other_redir373_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir375( FOLLOW_word_in_other_redir375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir396_bits[]	= { ANTLR_UINT64_LIT(0x0000008000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir396( FOLLOW_number_in_other_redir396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_39_in_other_redir398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_39_in_other_redir398( FOLLOW_39_in_other_redir398_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir400( FOLLOW_word_in_other_redir400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir421_bits[]	= { ANTLR_UINT64_LIT(0x0004000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir421( FOLLOW_number_in_other_redir421_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_50_in_other_redir423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_50_in_other_redir423( FOLLOW_50_in_other_redir423_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir425( FOLLOW_word_in_other_redir425_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir446_bits[]	= { ANTLR_UINT64_LIT(0x0000010000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir446( FOLLOW_number_in_other_redir446_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_40_in_other_redir448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_40_in_other_redir448( FOLLOW_40_in_other_redir448_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir450( FOLLOW_word_in_other_redir450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_other_redir471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_38_in_other_redir471( FOLLOW_38_in_other_redir471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir473( FOLLOW_number_in_other_redir473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir494_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir494( FOLLOW_number_in_other_redir494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_other_redir496_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_38_in_other_redir496( FOLLOW_38_in_other_redir496_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir498( FOLLOW_number_in_other_redir498_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_47_in_other_redir519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_47_in_other_redir519( FOLLOW_47_in_other_redir519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir521( FOLLOW_number_in_other_redir521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir542_bits[]	= { ANTLR_UINT64_LIT(0x0000800000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir542( FOLLOW_number_in_other_redir542_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_47_in_other_redir544_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_47_in_other_redir544( FOLLOW_47_in_other_redir544_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir546( FOLLOW_number_in_other_redir546_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_other_redir567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_38_in_other_redir567( FOLLOW_38_in_other_redir567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir569( FOLLOW_word_in_other_redir569_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir590_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir590( FOLLOW_number_in_other_redir590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_other_redir592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_38_in_other_redir592( FOLLOW_38_in_other_redir592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir594_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir594( FOLLOW_word_in_other_redir594_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_47_in_other_redir615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_47_in_other_redir615( FOLLOW_47_in_other_redir615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir617( FOLLOW_word_in_other_redir617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir638_bits[]	= { ANTLR_UINT64_LIT(0x0000800000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir638( FOLLOW_number_in_other_redir638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_47_in_other_redir640_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_47_in_other_redir640( FOLLOW_47_in_other_redir640_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir642( FOLLOW_word_in_other_redir642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_41_in_other_redir663_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_41_in_other_redir663( FOLLOW_41_in_other_redir663_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir665( FOLLOW_word_in_other_redir665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir686_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir686( FOLLOW_number_in_other_redir686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_41_in_other_redir688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_41_in_other_redir688( FOLLOW_41_in_other_redir688_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir690( FOLLOW_word_in_other_redir690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_47_in_other_redir711_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_47_in_other_redir711( FOLLOW_47_in_other_redir711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_other_redir713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_31_in_other_redir713( FOLLOW_31_in_other_redir713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir734_bits[]	= { ANTLR_UINT64_LIT(0x0000800000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir734( FOLLOW_number_in_other_redir734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_47_in_other_redir736_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_47_in_other_redir736( FOLLOW_47_in_other_redir736_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_other_redir738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_31_in_other_redir738( FOLLOW_31_in_other_redir738_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_other_redir759_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_38_in_other_redir759( FOLLOW_38_in_other_redir759_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_other_redir761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_31_in_other_redir761( FOLLOW_31_in_other_redir761_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir782_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir782( FOLLOW_number_in_other_redir782_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_other_redir784_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_38_in_other_redir784( FOLLOW_38_in_other_redir784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_other_redir786_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_31_in_other_redir786( FOLLOW_31_in_other_redir786_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_other_redir807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_23_in_other_redir807( FOLLOW_23_in_other_redir807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir809_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir809( FOLLOW_word_in_other_redir809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir830_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir830( FOLLOW_number_in_other_redir830_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_44_in_other_redir832_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_44_in_other_redir832( FOLLOW_44_in_other_redir832_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir834( FOLLOW_word_in_other_redir834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_44_in_other_redir855_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_44_in_other_redir855( FOLLOW_44_in_other_redir855_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir857( FOLLOW_word_in_other_redir857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_51_in_other_redir878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_51_in_other_redir878( FOLLOW_51_in_other_redir878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir880( FOLLOW_word_in_other_redir880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_other_redir901_bits[]	= { ANTLR_UINT64_LIT(0x0008000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_other_redir901( FOLLOW_number_in_other_redir901_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_51_in_other_redir903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_51_in_other_redir903( FOLLOW_51_in_other_redir903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_other_redir905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_other_redir905( FOLLOW_word_in_other_redir905_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_command_in_shell_cmd914_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_for_command_in_shell_cmd914( FOLLOW_for_command_in_shell_cmd914_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_case_command_in_shell_cmd937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_case_command_in_shell_cmd937( FOLLOW_case_command_in_shell_cmd937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_80_in_shell_cmd960_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_80_in_shell_cmd960( FOLLOW_80_in_shell_cmd960_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_shell_cmd962_bits[]	= { ANTLR_UINT64_LIT(0x0800000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_shell_cmd962( FOLLOW_compound_list_in_shell_cmd962_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_59_in_shell_cmd965_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_59_in_shell_cmd965( FOLLOW_59_in_shell_cmd965_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_shell_cmd967_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_shell_cmd967( FOLLOW_compound_list_in_shell_cmd967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_60_in_shell_cmd970_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_60_in_shell_cmd970( FOLLOW_60_in_shell_cmd970_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_78_in_shell_cmd993_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_78_in_shell_cmd993( FOLLOW_78_in_shell_cmd993_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_shell_cmd995_bits[]	= { ANTLR_UINT64_LIT(0x0800000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_shell_cmd995( FOLLOW_compound_list_in_shell_cmd995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_59_in_shell_cmd998_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_59_in_shell_cmd998( FOLLOW_59_in_shell_cmd998_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_shell_cmd1000_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_shell_cmd1000( FOLLOW_compound_list_in_shell_cmd1000_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_60_in_shell_cmd1003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_60_in_shell_cmd1003( FOLLOW_60_in_shell_cmd1003_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_if_command_in_shell_cmd1026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_if_command_in_shell_cmd1026( FOLLOW_if_command_in_shell_cmd1026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_subshell_in_shell_cmd1049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_subshell_in_shell_cmd1049( FOLLOW_subshell_in_shell_cmd1049_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_group_command_in_shell_cmd1072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_group_command_in_shell_cmd1072( FOLLOW_group_command_in_shell_cmd1072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_def_in_shell_cmd1095_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_function_def_in_shell_cmd1095( FOLLOW_function_def_in_shell_cmd1095_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_header_in_for_command1103_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_for_header_in_for_command1103( FOLLOW_for_header_in_for_command1103_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_for_command1113_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_for_command1113( FOLLOW_compound_list_in_for_command1113_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_for_command1116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_for_command1116( FOLLOW_set_in_for_command1116_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_65_in_for_header1136_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_65_in_for_header1136( FOLLOW_65_in_for_header1136_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_for_header1138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_for_header1138( FOLLOW_word_in_for_header1138_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_70_in_for_header1140_bits[]	= { ANTLR_UINT64_LIT(0x0020001000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_70_in_for_header1140( FOLLOW_70_in_for_header1140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_for_header1142_bits[]	= { ANTLR_UINT64_LIT(0x0020001000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_for_header1142( FOLLOW_word_in_for_header1142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_for_header1145_bits[]	= { ANTLR_UINT64_LIT(0x0800000000000000), ANTLR_UINT64_LIT(0x0000000000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_for_header1145( FOLLOW_set_in_for_header1145_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_for_header1151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_for_header1151( FOLLOW_set_in_for_header1151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_69_in_if_command1165_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_69_in_if_command1165( FOLLOW_69_in_if_command1165_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_if_command1167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_if_command1167( FOLLOW_compound_list_in_if_command1167_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_76_in_if_command1170_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_76_in_if_command1170( FOLLOW_76_in_if_command1170_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_if_command1172_bits[]	= { ANTLR_UINT64_LIT(0x6000000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_if_command1172( FOLLOW_compound_list_in_if_command1172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_61_in_if_command1176_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_61_in_if_command1176( FOLLOW_61_in_if_command1176_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_if_command1178_bits[]	= { ANTLR_UINT64_LIT(0x6000000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_if_command1178( FOLLOW_compound_list_in_if_command1178_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_62_in_if_command1183_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_62_in_if_command1183( FOLLOW_62_in_if_command1183_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_if_command1185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_if_command1185( FOLLOW_compound_list_in_if_command1185_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_64_in_if_command1188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_64_in_if_command1188( FOLLOW_64_in_if_command1188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_81_in_group_command1196_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_81_in_group_command1196( FOLLOW_81_in_group_command1196_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_group_command1198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_group_command1198( FOLLOW_compound_list_in_group_command1198_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_83_in_group_command1201_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_83_in_group_command1201( FOLLOW_83_in_group_command1201_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_66_in_function_def1211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_66_in_function_def1211( FOLLOW_66_in_function_def1211_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_function_def1215_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_function_def1215( FOLLOW_word_in_function_def1215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_24_in_function_def1217_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_24_in_function_def1217( FOLLOW_24_in_function_def1217_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_25_in_function_def1219_bits[]	= { ANTLR_UINT64_LIT(0x0020001000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_25_in_function_def1219( FOLLOW_25_in_function_def1219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_function_def1221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_function_def1221( FOLLOW_set_in_function_def1221_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_group_command_in_function_def1230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_group_command_in_function_def1230( FOLLOW_group_command_in_function_def1230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_55_in_case_command1240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_55_in_case_command1240( FOLLOW_55_in_case_command1240_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_case_command1242_bits[]	= { ANTLR_UINT64_LIT(0x0020001000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_case_command1242( FOLLOW_word_in_case_command1242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_case_command1244_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_case_command1244( FOLLOW_set_in_case_command1244_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_70_in_case_command1252_bits[]	= { ANTLR_UINT64_LIT(0x0020001000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_70_in_case_command1252( FOLLOW_70_in_case_command1252_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_case_command1254_bits[]	= { ANTLR_UINT64_LIT(0x8000000002000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_case_command1254( FOLLOW_set_in_case_command1254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_case_clause_in_case_command1262_bits[]	= { ANTLR_UINT64_LIT(0x8000000002000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_case_clause_in_case_command1262( FOLLOW_case_clause_in_case_command1262_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_63_in_case_command1265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_63_in_case_command1265( FOLLOW_63_in_case_command1265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_pattern_in_case_clause1272_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_pattern_in_case_clause1272( FOLLOW_pattern_in_case_clause1272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_25_in_case_clause1274_bits[]	= { ANTLR_UINT64_LIT(0x07CD924001858400), ANTLR_UINT64_LIT(0x000000000003EEBE) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_25_in_case_clause1274( FOLLOW_25_in_case_clause1274_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_list_in_case_clause1276_bits[]	= { ANTLR_UINT64_LIT(0x0000002000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_compound_list_in_case_clause1276( FOLLOW_compound_list_in_case_clause1276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_37_in_case_clause1279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_37_in_case_clause1279( FOLLOW_37_in_case_clause1279_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_57_in_cmd1306_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048800) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_57_in_cmd1306( FOLLOW_57_in_cmd1306_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1311_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1311( FOLLOW_opts_in_cmd1311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1326_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1326( FOLLOW_word_in_cmd1326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1339_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1339( FOLLOW_from_redir_in_cmd1339_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd1352_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd1352( FOLLOW_30_in_cmd1352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_56_in_cmd1369_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_56_in_cmd1369( FOLLOW_56_in_cmd1369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1374_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1374( FOLLOW_opts_in_cmd1374_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1381_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1381( FOLLOW_word_in_cmd1381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1395_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1395( FOLLOW_from_redir_in_cmd1395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd1408_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd1408( FOLLOW_30_in_cmd1408_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_67_in_cmd1425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048800) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_67_in_cmd1425( FOLLOW_67_in_cmd1425_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048800) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1432( FOLLOW_opts_in_cmd1432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1452_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1452( FOLLOW_word_in_cmd1452_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1463_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1463( FOLLOW_opts_in_cmd1463_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1479_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1479( FOLLOW_word_in_cmd1479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1493_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1493( FOLLOW_from_redir_in_cmd1493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd1506_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd1506( FOLLOW_30_in_cmd1506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_73_in_cmd1523_bits[]	= { ANTLR_UINT64_LIT(0x0000058000048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_73_in_cmd1523( FOLLOW_73_in_cmd1523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1527_bits[]	= { ANTLR_UINT64_LIT(0x0000058000048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1527( FOLLOW_opts_in_cmd1527_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1541_bits[]	= { ANTLR_UINT64_LIT(0x0000058000048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1541( FOLLOW_word_in_cmd1541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1554_bits[]	= { ANTLR_UINT64_LIT(0x0000058000048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1554( FOLLOW_from_redir_in_cmd1554_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_68_in_cmd1577_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_68_in_cmd1577( FOLLOW_68_in_cmd1577_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1581_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1581( FOLLOW_opts_in_cmd1581_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_32_in_cmd1590_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_32_in_cmd1590( FOLLOW_32_in_cmd1590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_33_in_cmd1594_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_33_in_cmd1594( FOLLOW_33_in_cmd1594_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1601_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1601( FOLLOW_word_in_cmd1601_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1615_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1615( FOLLOW_from_redir_in_cmd1615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd1628_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd1628( FOLLOW_30_in_cmd1628_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_74_in_cmd1646_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_74_in_cmd1646( FOLLOW_74_in_cmd1646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1650_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1650( FOLLOW_opts_in_cmd1650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_32_in_cmd1659_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_32_in_cmd1659( FOLLOW_32_in_cmd1659_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_33_in_cmd1663_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_33_in_cmd1663( FOLLOW_33_in_cmd1663_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1670_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1670( FOLLOW_word_in_cmd1670_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1684_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1684( FOLLOW_from_redir_in_cmd1684_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd1697_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd1697( FOLLOW_30_in_cmd1697_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_71_in_cmd1716_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048800) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_71_in_cmd1716( FOLLOW_71_in_cmd1716_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_32_in_cmd1720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_32_in_cmd1720( FOLLOW_32_in_cmd1720_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_cmd1724_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_cmd1724( FOLLOW_number_in_cmd1724_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_33_in_cmd1746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_33_in_cmd1746( FOLLOW_33_in_cmd1746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_cmd1750_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_cmd1750( FOLLOW_number_in_cmd1750_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_OPTS_in_cmd1771_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_OPTS_in_cmd1771( FOLLOW_OPTS_in_cmd1771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1791_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1791( FOLLOW_word_in_cmd1791_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd1816_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd1816( FOLLOW_30_in_cmd1816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1843_bits[]	= { ANTLR_UINT64_LIT(0x0000058340048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1843( FOLLOW_from_redir_in_cmd1843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_75_in_cmd1898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_75_in_cmd1898( FOLLOW_75_in_cmd1898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1901_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1901( FOLLOW_word_in_cmd1901_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_77_in_cmd1914_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_77_in_cmd1914( FOLLOW_77_in_cmd1914_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd1918_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd1918( FOLLOW_opts_in_cmd1918_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd1931_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd1931( FOLLOW_word_in_cmd1931_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd1965_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd1965( FOLLOW_from_redir_in_cmd1965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd2027_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd2027( FOLLOW_30_in_cmd2027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_79_in_cmd2063_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_79_in_cmd2063( FOLLOW_79_in_cmd2063_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd2076_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd2076( FOLLOW_opts_in_cmd2076_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd2090_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd2090( FOLLOW_word_in_cmd2090_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd2124_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd2124( FOLLOW_from_redir_in_cmd2124_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd2186_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd2186( FOLLOW_30_in_cmd2186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_54_in_cmd2228_bits[]	= { ANTLR_UINT64_LIT(0x0010000000000800) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_54_in_cmd2228( FOLLOW_54_in_cmd2228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_OPTS_in_cmd2230_bits[]	= { ANTLR_UINT64_LIT(0x0010000000000800) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_OPTS_in_cmd2230( FOLLOW_OPTS_in_cmd2230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_52_in_cmd2233_bits[]	= { ANTLR_UINT64_LIT(0x0020000000048400), ANTLR_UINT64_LIT(0x0000000000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_52_in_cmd2233( FOLLOW_52_in_cmd2233_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_53_in_cmd2236_bits[]	= { ANTLR_UINT64_LIT(0x0020000000048400), ANTLR_UINT64_LIT(0x0000000000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_53_in_cmd2236( FOLLOW_53_in_cmd2236_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkbody_in_cmd2245_bits[]	= { ANTLR_UINT64_LIT(0x0030000000048400), ANTLR_UINT64_LIT(0x0000000000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkbody_in_cmd2245( FOLLOW_awkbody_in_cmd2245_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_53_in_cmd2249_bits[]	= { ANTLR_UINT64_LIT(0x0030000000048400), ANTLR_UINT64_LIT(0x0000000000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_53_in_cmd2249( FOLLOW_53_in_cmd2249_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_52_in_cmd2255_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_52_in_cmd2255( FOLLOW_52_in_cmd2255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_assignment_in_cmd2258_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_assignment_in_cmd2258( FOLLOW_assignment_in_cmd2258_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_OPTS_in_cmd2260_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_OPTS_in_cmd2260( FOLLOW_OPTS_in_cmd2260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd2298_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd2298( FOLLOW_word_in_cmd2298_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd2312_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd2312( FOLLOW_from_redir_in_cmd2312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd2325_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd2325( FOLLOW_30_in_cmd2325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_58_in_cmd2341_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_58_in_cmd2341( FOLLOW_58_in_cmd2341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_opts_in_cmd2345_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_opts_in_cmd2345( FOLLOW_opts_in_cmd2345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd2358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd2358( FOLLOW_word_in_cmd2358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_cmd2360_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_cmd2360( FOLLOW_number_in_cmd2360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_from_redir_in_cmd2394_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_from_redir_in_cmd2394( FOLLOW_from_redir_in_cmd2394_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_cmd2456_bits[]	= { ANTLR_UINT64_LIT(0x0000058040048802) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_30_in_cmd2456( FOLLOW_30_in_cmd2456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_cmd2494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_cmd2494( FOLLOW_word_in_cmd2494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_assignment2509_bits[]	= { ANTLR_UINT64_LIT(0x0000200000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_assignment2509( FOLLOW_word_in_assignment2509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_45_in_assignment2510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_45_in_assignment2510( FOLLOW_45_in_assignment2510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_assignment2511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_assignment2511( FOLLOW_word_in_assignment2511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkpattern_in_awkbody2534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000), ANTLR_UINT64_LIT(0x0000000000060000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkpattern_in_awkbody2534( FOLLOW_awkpattern_in_awkbody2534_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_awkbody2547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_awkbody2547( FOLLOW_set_in_awkbody2547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkpattern_in_awkbody2557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000), ANTLR_UINT64_LIT(0x0000000000060000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkpattern_in_awkbody2557( FOLLOW_awkpattern_in_awkbody2557_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_81_in_awkbody2605_bits[]	= { ANTLR_UINT64_LIT(0x0020000000048000), ANTLR_UINT64_LIT(0x0000000000000120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_81_in_awkbody2605( FOLLOW_81_in_awkbody2605_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_53_in_awkbody2608_bits[]	= { ANTLR_UINT64_LIT(0x0020000000048000), ANTLR_UINT64_LIT(0x0000000000000120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_53_in_awkbody2608( FOLLOW_53_in_awkbody2608_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkcmds_in_awkbody2613_bits[]	= { ANTLR_UINT64_LIT(0x0020000000048000), ANTLR_UINT64_LIT(0x0000000000080120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkcmds_in_awkbody2613( FOLLOW_awkcmds_in_awkbody2613_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_53_in_awkbody2617_bits[]	= { ANTLR_UINT64_LIT(0x0020000000048000), ANTLR_UINT64_LIT(0x0000000000080120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_53_in_awkbody2617( FOLLOW_53_in_awkbody2617_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_83_in_awkbody2624_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_83_in_awkbody2624( FOLLOW_83_in_awkbody2624_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkpatternparsed_in_awkpattern2656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkpatternparsed_in_awkpattern2656( FOLLOW_awkpatternparsed_in_awkpattern2656_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkpatternparsed2674_bits[]	= { ANTLR_UINT64_LIT(0x0003488000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkpatternparsed2674( FOLLOW_word_in_awkpatternparsed2674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_awkpatternparsed2678_bits[]	= { ANTLR_UINT64_LIT(0x0003488000020000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_awkpatternparsed2678( FOLLOW_number_in_awkpatternparsed2678_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_awkpatternparsed2681_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_awkpatternparsed2681( FOLLOW_set_in_awkpatternparsed2681_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkpatternparsed2698_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkpatternparsed2698( FOLLOW_word_in_awkpatternparsed2698_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_awkpatternparsed2702_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_awkpatternparsed2702( FOLLOW_number_in_awkpatternparsed2702_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkpatternparsed2709_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkpatternparsed2709( FOLLOW_word_in_awkpatternparsed2709_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_awkpatternparsed2711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_awkpatternparsed2711( FOLLOW_number_in_awkpatternparsed2711_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_84_in_awkpatternparsed2714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_84_in_awkpatternparsed2714( FOLLOW_84_in_awkpatternparsed2714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkpatternparsed2716_bits[]	= { ANTLR_UINT64_LIT(0x0000000800000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkpatternparsed2716( FOLLOW_word_in_awkpatternparsed2716_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_35_in_awkpatternparsed2718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_35_in_awkpatternparsed2718( FOLLOW_35_in_awkpatternparsed2718_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_72_in_awkcmds2738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048010) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_72_in_awkcmds2738( FOLLOW_72_in_awkcmds2738_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awklist_in_awkcmds2742_bits[]	= { ANTLR_UINT64_LIT(0x0000001000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awklist_in_awkcmds2742( FOLLOW_awklist_in_awkcmds2742_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkop_in_awkcmds2749_bits[]	= { ANTLR_UINT64_LIT(0x0000001000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkop_in_awkcmds2749( FOLLOW_awkop_in_awkcmds2749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkif_in_awkcmds2755_bits[]	= { ANTLR_UINT64_LIT(0x0000001000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkif_in_awkcmds2755( FOLLOW_awkif_in_awkcmds2755_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_36_in_awkcmds2762_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_36_in_awkcmds2762( FOLLOW_36_in_awkcmds2762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkop2777_bits[]	= { ANTLR_UINT64_LIT(0x0000200428000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkop2777( FOLLOW_word_in_awkop2777_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_awkop2779_bits[]	= { ANTLR_UINT64_LIT(0x0000000001048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_awkop2779( FOLLOW_set_in_awkop2779_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkmath_in_awkop2789_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkmath_in_awkop2789( FOLLOW_awkmath_in_awkop2789_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_24_in_awkmath2803_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_24_in_awkmath2803( FOLLOW_24_in_awkmath2803_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkmath2807_bits[]	= { ANTLR_UINT64_LIT(0x0000000896000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkmath2807( FOLLOW_word_in_awkmath2807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_awkmath2809_bits[]	= { ANTLR_UINT64_LIT(0x0000000896000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_number_in_awkmath2809( FOLLOW_number_in_awkmath2809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_25_in_awkmath2812_bits[]	= { ANTLR_UINT64_LIT(0x0000000894000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_25_in_awkmath2812( FOLLOW_25_in_awkmath2812_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_awkmath2821_bits[]	= { ANTLR_UINT64_LIT(0x0000000001048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_set_in_awkmath2821( FOLLOW_set_in_awkmath2821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkmath_in_awkmath2831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkmath_in_awkmath2831( FOLLOW_awkmath_in_awkmath2831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkexpr_in_awklist2851_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkexpr_in_awklist2851( FOLLOW_awkexpr_in_awklist2851_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_69_in_awkif2866_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_69_in_awkif2866( FOLLOW_69_in_awkif2866_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_24_in_awkif2868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_24_in_awkif2868( FOLLOW_24_in_awkif2868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkpattern_in_awkif2870_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkpattern_in_awkif2870( FOLLOW_awkpattern_in_awkif2870_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_25_in_awkif2872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000), ANTLR_UINT64_LIT(0x0000000000020120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_25_in_awkif2872( FOLLOW_25_in_awkif2872_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_81_in_awkif2875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000), ANTLR_UINT64_LIT(0x0000000000000120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_81_in_awkif2875( FOLLOW_81_in_awkif2875_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkcmds_in_awkif2877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkcmds_in_awkif2877( FOLLOW_awkcmds_in_awkif2877_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_83_in_awkif2880_bits[]	= { ANTLR_UINT64_LIT(0x4000000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_83_in_awkif2880( FOLLOW_83_in_awkif2880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkcmds_in_awkif2883_bits[]	= { ANTLR_UINT64_LIT(0x4000000000000000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkcmds_in_awkif2883( FOLLOW_awkcmds_in_awkif2883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_62_in_awkif2891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048000), ANTLR_UINT64_LIT(0x0000000000020120) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_62_in_awkif2891( FOLLOW_62_in_awkif2891_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_81_in_awkif2894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000048400) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_81_in_awkif2894( FOLLOW_81_in_awkif2894_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkpattern_in_awkif2896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkpattern_in_awkif2896( FOLLOW_awkpattern_in_awkif2896_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_83_in_awkif2898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_83_in_awkif2898( FOLLOW_83_in_awkif2898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_awkcmds_in_awkif2901_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_awkcmds_in_awkif2901( FOLLOW_awkcmds_in_awkif2901_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_word_in_awkexpr2915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_word_in_awkexpr2915( FOLLOW_word_in_awkexpr2915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_alchar_in_awkexpr2920_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_alchar_in_awkexpr2920( FOLLOW_alchar_in_awkexpr2920_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_NUMBER_in_number2941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_NUMBER_in_number2941( FOLLOW_NUMBER_in_number2941_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_WORD_in_word2947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_WORD_in_word2947( FOLLOW_WORD_in_word2947_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_word2950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_18_in_word2950( FOLLOW_18_in_word2950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_WORD_in_word2952_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_WORD_in_word2952( FOLLOW_WORD_in_word2952_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_word2954_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_18_in_word2954( FOLLOW_18_in_word2954_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_OPTS_in_opts2959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_OPTS_in_opts2959( FOLLOW_OPTS_in_opts2959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SimpleBashSQLParser  */
static	ANTLR_BITWORD FOLLOW_ALCHAR_in_alchar2964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SimpleBashSQLParserImplTraits::BitsetListType FOLLOW_ALCHAR_in_alchar2964( FOLLOW_ALCHAR_in_alchar2964_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start file
 * SimpleBashSQL.g:236:1: file : ( newline )* ;
 */
void
SimpleBashSQLParser::file()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:236:5: ( ( newline )* )
        // SimpleBashSQL.g:236:7: ( newline )*
        {
            // SimpleBashSQL.g:236:7: ( newline )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case NUMBER:
                case PIPE:
                case WORD:
                case 16:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 36:
                case 37:
                case 38:
                case 41:
                case 44:
                case 47:
                case 48:
                case 50:
                case 51:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 71:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // SimpleBashSQL.g:236:7: newline
            	    {
            	        this->followPush(FOLLOW_newline_in_file69);
            	        newline();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefileEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefileEx; /* Prevent compiler warnings */
    rulefileEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end file */

/**
 * $ANTLR start newline
 * SimpleBashSQL.g:238:1: newline : ( ( '\\n' )* simple_list[false] ( '\\n' | ';' | '&' ) | comment );
 */
void
SimpleBashSQLParser::newline()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    comment_return comment1;
    /* Initialize rule variables
     */


 
    {
        {
            //  SimpleBashSQL.g:238:8: ( ( '\\n' )* simple_list[false] ( '\\n' | ';' | '&' ) | comment )

            ANTLR_UINT32 alt3;

            alt3=2;

            switch ( this->LA(1) )
            {
            case NUMBER:
            case PIPE:
            case WORD:
            case 16:
            case 18:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 36:
            case 37:
            case 38:
            case 41:
            case 44:
            case 47:
            case 48:
            case 50:
            case 51:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 71:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            	{
            		alt3=1;
            	}
                break;
            case 19:
            case 20:
            	{
            		alt3=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto rulenewlineEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // SimpleBashSQL.g:238:10: ( '\\n' )* simple_list[false] ( '\\n' | ';' | '&' )
        	    {
        	        // SimpleBashSQL.g:238:10: ( '\\n' )*

        	        for (;;)
        	        {
        	            int alt2=2;
        	            switch ( this->LA(1) )
        	            {
        	            case 53:
        	            	{
        	            		alt2=1;
        	            	}
        	                break;

        	            }

        	            switch (alt2)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:238:11: '\\n'
        	        	    {
        	        	         this->matchToken(53, &FOLLOW_53_in_newline78);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenewlineEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop2;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop2: ; /* Jump out to here if this rule does not match */


        	        this->followPush(FOLLOW_simple_list_in_newline82);
        	        simple_list(false);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenewlineEx;
        	        }


        	        if ( this->LA(1) == 22 || this->LA(1) == 36 || this->LA(1) == 53 )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto rulenewlineEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:239:4: comment
        	    {
        	        this->followPush(FOLLOW_comment_in_newline100);
        	        comment1=comment();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenewlineEx;
        	        }


        	        {
        	             cout << (this->get_strstream()->toStringTT(comment1.start, comment1.stop))
        	            ; 
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenewlineEx; /* Prevent compiler warnings */
    rulenewlineEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end newline */

/**
 * $ANTLR start comment
 * SimpleBashSQL.g:241:1: comment : ( '#' ( alchar )* | '#!/bin/bash' );
 */
SimpleBashSQLParser::comment_return
SimpleBashSQLParser::comment()
{
    SimpleBashSQLParser::comment_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        {
            //  SimpleBashSQL.g:241:8: ( '#' ( alchar )* | '#!/bin/bash' )

            ANTLR_UINT32 alt5;

            alt5=2;

            switch ( this->LA(1) )
            {
            case 20:
            	{
            		alt5=1;
            	}
                break;
            case 19:
            	{
            		alt5=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 5 );
                ex->set_state( 0 );


                goto rulecommentEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // SimpleBashSQL.g:241:10: '#' ( alchar )*
        	    {
        	         this->matchToken(20, &FOLLOW_20_in_comment109);
        	        if  (this->hasException())
        	        {
        	            goto rulecommentEx;
        	        }


        	        // SimpleBashSQL.g:241:14: ( alchar )*

        	        for (;;)
        	        {
        	            int alt4=2;
        	            switch ( this->LA(1) )
        	            {
        	            case ALCHAR:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;

        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:241:14: alchar
        	        	    {
        	        	        this->followPush(FOLLOW_alchar_in_comment111);
        	        	        alchar();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecommentEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop4;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop4: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:242:4: '#!/bin/bash'
        	    {
        	         this->matchToken(19, &FOLLOW_19_in_comment117);
        	        if  (this->hasException())
        	        {
        	            goto rulecommentEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecommentEx; /* Prevent compiler warnings */
    rulecommentEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end comment */

/**
 * $ANTLR start simple_list
 * SimpleBashSQL.g:245:1: simple_list[bool isSub] : ( '!' )? pipeline_cmd[isSub] ( ( '&&' | '||' ) pipeline_cmd[isSub] )* ;
 */
void
SimpleBashSQLParser::simple_list(bool isSub)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


    lastquery=NULL;


 
    {
        // SimpleBashSQL.g:249:2: ( ( '!' )? pipeline_cmd[isSub] ( ( '&&' | '||' ) pipeline_cmd[isSub] )* )
        // SimpleBashSQL.g:249:4: ( '!' )? pipeline_cmd[isSub] ( ( '&&' | '||' ) pipeline_cmd[isSub] )*
        {
            // SimpleBashSQL.g:249:4: ( '!' )?
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                    case 16:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6)
                {
            	case 1:
            	    // SimpleBashSQL.g:249:5: '!'
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_simple_list135);
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_listEx;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_pipeline_cmd_in_simple_list139);
            pipeline_cmd(isSub);

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_listEx;
            }


            // SimpleBashSQL.g:249:31: ( ( '&&' | '||' ) pipeline_cmd[isSub] )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case 21:
                case 82:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // SimpleBashSQL.g:249:32: ( '&&' | '||' ) pipeline_cmd[isSub]
            	    {
            	        if ( this->LA(1) == 21 || this->LA(1) == 82 )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	        }
            	        else
            	        {
            	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto rulesimple_listEx;
            	        }


            	        this->followPush(FOLLOW_pipeline_cmd_in_simple_list151);
            	        pipeline_cmd(isSub);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_listEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_listEx; /* Prevent compiler warnings */
    rulesimple_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_list */

/**
 * $ANTLR start pipeline_cmd
 * SimpleBashSQL.g:253:1: pipeline_cmd[bool isSub] : c1= command ( PIPE c2= command )* ;
 */
void
SimpleBashSQLParser::pipeline_cmd(bool isSub)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    command_return c1;
    command_return c2;
    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:253:25: (c1= command ( PIPE c2= command )* )
        // SimpleBashSQL.g:253:27: c1= command ( PIPE c2= command )*
        {
            this->followPush(FOLLOW_command_in_pipeline_cmd166);
            c1=command();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepipeline_cmdEx;
            }


            {
                 
                			/*only if the lastquery could not be translated &&
                				in bashmode && should be printed */
                			if(tobeprint && !lastquery && sqltool !="")
                				cout << (this->get_strstream()->toStringTT(c1.start, c1.stop))
                ;
                			
            }


            // SimpleBashSQL.g:260:4: ( PIPE c2= command )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case PIPE:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // SimpleBashSQL.g:260:5: PIPE c2= command
            	    {
            	         this->matchToken(PIPE, &FOLLOW_PIPE_in_pipeline_cmd177);
            	        if  (this->hasException())
            	        {
            	            goto rulepipeline_cmdEx;
            	        }


            	        this->followPush(FOLLOW_command_in_pipeline_cmd181);
            	        c2=command();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepipeline_cmdEx;
            	        }


            	        {
            	             
            	            				if(tobeprint && !lastquery && sqltool !="")
            	            					cout << " | " << (this->get_strstream()->toStringTT(c2.start, c2.stop))
            	            ;
            	            				
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


            {

                			/* on normal sql mode */
                			if(!isSub && lastquery && sqltool =="")
                				lastquery->print();
                			if(!isSub && lastquery && sqltool !=""){
                				cout << sqltool << " ";
                				lastquery->print();
                			}
                			printf("\n");
                			tobeprint=1;
                			
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepipeline_cmdEx; /* Prevent compiler warnings */
    rulepipeline_cmdEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pipeline_cmd */

/**
 * $ANTLR start command
 * SimpleBashSQL.g:279:1: command : ( cmd ( other_redir | to_redir )* | shell_cmd ( redirection )* );
 */
SimpleBashSQLParser::command_return
SimpleBashSQLParser::command()
{
    SimpleBashSQLParser::command_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        {
            //  SimpleBashSQL.g:279:8: ( cmd ( other_redir | to_redir )* | shell_cmd ( redirection )* )

            ANTLR_UINT32 alt11;

            alt11=2;

            switch ( this->LA(1) )
            {
            case NUMBER:
            case PIPE:
            case 21:
            case 22:
            case 23:
            case 25:
            case 36:
            case 37:
            case 38:
            case 41:
            case 44:
            case 47:
            case 48:
            case 50:
            case 51:
            case 53:
            case 54:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 64:
            case 67:
            case 68:
            case 71:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 79:
            case 82:
            case 83:
            	{
            		alt11=1;
            	}
                break;
            case WORD:
            	{
            		switch ( this->LA(2) )
            		{
            		case NUMBER:
            		case PIPE:
            		case WORD:
            		case 18:
            		case 21:
            		case 22:
            		case 23:
            		case 25:
            		case 36:
            		case 37:
            		case 38:
            		case 41:
            		case 44:
            		case 47:
            		case 48:
            		case 50:
            		case 51:
            		case 53:
            		case 59:
            		case 60:
            		case 61:
            		case 62:
            		case 64:
            		case 76:
            		case 82:
            		case 83:
            			{
            				alt11=1;
            			}
            		    break;
            		case 24:
            			{
            				alt11=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 11 );
            		    ex->set_state( 2 );


            		    goto rulecommandEx;

            		}

            	}
                break;
            case 18:
            	{
            		switch ( this->LA(2) )
            		{
            		case WORD:
            			{
            				switch ( this->LA(3) )
            				{
            				case 18:
            					{
            						switch ( this->LA(4) )
            						{
            						case NUMBER:
            						case PIPE:
            						case WORD:
            						case 18:
            						case 21:
            						case 22:
            						case 23:
            						case 25:
            						case 36:
            						case 37:
            						case 38:
            						case 41:
            						case 44:
            						case 47:
            						case 48:
            						case 50:
            						case 51:
            						case 53:
            						case 59:
            						case 60:
            						case 61:
            						case 62:
            						case 64:
            						case 76:
            						case 82:
            						case 83:
            							{
            								alt11=1;
            							}
            						    break;
            						case 24:
            							{
            								alt11=2;
            							}
            						    break;

            						default:
            						    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            						    ex->set_decisionNum( 11 );
            						    ex->set_state( 6 );


            						    goto rulecommandEx;

            						}

            					}
            				    break;

            				default:
            				    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 11 );
            				    ex->set_state( 5 );


            				    goto rulecommandEx;

            				}

            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 11 );
            		    ex->set_state( 3 );


            		    goto rulecommandEx;

            		}

            	}
                break;
            case 24:
            case 55:
            case 65:
            case 66:
            case 69:
            case 78:
            case 80:
            case 81:
            	{
            		alt11=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 11 );
                ex->set_state( 0 );


                goto rulecommandEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // SimpleBashSQL.g:279:10: cmd ( other_redir | to_redir )*
        	    {
        	        this->followPush(FOLLOW_cmd_in_command208);
        	        cmd();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // SimpleBashSQL.g:279:14: ( other_redir | to_redir )*

        	        for (;;)
        	        {
        	            int alt9=3;
        	            switch ( this->LA(1) )
        	            {
        	            case NUMBER:
        	            case 23:
        	            case 38:
        	            case 41:
        	            case 44:
        	            case 47:
        	            case 51:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;
        	            case 48:
        	            case 50:
        	            	{
        	            		alt9=2;
        	            	}
        	                break;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:279:15: other_redir
        	        	    {
        	        	        this->followPush(FOLLOW_other_redir_in_command211);
        	        	        other_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:279:27: to_redir
        	        	    {
        	        	        this->followPush(FOLLOW_to_redir_in_command213);
        	        	        to_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:279:40: shell_cmd ( redirection )*
        	    {
        	        this->followPush(FOLLOW_shell_cmd_in_command219);
        	        shell_cmd();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // SimpleBashSQL.g:279:50: ( redirection )*

        	        for (;;)
        	        {
        	            int alt10=2;
        	            switch ( this->LA(1) )
        	            {
        	            case NUMBER:
        	            case 23:
        	            case 38:
        	            case 39:
        	            case 40:
        	            case 41:
        	            case 42:
        	            case 44:
        	            case 47:
        	            case 51:
        	            	{
        	            		alt10=1;
        	            	}
        	                break;

        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:279:51: redirection
        	        	    {
        	        	        this->followPush(FOLLOW_redirection_in_command222);
        	        	        redirection();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop10;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop10: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecommandEx; /* Prevent compiler warnings */
    rulecommandEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end command */

/**
 * $ANTLR start subshell
 * SimpleBashSQL.g:280:1: subshell : '(' compound_list[true] ')' ;
 */
void
SimpleBashSQLParser::subshell()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:280:9: ( '(' compound_list[true] ')' )
        // SimpleBashSQL.g:280:11: '(' compound_list[true] ')'
        {
             this->matchToken(24, &FOLLOW_24_in_subshell230);
            if  (this->hasException())
            {
                goto rulesubshellEx;
            }


            this->followPush(FOLLOW_compound_list_in_subshell232);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubshellEx;
            }


             this->matchToken(25, &FOLLOW_25_in_subshell235);
            if  (this->hasException())
            {
                goto rulesubshellEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubshellEx; /* Prevent compiler warnings */
    rulesubshellEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subshell */

/**
 * $ANTLR start compound_list
 * SimpleBashSQL.g:282:1: compound_list[bool isSubshell] : simple_list[isSubshell] ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list[isSubshell] )* ;
 */
void
SimpleBashSQLParser::compound_list(bool isSubshell)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:283:2: ( simple_list[isSubshell] ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list[isSubshell] )* )
        // SimpleBashSQL.g:283:4: simple_list[isSubshell] ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list[isSubshell] )*
        {
            this->followPush(FOLLOW_simple_list_in_compound_list245);
            simple_list(isSubshell);

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_listEx;
            }


            // SimpleBashSQL.g:284:2: ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list[isSubshell] )*

            for (;;)
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                case 22:
                case 36:
                case 53:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13)
                {
            	case 1:
            	    // SimpleBashSQL.g:284:4: ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list[isSubshell]
            	    {
            	        if ( this->LA(1) == 22 || this->LA(1) == 36 || this->LA(1) == 53 )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	        }
            	        else
            	        {
            	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto rulecompound_listEx;
            	        }


            	        // SimpleBashSQL.g:284:23: ( '\\n' )*

            	        for (;;)
            	        {
            	            int alt12=2;
            	            switch ( this->LA(1) )
            	            {
            	            case 53:
            	            	{
            	            		alt12=1;
            	            	}
            	                break;

            	            }

            	            switch (alt12)
            	            {
            	        	case 1:
            	        	    // SimpleBashSQL.g:284:24: '\\n'
            	        	    {
            	        	         this->matchToken(53, &FOLLOW_53_in_compound_list265);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_listEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop12;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop12: ; /* Jump out to here if this rule does not match */


            	        this->followPush(FOLLOW_simple_list_in_compound_list269);
            	        simple_list(isSubshell);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompound_listEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_listEx; /* Prevent compiler warnings */
    rulecompound_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_list */

/**
 * $ANTLR start redirection
 * SimpleBashSQL.g:286:1: redirection : ( from_redir | other_redir );
 */
void
SimpleBashSQLParser::redirection()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  SimpleBashSQL.g:286:12: ( from_redir | other_redir )

            ANTLR_UINT32 alt14;

            alt14=2;

            switch ( this->LA(1) )
            {
            case 39:
            case 40:
            case 42:
            	{
            		alt14=1;
            	}
                break;
            case NUMBER:
            case 23:
            case 38:
            case 41:
            case 44:
            case 47:
            case 51:
            	{
            		alt14=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 14 );
                ex->set_state( 0 );


                goto ruleredirectionEx;

            }

            switch (alt14)
            {
        	case 1:
        	    // SimpleBashSQL.g:286:14: from_redir
        	    {
        	        this->followPush(FOLLOW_from_redir_in_redirection280);
        	        from_redir();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleredirectionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:286:27: other_redir
        	    {
        	        this->followPush(FOLLOW_other_redir_in_redirection284);
        	        other_redir();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleredirectionEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleredirectionEx; /* Prevent compiler warnings */
    ruleredirectionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end redirection */

/**
 * $ANTLR start to_redir
 * SimpleBashSQL.g:288:1: to_redir : ( '>' | '>>' ) word ;
 */
void
SimpleBashSQLParser::to_redir()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    word_return word2;
    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:288:9: ( ( '>' | '>>' ) word )
        // SimpleBashSQL.g:288:11: ( '>' | '>>' ) word
        {
            if ( this->LA(1) == 48 || this->LA(1) == 50 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleto_redirEx;
            }


            this->followPush(FOLLOW_word_in_to_redir298);
            word2=word();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleto_redirEx;
            }


            {

                	/* on normal sql mode */
                	if(sqltool=="" && lastquery){
                		std::cout << "WITH " << (this->get_strstream()->toStringTT(word2.start, word2.stop))
                 << " AS ("  << endl;
                		lastquery->print();
                		std::cout << " )" << endl;
                		lastquery=NULL;
                		tobeprint=0;
                	}else if(lastquery){
                	/* on bash mode use sqltool */
                		std::cout << sqltool << " ";
                		lastquery->print();
                		std::cout << " > " << (this->get_strstream()->toStringTT(word2.start, word2.stop))
                 << endl;
                		lastquery=NULL;
                		tobeprint=0;
                	}
                	/*TODO hashmap with lastqueries */

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_redirEx; /* Prevent compiler warnings */
    ruleto_redirEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_redir */

/**
 * $ANTLR start from_redir
 * SimpleBashSQL.g:308:1: from_redir returns [string fname] : ( ( '<' | '<<' | '<<<' ) word | '<' subshell );
 */
string
SimpleBashSQLParser::from_redir()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    string fname;


    word_return word3;
    /* Initialize rule variables
     */
     


 
    {
        {
            //  SimpleBashSQL.g:309:3: ( ( '<' | '<<' | '<<<' ) word | '<' subshell )

            ANTLR_UINT32 alt15;

            alt15=2;

            switch ( this->LA(1) )
            {
            case 39:
            	{
            		switch ( this->LA(2) )
            		{
            		case WORD:
            		case 18:
            			{
            				alt15=1;
            			}
            		    break;
            		case 24:
            			{
            				alt15=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 15 );
            		    ex->set_state( 1 );


            		    goto rulefrom_redirEx;

            		}

            	}
                break;
            case 40:
            case 42:
            	{
            		alt15=1;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 15 );
                ex->set_state( 0 );


                goto rulefrom_redirEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // SimpleBashSQL.g:309:5: ( '<' | '<<' | '<<<' ) word
        	    {
        	        if ( ((this->LA(1) >= 39) && (this->LA(1) <= 40)) || this->LA(1) == 42 )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto rulefrom_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_from_redir323);
        	        word3=word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefrom_redirEx;
        	        }


        	        {

        	            			stringstream s; s << (this->get_strstream()->toStringTT(word3.start, word3.stop))
        	            ; 
        	            			fname=s.str();
        	            			
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:314:5: '<' subshell
        	    {
        	         this->matchToken(39, &FOLLOW_39_in_from_redir334);
        	        if  (this->hasException())
        	        {
        	            goto rulefrom_redirEx;
        	        }


        	        this->followPush(FOLLOW_subshell_in_from_redir336);
        	        subshell();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefrom_redirEx;
        	        }


        	        {

        	            			fname="";
        	            			
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulefrom_redirEx; /* Prevent compiler warnings */
    rulefrom_redirEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return fname;
}
/* $ANTLR end from_redir */

/**
 * $ANTLR start other_redir
 * SimpleBashSQL.g:320:1: other_redir : ( number '>' word | number '<' word | number '>>' word | number '<<' word | '<&' number | number '<&' number | '>&' number | number '>&' number | '<&' word | number '<&' word | '>&' word | number '>&' word | '<<-' word | number '<<-' word | '>&' '-' | number '>&' '-' | '<&' '-' | number '<&' '-' | '&>' word | number '<>' word | '<>' word | '>|' word | number '>|' word );
 */
void
SimpleBashSQLParser::other_redir()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  SimpleBashSQL.g:320:12: ( number '>' word | number '<' word | number '>>' word | number '<<' word | '<&' number | number '<&' number | '>&' number | number '>&' number | '<&' word | number '<&' word | '>&' word | number '>&' word | '<<-' word | number '<<-' word | '>&' '-' | number '>&' '-' | '<&' '-' | number '<&' '-' | '&>' word | number '<>' word | '<>' word | '>|' word | number '>|' word )

            ANTLR_UINT32 alt16;

            alt16=23;

            switch ( this->LA(1) )
            {
            case NUMBER:
            	{
            		switch ( this->LA(2) )
            		{
            		case 48:
            			{
            				alt16=1;
            			}
            		    break;
            		case 39:
            			{
            				alt16=2;
            			}
            		    break;
            		case 50:
            			{
            				alt16=3;
            			}
            		    break;
            		case 40:
            			{
            				alt16=4;
            			}
            		    break;
            		case 38:
            			{
            				switch ( this->LA(3) )
            				{
            				case 31:
            					{
            						alt16=18;
            					}
            				    break;
            				case NUMBER:
            					{
            						alt16=6;
            					}
            				    break;
            				case WORD:
            				case 18:
            					{
            						alt16=10;
            					}
            				    break;

            				default:
            				    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 16 );
            				    ex->set_state( 12 );


            				    goto ruleother_redirEx;

            				}

            			}
            		    break;
            		case 47:
            			{
            				switch ( this->LA(3) )
            				{
            				case 31:
            					{
            						alt16=16;
            					}
            				    break;
            				case NUMBER:
            					{
            						alt16=8;
            					}
            				    break;
            				case WORD:
            				case 18:
            					{
            						alt16=12;
            					}
            				    break;

            				default:
            				    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 16 );
            				    ex->set_state( 13 );


            				    goto ruleother_redirEx;

            				}

            			}
            		    break;
            		case 41:
            			{
            				alt16=14;
            			}
            		    break;
            		case 44:
            			{
            				alt16=20;
            			}
            		    break;
            		case 51:
            			{
            				alt16=23;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 16 );
            		    ex->set_state( 1 );


            		    goto ruleother_redirEx;

            		}

            	}
                break;
            case 38:
            	{
            		switch ( this->LA(2) )
            		{
            		case 31:
            			{
            				alt16=17;
            			}
            		    break;
            		case NUMBER:
            			{
            				alt16=5;
            			}
            		    break;
            		case WORD:
            		case 18:
            			{
            				alt16=9;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 16 );
            		    ex->set_state( 2 );


            		    goto ruleother_redirEx;

            		}

            	}
                break;
            case 47:
            	{
            		switch ( this->LA(2) )
            		{
            		case 31:
            			{
            				alt16=15;
            			}
            		    break;
            		case NUMBER:
            			{
            				alt16=7;
            			}
            		    break;
            		case WORD:
            		case 18:
            			{
            				alt16=11;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 16 );
            		    ex->set_state( 3 );


            		    goto ruleother_redirEx;

            		}

            	}
                break;
            case 41:
            	{
            		alt16=13;
            	}
                break;
            case 23:
            	{
            		alt16=19;
            	}
                break;
            case 44:
            	{
            		alt16=21;
            	}
                break;
            case 51:
            	{
            		alt16=22;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 16 );
                ex->set_state( 0 );


                goto ruleother_redirEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // SimpleBashSQL.g:321:20: number '>' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir371);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(48, &FOLLOW_48_in_other_redir373);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir375);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:322:20: number '<' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir396);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(39, &FOLLOW_39_in_other_redir398);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir400);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:323:20: number '>>' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir421);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(50, &FOLLOW_50_in_other_redir423);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir425);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // SimpleBashSQL.g:324:20: number '<<' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir446);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(40, &FOLLOW_40_in_other_redir448);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir450);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // SimpleBashSQL.g:325:20: '<&' number
        	    {
        	         this->matchToken(38, &FOLLOW_38_in_other_redir471);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_number_in_other_redir473);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // SimpleBashSQL.g:326:20: number '<&' number
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir494);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(38, &FOLLOW_38_in_other_redir496);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_number_in_other_redir498);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // SimpleBashSQL.g:327:20: '>&' number
        	    {
        	         this->matchToken(47, &FOLLOW_47_in_other_redir519);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_number_in_other_redir521);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // SimpleBashSQL.g:328:20: number '>&' number
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir542);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(47, &FOLLOW_47_in_other_redir544);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_number_in_other_redir546);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 9:
        	    // SimpleBashSQL.g:329:20: '<&' word
        	    {
        	         this->matchToken(38, &FOLLOW_38_in_other_redir567);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir569);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 10:
        	    // SimpleBashSQL.g:330:20: number '<&' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir590);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(38, &FOLLOW_38_in_other_redir592);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir594);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // SimpleBashSQL.g:331:20: '>&' word
        	    {
        	         this->matchToken(47, &FOLLOW_47_in_other_redir615);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir617);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 12:
        	    // SimpleBashSQL.g:332:20: number '>&' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir638);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(47, &FOLLOW_47_in_other_redir640);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir642);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 13:
        	    // SimpleBashSQL.g:333:20: '<<-' word
        	    {
        	         this->matchToken(41, &FOLLOW_41_in_other_redir663);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir665);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 14:
        	    // SimpleBashSQL.g:334:20: number '<<-' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir686);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(41, &FOLLOW_41_in_other_redir688);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir690);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 15:
        	    // SimpleBashSQL.g:335:20: '>&' '-'
        	    {
        	         this->matchToken(47, &FOLLOW_47_in_other_redir711);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(31, &FOLLOW_31_in_other_redir713);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 16:
        	    // SimpleBashSQL.g:336:20: number '>&' '-'
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir734);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(47, &FOLLOW_47_in_other_redir736);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(31, &FOLLOW_31_in_other_redir738);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 17:
        	    // SimpleBashSQL.g:337:20: '<&' '-'
        	    {
        	         this->matchToken(38, &FOLLOW_38_in_other_redir759);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(31, &FOLLOW_31_in_other_redir761);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 18:
        	    // SimpleBashSQL.g:338:20: number '<&' '-'
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir782);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(38, &FOLLOW_38_in_other_redir784);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(31, &FOLLOW_31_in_other_redir786);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 19:
        	    // SimpleBashSQL.g:339:20: '&>' word
        	    {
        	         this->matchToken(23, &FOLLOW_23_in_other_redir807);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir809);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 20:
        	    // SimpleBashSQL.g:340:20: number '<>' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir830);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(44, &FOLLOW_44_in_other_redir832);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir834);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 21:
        	    // SimpleBashSQL.g:341:20: '<>' word
        	    {
        	         this->matchToken(44, &FOLLOW_44_in_other_redir855);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir857);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 22:
        	    // SimpleBashSQL.g:342:20: '>|' word
        	    {
        	         this->matchToken(51, &FOLLOW_51_in_other_redir878);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir880);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 23:
        	    // SimpleBashSQL.g:343:20: number '>|' word
        	    {
        	        this->followPush(FOLLOW_number_in_other_redir901);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         this->matchToken(51, &FOLLOW_51_in_other_redir903);
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	        this->followPush(FOLLOW_word_in_other_redir905);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleother_redirEx; /* Prevent compiler warnings */
    ruleother_redirEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end other_redir */

/**
 * $ANTLR start shell_cmd
 * SimpleBashSQL.g:346:1: shell_cmd : ( for_command | case_command | 'while' compound_list[true] 'do' compound_list[true] 'done' | 'until' compound_list[true] 'do' compound_list[true] 'done' | if_command | subshell | group_command | function_def );
 */
void
SimpleBashSQLParser::shell_cmd()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  SimpleBashSQL.g:346:10: ( for_command | case_command | 'while' compound_list[true] 'do' compound_list[true] 'done' | 'until' compound_list[true] 'do' compound_list[true] 'done' | if_command | subshell | group_command | function_def )

            ANTLR_UINT32 alt17;

            alt17=8;

            switch ( this->LA(1) )
            {
            case 65:
            	{
            		alt17=1;
            	}
                break;
            case 55:
            	{
            		alt17=2;
            	}
                break;
            case 80:
            	{
            		alt17=3;
            	}
                break;
            case 78:
            	{
            		alt17=4;
            	}
                break;
            case 69:
            	{
            		alt17=5;
            	}
                break;
            case 24:
            	{
            		alt17=6;
            	}
                break;
            case 81:
            	{
            		alt17=7;
            	}
                break;
            case WORD:
            case 18:
            case 66:
            	{
            		alt17=8;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 17 );
                ex->set_state( 0 );


                goto ruleshell_cmdEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // SimpleBashSQL.g:346:13: for_command
        	    {
        	        this->followPush(FOLLOW_for_command_in_shell_cmd914);
        	        for_command();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:347:22: case_command
        	    {
        	        this->followPush(FOLLOW_case_command_in_shell_cmd937);
        	        case_command();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:348:22: 'while' compound_list[true] 'do' compound_list[true] 'done'
        	    {
        	         this->matchToken(80, &FOLLOW_80_in_shell_cmd960);
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        this->followPush(FOLLOW_compound_list_in_shell_cmd962);
        	        compound_list(true);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         this->matchToken(59, &FOLLOW_59_in_shell_cmd965);
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        this->followPush(FOLLOW_compound_list_in_shell_cmd967);
        	        compound_list(true);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         this->matchToken(60, &FOLLOW_60_in_shell_cmd970);
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // SimpleBashSQL.g:349:22: 'until' compound_list[true] 'do' compound_list[true] 'done'
        	    {
        	         this->matchToken(78, &FOLLOW_78_in_shell_cmd993);
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        this->followPush(FOLLOW_compound_list_in_shell_cmd995);
        	        compound_list(true);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         this->matchToken(59, &FOLLOW_59_in_shell_cmd998);
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        this->followPush(FOLLOW_compound_list_in_shell_cmd1000);
        	        compound_list(true);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         this->matchToken(60, &FOLLOW_60_in_shell_cmd1003);
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // SimpleBashSQL.g:350:22: if_command
        	    {
        	        this->followPush(FOLLOW_if_command_in_shell_cmd1026);
        	        if_command();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // SimpleBashSQL.g:351:22: subshell
        	    {
        	        this->followPush(FOLLOW_subshell_in_shell_cmd1049);
        	        subshell();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // SimpleBashSQL.g:352:22: group_command
        	    {
        	        this->followPush(FOLLOW_group_command_in_shell_cmd1072);
        	        group_command();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // SimpleBashSQL.g:353:22: function_def
        	    {
        	        this->followPush(FOLLOW_function_def_in_shell_cmd1095);
        	        function_def();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleshell_cmdEx; /* Prevent compiler warnings */
    ruleshell_cmdEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end shell_cmd */

/**
 * $ANTLR start for_command
 * SimpleBashSQL.g:355:1: for_command : for_header compound_list[true] ( 'done' | '}' ) ;
 */
void
SimpleBashSQLParser::for_command()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    for_header_return for_header4;
    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:355:12: ( for_header compound_list[true] ( 'done' | '}' ) )
        // SimpleBashSQL.g:355:15: for_header compound_list[true] ( 'done' | '}' )
        {
            this->followPush(FOLLOW_for_header_in_for_command1103);
            for_header4=for_header();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_commandEx;
            }


            {
                cout << (this->get_strstream()->toStringTT(for_header4.start, for_header4.stop))
                 << endl;
            }


            this->followPush(FOLLOW_compound_list_in_for_command1113);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_commandEx;
            }


            if ( this->LA(1) == 60 || this->LA(1) == 83 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulefor_commandEx;
            }


            {
                printf("done\n");tobeprint=0;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_commandEx; /* Prevent compiler warnings */
    rulefor_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_command */

/**
 * $ANTLR start for_header
 * SimpleBashSQL.g:360:1: for_header : 'for' word 'in' ( word )* ( '\\n' | ';' ) ( 'do' | '{' ) ;
 */
SimpleBashSQLParser::for_header_return
SimpleBashSQLParser::for_header()
{
    SimpleBashSQLParser::for_header_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        // SimpleBashSQL.g:360:11: ( 'for' word 'in' ( word )* ( '\\n' | ';' ) ( 'do' | '{' ) )
        // SimpleBashSQL.g:360:14: 'for' word 'in' ( word )* ( '\\n' | ';' ) ( 'do' | '{' )
        {
             this->matchToken(65, &FOLLOW_65_in_for_header1136);
            if  (this->hasException())
            {
                goto rulefor_headerEx;
            }


            this->followPush(FOLLOW_word_in_for_header1138);
            word();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_headerEx;
            }


             this->matchToken(70, &FOLLOW_70_in_for_header1140);
            if  (this->hasException())
            {
                goto rulefor_headerEx;
            }


            // SimpleBashSQL.g:360:30: ( word )*

            for (;;)
            {
                int alt18=2;
                switch ( this->LA(1) )
                {
                case WORD:
                case 18:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18)
                {
            	case 1:
            	    // SimpleBashSQL.g:360:30: word
            	    {
            	        this->followPush(FOLLOW_word_in_for_header1142);
            	        word();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_headerEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


            if ( this->LA(1) == 36 || this->LA(1) == 53 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulefor_headerEx;
            }


            if ( this->LA(1) == 59 || this->LA(1) == 81 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulefor_headerEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_headerEx; /* Prevent compiler warnings */
    rulefor_headerEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end for_header */

/**
 * $ANTLR start if_command
 * SimpleBashSQL.g:362:1: if_command : 'if' compound_list[true] 'then' compound_list[true] ( 'elif' compound_list[true] )* 'else' compound_list[true] 'fi' ;
 */
void
SimpleBashSQLParser::if_command()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:362:11: ( 'if' compound_list[true] 'then' compound_list[true] ( 'elif' compound_list[true] )* 'else' compound_list[true] 'fi' )
        // SimpleBashSQL.g:362:13: 'if' compound_list[true] 'then' compound_list[true] ( 'elif' compound_list[true] )* 'else' compound_list[true] 'fi'
        {
             this->matchToken(69, &FOLLOW_69_in_if_command1165);
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


            this->followPush(FOLLOW_compound_list_in_if_command1167);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


             this->matchToken(76, &FOLLOW_76_in_if_command1170);
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


            this->followPush(FOLLOW_compound_list_in_if_command1172);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


            // SimpleBashSQL.g:362:65: ( 'elif' compound_list[true] )*

            for (;;)
            {
                int alt19=2;
                switch ( this->LA(1) )
                {
                case 61:
                	{
                		alt19=1;
                	}
                    break;

                }

                switch (alt19)
                {
            	case 1:
            	    // SimpleBashSQL.g:362:66: 'elif' compound_list[true]
            	    {
            	         this->matchToken(61, &FOLLOW_61_in_if_command1176);
            	        if  (this->hasException())
            	        {
            	            goto ruleif_commandEx;
            	        }


            	        this->followPush(FOLLOW_compound_list_in_if_command1178);
            	        compound_list(true);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleif_commandEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


             this->matchToken(62, &FOLLOW_62_in_if_command1183);
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


            this->followPush(FOLLOW_compound_list_in_if_command1185);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


             this->matchToken(64, &FOLLOW_64_in_if_command1188);
            if  (this->hasException())
            {
                goto ruleif_commandEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleif_commandEx; /* Prevent compiler warnings */
    ruleif_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end if_command */

/**
 * $ANTLR start group_command
 * SimpleBashSQL.g:364:1: group_command : '{' compound_list[true] '}' ;
 */
void
SimpleBashSQLParser::group_command()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:364:15: ( '{' compound_list[true] '}' )
        // SimpleBashSQL.g:364:17: '{' compound_list[true] '}'
        {
             this->matchToken(81, &FOLLOW_81_in_group_command1196);
            if  (this->hasException())
            {
                goto rulegroup_commandEx;
            }


            this->followPush(FOLLOW_compound_list_in_group_command1198);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto rulegroup_commandEx;
            }


             this->matchToken(83, &FOLLOW_83_in_group_command1201);
            if  (this->hasException())
            {
                goto rulegroup_commandEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegroup_commandEx; /* Prevent compiler warnings */
    rulegroup_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_command */

/**
 * $ANTLR start function_def
 * SimpleBashSQL.g:366:1: function_def : ( 'function' )* word '(' ')' ( '\\n' | ';' ) group_command ;
 */
void
SimpleBashSQLParser::function_def()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:366:14: ( ( 'function' )* word '(' ')' ( '\\n' | ';' ) group_command )
        // SimpleBashSQL.g:366:17: ( 'function' )* word '(' ')' ( '\\n' | ';' ) group_command
        {
            // SimpleBashSQL.g:366:17: ( 'function' )*

            for (;;)
            {
                int alt20=2;
                switch ( this->LA(1) )
                {
                case 66:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // SimpleBashSQL.g:366:18: 'function'
            	    {
            	         this->matchToken(66, &FOLLOW_66_in_function_def1211);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_defEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_word_in_function_def1215);
            word();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_defEx;
            }


             this->matchToken(24, &FOLLOW_24_in_function_def1217);
            if  (this->hasException())
            {
                goto rulefunction_defEx;
            }


             this->matchToken(25, &FOLLOW_25_in_function_def1219);
            if  (this->hasException())
            {
                goto rulefunction_defEx;
            }


            if ( this->LA(1) == 36 || this->LA(1) == 53 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulefunction_defEx;
            }


            this->followPush(FOLLOW_group_command_in_function_def1230);
            group_command();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_defEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_defEx; /* Prevent compiler warnings */
    rulefunction_defEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_def */

/**
 * $ANTLR start case_command
 * SimpleBashSQL.g:368:1: case_command : 'case' word ( '\\n' | ';' ) 'in' ( '\\n' | ';' ) ( case_clause )* 'esac' ;
 */
void
SimpleBashSQLParser::case_command()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:368:13: ( 'case' word ( '\\n' | ';' ) 'in' ( '\\n' | ';' ) ( case_clause )* 'esac' )
        // SimpleBashSQL.g:368:16: 'case' word ( '\\n' | ';' ) 'in' ( '\\n' | ';' ) ( case_clause )* 'esac'
        {
             this->matchToken(55, &FOLLOW_55_in_case_command1240);
            if  (this->hasException())
            {
                goto rulecase_commandEx;
            }


            this->followPush(FOLLOW_word_in_case_command1242);
            word();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecase_commandEx;
            }


            if ( this->LA(1) == 36 || this->LA(1) == 53 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulecase_commandEx;
            }


             this->matchToken(70, &FOLLOW_70_in_case_command1252);
            if  (this->hasException())
            {
                goto rulecase_commandEx;
            }


            if ( this->LA(1) == 36 || this->LA(1) == 53 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulecase_commandEx;
            }


            // SimpleBashSQL.g:368:59: ( case_clause )*

            for (;;)
            {
                int alt21=2;
                switch ( this->LA(1) )
                {
                case 25:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21)
                {
            	case 1:
            	    // SimpleBashSQL.g:368:59: case_clause
            	    {
            	        this->followPush(FOLLOW_case_clause_in_case_command1262);
            	        case_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_commandEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


             this->matchToken(63, &FOLLOW_63_in_case_command1265);
            if  (this->hasException())
            {
                goto rulecase_commandEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecase_commandEx; /* Prevent compiler warnings */
    rulecase_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end case_command */

/**
 * $ANTLR start case_clause
 * SimpleBashSQL.g:370:1: case_clause : pattern ')' compound_list[true] ';;' ;
 */
void
SimpleBashSQLParser::case_clause()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:370:12: ( pattern ')' compound_list[true] ';;' )
        // SimpleBashSQL.g:370:14: pattern ')' compound_list[true] ';;'
        {
            this->followPush(FOLLOW_pattern_in_case_clause1272);
            pattern();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecase_clauseEx;
            }


             this->matchToken(25, &FOLLOW_25_in_case_clause1274);
            if  (this->hasException())
            {
                goto rulecase_clauseEx;
            }


            this->followPush(FOLLOW_compound_list_in_case_clause1276);
            compound_list(true);

            this->followPop();
            if  (this->hasException())
            {
                goto rulecase_clauseEx;
            }


             this->matchToken(37, &FOLLOW_37_in_case_clause1279);
            if  (this->hasException())
            {
                goto rulecase_clauseEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecase_clauseEx; /* Prevent compiler warnings */
    rulecase_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end case_clause */

/**
 * $ANTLR start cmd
 * SimpleBashSQL.g:373:1: cmd returns [TheQuery *r] : ( 'cut' ( opts | word | from_redir | '- ' )+ | 'cat' ( opts | word | from_redir | '- ' )* | 'grep' (o1= opts )* p= word (o2= opts |f= word | from_redir | '- ' )* | 'sort' ( opts | word | from_redir )* | 'head' ( opts | '-1' | '-2' | word | from_redir | '- ' )* | 'tail' ( opts | '-1' | '-2' | word | from_redir | '- ' )* | 'join' ( ( '-1' n1= number ) | ( '-2' n2= number ) | OPTS | word | '- ' | from_redir )+ | 'tee' word | 'uniq' ( opts | word | from_redir | '- ' )* | 'wc -l' ( opts | word | from_redir | '- ' )* | 'awk' ( OPTS )* '\\'' ( '\\n' )* ( awkbody[r] ( '\\n' )* )+ '\\'' ( assignment | OPTS )* ( word | from_redir | '- ' )* | 'datamash' ( opts | word number | from_redir | '- ' )* | ( word )* );
 */
TheQuery *
SimpleBashSQLParser::cmd()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    TheQuery * r;


    opts_return o1;
    word_return p;
    opts_return o2;
    word_return f;
    number_return n1;
    number_return n2;
    opts_return opts5;
    word_return word6;
    string from_redir7;
    word_return word8;
    string from_redir9;
    string from_redir10;
    opts_return opts11;
    word_return word12;
    string from_redir13;
    word_return word14;
    string from_redir15;
    word_return word16;
    string from_redir17;
    word_return word18;
    string from_redir19;
    opts_return opts20;
    word_return word21;
    string from_redir22;
    opts_return opts23;
    word_return word24;
    string from_redir25;
    word_return word26;
    string from_redir27;
    opts_return opts28;
    word_return word29;
    number_return number30;
    string from_redir31;
    /* Initialize rule variables
     */
     


    	/* new TheQuery r,
    	afterwards, set old query (lastquery) as table-reference
    	set lastquery as null, so queries from subshell will won't be
    	included twice */
    	TheQuery* fromPipe=lastquery;
    	lastquery=NULL;
    	r = new TheQuery();
    	stringstream s;
    	char buffer[80];
    	int helpsize=0, join_on, a_int=0;


 
    {
        {
            //  SimpleBashSQL.g:390:2: ( 'cut' ( opts | word | from_redir | '- ' )+ | 'cat' ( opts | word | from_redir | '- ' )* | 'grep' (o1= opts )* p= word (o2= opts |f= word | from_redir | '- ' )* | 'sort' ( opts | word | from_redir )* | 'head' ( opts | '-1' | '-2' | word | from_redir | '- ' )* | 'tail' ( opts | '-1' | '-2' | word | from_redir | '- ' )* | 'join' ( ( '-1' n1= number ) | ( '-2' n2= number ) | OPTS | word | '- ' | from_redir )+ | 'tee' word | 'uniq' ( opts | word | from_redir | '- ' )* | 'wc -l' ( opts | word | from_redir | '- ' )* | 'awk' ( OPTS )* '\\'' ( '\\n' )* ( awkbody[r] ( '\\n' )* )+ '\\'' ( assignment | OPTS )* ( word | from_redir | '- ' )* | 'datamash' ( opts | word number | from_redir | '- ' )* | ( word )* )

            ANTLR_UINT32 alt40;

            alt40=13;

            switch ( this->LA(1) )
            {
            case 57:
            	{
            		alt40=1;
            	}
                break;
            case 56:
            	{
            		alt40=2;
            	}
                break;
            case 67:
            	{
            		alt40=3;
            	}
                break;
            case 73:
            	{
            		alt40=4;
            	}
                break;
            case 68:
            	{
            		alt40=5;
            	}
                break;
            case 74:
            	{
            		alt40=6;
            	}
                break;
            case 71:
            	{
            		alt40=7;
            	}
                break;
            case 75:
            	{
            		alt40=8;
            	}
                break;
            case 77:
            	{
            		alt40=9;
            	}
                break;
            case 79:
            	{
            		alt40=10;
            	}
                break;
            case 54:
            	{
            		alt40=11;
            	}
                break;
            case 58:
            	{
            		alt40=12;
            	}
                break;
            case NUMBER:
            case PIPE:
            case WORD:
            case 18:
            case 21:
            case 22:
            case 23:
            case 25:
            case 36:
            case 37:
            case 38:
            case 41:
            case 44:
            case 47:
            case 48:
            case 50:
            case 51:
            case 53:
            case 59:
            case 60:
            case 61:
            case 62:
            case 64:
            case 76:
            case 82:
            case 83:
            	{
            		alt40=13;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 40 );
                ex->set_state( 0 );


                goto rulecmdEx;

            }

            switch (alt40)
            {
        	case 1:
        	    // SimpleBashSQL.g:391:4: 'cut' ( opts | word | from_redir | '- ' )+
        	    {
        	         this->matchToken(57, &FOLLOW_57_in_cmd1306);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:391:11: ( opts | word | from_redir | '- ' )+
        	        {
        	            int cnt22=0;

        	            for (;;)
        	            {
        	                int alt22=5;
        	        	switch ( this->LA(1) )
        	        	{
        	        	case OPTS:
        	        		{
        	        			alt22=1;
        	        		}
        	        	    break;
        	        	case WORD:
        	        	case 18:
        	        		{
        	        			alt22=2;
        	        		}
        	        	    break;
        	        	case 39:
        	        	case 40:
        	        	case 42:
        	        		{
        	        			alt22=3;
        	        		}
        	        	    break;
        	        	case 30:
        	        		{
        	        			alt22=4;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt22)
        	        	{
        	        	    case 1:
        	        	        // SimpleBashSQL.g:391:13: opts
        	        	        {
        	        	            this->followPush(FOLLOW_opts_in_cmd1311);
        	        	            opts5=opts();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {

        	        	                				s.str(""); s.clear();
        	        	                				s << (this->get_strstream()->toStringTT(opts5.start, opts5.stop))
        	        	                ; s.getline(buffer,80);
        	        	                				optscut(buffer,r);
        	        	                				
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // SimpleBashSQL.g:397:6: word
        	        	        {
        	        	            this->followPush(FOLLOW_word_in_cmd1326);
        	        	            word6=word();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {

        	        	                				s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(word6.start, word6.stop))
        	        	                ;
        	        	                				r->makeUnion(s.str());
        	        	                				
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 3:
        	        	        // SimpleBashSQL.g:402:6: from_redir
        	        	        {
        	        	            this->followPush(FOLLOW_from_redir_in_cmd1339);
        	        	            from_redir7=from_redir();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                /* fname!=NULL, wenn Dateiname */
        	        	                				if (!from_redir7
        	        	                .empty())
        	        	                					r->makeUnion(from_redir7
        	        	                );
        	        	                				else /* sonst subshell */
        	        	                					r->makeUnion(lastquery); 
        	        	                				
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 4:
        	        	        // SimpleBashSQL.g:409:6: '- '
        	        	        {
        	        	             this->matchToken(30, &FOLLOW_30_in_cmd1352);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt22 >= 1 )
        	        		{
        	        		    goto loop22;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		new ANTLR_Exception< SimpleBashSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        	        		goto rulecmdEx;
        	        	}
        	        	cnt22++;
        	            }
        	            loop22: ;	/* Jump to here if this rule does not match */
        	        }

        	        {
        	            r->makeUnion(fromPipe);
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:413:4: 'cat' ( opts | word | from_redir | '- ' )*
        	    {
        	         this->matchToken(56, &FOLLOW_56_in_cmd1369);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:413:11: ( opts | word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt23=5;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt23=1;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt23=2;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt23=3;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt23=4;
        	            	}
        	                break;

        	            }

        	            switch (alt23)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:413:13: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1374);
        	        	        opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:414:6: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd1381);
        	        	        word8=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();  s << (this->get_strstream()->toStringTT(word8.start, word8.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:419:6: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd1395);
        	        	        from_redir9=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir9
        	        	            .empty())
        	        	            					r->makeUnion(from_redir9
        	        	            );
        	        	            				else /* sonst subshell */
        	        	            					r->makeUnion(lastquery);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:426:6: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd1408);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop23;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop23: ; /* Jump out to here if this rule does not match */


        	        {
        	            r->makeUnion(fromPipe);
        	        }


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:430:4: 'grep' (o1= opts )* p= word (o2= opts |f= word | from_redir | '- ' )*
        	    {
        	         this->matchToken(67, &FOLLOW_67_in_cmd1425);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:430:12: (o1= opts )*

        	        for (;;)
        	        {
        	            int alt24=2;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt24=1;
        	            	}
        	                break;

        	            }

        	            switch (alt24)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:430:14: o1= opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1432);
        	        	        o1=opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();
        	        	            				s << (this->get_strstream()->toStringTT(o1.start, o1.stop))
        	        	            ; s.getline(buffer,80);
        	        	            				a_int=optsgrep(buffer,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop24;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop24: ; /* Jump out to here if this rule does not match */


        	        this->followPush(FOLLOW_word_in_cmd1452);
        	        p=word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:438:4: (o2= opts |f= word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt25=5;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt25=1;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt25=2;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt25=3;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt25=4;
        	            	}
        	                break;

        	            }

        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:438:6: o2= opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1463);
        	        	        o2=opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();
        	        	            				s << (this->get_strstream()->toStringTT(o2.start, o2.stop))
        	        	            ; s.getline(buffer,80);
        	        	            				optsgrep(buffer,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:444:6: f= word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd1479);
        	        	        f=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(f.start, f.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:449:6: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd1493);
        	        	        from_redir10=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir10
        	        	            .empty())
        	        	            					r->makeUnion(from_redir10
        	        	            );
        	        	            				else /* sonst subshell */
        	        	            					r->makeUnion(lastquery);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:456:6: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd1506);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop25;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop25: ; /* Jump out to here if this rule does not match */


        	        {

        	            			r->makeUnion(fromPipe);
        	            			s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(p.start, p.stop))
        	            ;
        	            			zugrep(s.str(),a_int,r);
        	            			
        	        }


        	    }
        	    break;
        	case 4:
        	    // SimpleBashSQL.g:464:4: 'sort' ( opts | word | from_redir )*
        	    {
        	         this->matchToken(73, &FOLLOW_73_in_cmd1523);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:464:11: ( opts | word | from_redir )*

        	        for (;;)
        	        {
        	            int alt26=4;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt26=2;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt26=3;
        	            	}
        	                break;

        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:464:13: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1527);
        	        	        opts11=opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();
        	        	            				s << (this->get_strstream()->toStringTT(opts11.start, opts11.stop))
        	        	            ; s.getline(buffer,80);
        	        	            				optssort(buffer,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:470:6: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd1541);
        	        	        word12=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(word12.start, word12.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:475:6: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd1554);
        	        	        from_redir13=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, if filename specified*/
        	        	            				if (!from_redir13
        	        	            .empty())
        	        	            					r->makeUnion(from_redir13
        	        	            );
        	        	            				else /* sonst subshell */
        	        	            					r->makeUnion(lastquery);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop26;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop26: ; /* Jump out to here if this rule does not match */


        	        {
        	            r->makeUnion(fromPipe);
        	        }


        	    }
        	    break;
        	case 5:
        	    // SimpleBashSQL.g:485:4: 'head' ( opts | '-1' | '-2' | word | from_redir | '- ' )*
        	    {
        	         this->matchToken(68, &FOLLOW_68_in_cmd1577);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:485:11: ( opts | '-1' | '-2' | word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt27=7;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt27=1;
        	            	}
        	                break;
        	            case 32:
        	            	{
        	            		alt27=2;
        	            	}
        	                break;
        	            case 33:
        	            	{
        	            		alt27=3;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt27=4;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt27=5;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt27=6;
        	            	}
        	                break;

        	            }

        	            switch (alt27)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:485:13: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1581);
        	        	        opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:486:6: '-1'
        	        	    {
        	        	         this->matchToken(32, &FOLLOW_32_in_cmd1590);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:486:13: '-2'
        	        	    {
        	        	         this->matchToken(33, &FOLLOW_33_in_cmd1594);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:487:6: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd1601);
        	        	        word14=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();  s << (this->get_strstream()->toStringTT(word14.start, word14.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 5:
        	        	    // SimpleBashSQL.g:492:6: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd1615);
        	        	        from_redir15=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir15
        	        	            .empty())
        	        	            					r->makeUnion(from_redir15
        	        	            );
        	        	            				else /* sonst subshell */
        	        	            					r->makeUnion(lastquery);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 6:
        	        	    // SimpleBashSQL.g:499:6: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd1628);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop27;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop27: ; /* Jump out to here if this rule does not match */


        	        {
        	            r->makeUnion(fromPipe);
        	        }


        	    }
        	    break;
        	case 6:
        	    // SimpleBashSQL.g:504:4: 'tail' ( opts | '-1' | '-2' | word | from_redir | '- ' )*
        	    {
        	         this->matchToken(74, &FOLLOW_74_in_cmd1646);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:504:11: ( opts | '-1' | '-2' | word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt28=7;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt28=1;
        	            	}
        	                break;
        	            case 32:
        	            	{
        	            		alt28=2;
        	            	}
        	                break;
        	            case 33:
        	            	{
        	            		alt28=3;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt28=4;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt28=5;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt28=6;
        	            	}
        	                break;

        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:504:13: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1650);
        	        	        opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:505:6: '-1'
        	        	    {
        	        	         this->matchToken(32, &FOLLOW_32_in_cmd1659);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:505:13: '-2'
        	        	    {
        	        	         this->matchToken(33, &FOLLOW_33_in_cmd1663);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:506:6: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd1670);
        	        	        word16=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();  s << (this->get_strstream()->toStringTT(word16.start, word16.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 5:
        	        	    // SimpleBashSQL.g:511:6: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd1684);
        	        	        from_redir17=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir17
        	        	            .empty())
        	        	            					r->makeUnion(from_redir17
        	        	            );
        	        	            				else /* sonst subshell */
        	        	            					r->makeUnion(lastquery);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 6:
        	        	    // SimpleBashSQL.g:518:6: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd1697);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop28;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop28: ; /* Jump out to here if this rule does not match */


        	        {
        	            r->makeUnion(fromPipe);
        	        }


        	    }
        	    break;
        	case 7:
        	    // SimpleBashSQL.g:523:4: 'join' ( ( '-1' n1= number ) | ( '-2' n2= number ) | OPTS | word | '- ' | from_redir )+
        	    {
        	         this->matchToken(71, &FOLLOW_71_in_cmd1716);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:523:11: ( ( '-1' n1= number ) | ( '-2' n2= number ) | OPTS | word | '- ' | from_redir )+
        	        {
        	            int cnt29=0;

        	            for (;;)
        	            {
        	                int alt29=7;
        	        	switch ( this->LA(1) )
        	        	{
        	        	case 32:
        	        		{
        	        			alt29=1;
        	        		}
        	        	    break;
        	        	case 33:
        	        		{
        	        			alt29=2;
        	        		}
        	        	    break;
        	        	case OPTS:
        	        		{
        	        			alt29=3;
        	        		}
        	        	    break;
        	        	case WORD:
        	        	case 18:
        	        		{
        	        			alt29=4;
        	        		}
        	        	    break;
        	        	case 30:
        	        		{
        	        			alt29=5;
        	        		}
        	        	    break;
        	        	case 39:
        	        	case 40:
        	        	case 42:
        	        		{
        	        			alt29=6;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt29)
        	        	{
        	        	    case 1:
        	        	        // SimpleBashSQL.g:523:12: ( '-1' n1= number )
        	        	        {
        	        	            // SimpleBashSQL.g:523:12: ( '-1' n1= number )
        	        	            // SimpleBashSQL.g:523:13: '-1' n1= number
        	        	            {
        	        	                 this->matchToken(32, &FOLLOW_32_in_cmd1720);
        	        	                if  (this->hasException())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	                this->followPush(FOLLOW_number_in_cmd1724);
        	        	                n1=number();

        	        	                this->followPop();
        	        	                if  (this->hasException())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // SimpleBashSQL.g:524:19: ( '-2' n2= number )
        	        	        {
        	        	            // SimpleBashSQL.g:524:19: ( '-2' n2= number )
        	        	            // SimpleBashSQL.g:524:20: '-2' n2= number
        	        	            {
        	        	                 this->matchToken(33, &FOLLOW_33_in_cmd1746);
        	        	                if  (this->hasException())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	                this->followPush(FOLLOW_number_in_cmd1750);
        	        	                n2=number();

        	        	                this->followPop();
        	        	                if  (this->hasException())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	            }


        	        	        }
        	        	        break;
        	        	    case 3:
        	        	        // SimpleBashSQL.g:525:19: OPTS
        	        	        {
        	        	             this->matchToken(OPTS, &FOLLOW_OPTS_in_cmd1771);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 4:
        	        	        // SimpleBashSQL.g:526:19: word
        	        	        {
        	        	            this->followPush(FOLLOW_word_in_cmd1791);
        	        	            word18=word();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {

        	        	                			s.str(""); s.clear();
        	        	                			s << (this->get_strstream()->toStringTT(word18.start, word18.stop))
        	        	                ; r->makeCross(s.str());
        	        	                			/* helpsize to detect first field of 2nd table*/
        	        	                			helpsize= helpsize==0 ? 
        	        	                				r->getColumnsCount() : helpsize;
        	        	                                        
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 5:
        	        	        // SimpleBashSQL.g:534:19: '- '
        	        	        {
        	        	             this->matchToken(30, &FOLLOW_30_in_cmd1816);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {

        	        	                			r->makeCross(fromPipe);
        	        	                			/* helpsize to detect first field of 2nd table*/
        	        	                			helpsize= helpsize==0 ? 
        	        	                				r->getColumnsCount() : helpsize;
        	        	                                        
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 6:
        	        	        // SimpleBashSQL.g:541:19: from_redir
        	        	        {
        	        	            this->followPush(FOLLOW_from_redir_in_cmd1843);
        	        	            from_redir19=from_redir();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                /* fname!=NULL, wenn Dateiname */
        	        	                			if (!from_redir19
        	        	                .empty())
        	        	                				r->makeUnion(from_redir19
        	        	                );
        	        	                                        else /* sonst subshell */
        	        	                                                r->makeCross(lastquery);
        	        	                			/* helpsize to detect first field of 2nd table*/
        	        	                			helpsize= helpsize==0 ? 
        	        	                				r->getColumnsCount() : helpsize;
        	        	                                        
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt29 >= 1 )
        	        		{
        	        		    goto loop29;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		new ANTLR_Exception< SimpleBashSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        	        		goto rulecmdEx;
        	        	}
        	        	cnt29++;
        	            }
        	            loop29: ;	/* Jump to here if this rule does not match */
        	        }

        	        {

        	            		s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(n2.start, n2.stop))
        	            ;
        	            		/*get relative column number*/
        	            		join_on=stoi(s.str())+helpsize;
        	            		s.str(""); s.clear(); 
        	            		s<< "t1.$" <<(this->get_strstream()->toStringTT(n1.start, n1.stop))
        	             << "=t2.$" << join_on;
        	            		r->addCondition(s.str());
        	            		/*print the relevant columns*/
        	            		int max=r->getColumnsCount();
        	            		for(int i=1; i<=max;i++)
        	            			r->addSelect("$"+std::to_string(i));
        	            		r->deleteSelect(join_on);
        	            		
        	        }


        	    }
        	    break;
        	case 8:
        	    // SimpleBashSQL.g:566:4: 'tee' word
        	    {
        	         this->matchToken(75, &FOLLOW_75_in_cmd1898);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        this->followPush(FOLLOW_word_in_cmd1901);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        {

        	            				delete r;
        	            				r=fromPipe;
        	            			
        	        }


        	    }
        	    break;
        	case 9:
        	    // SimpleBashSQL.g:572:4: 'uniq' ( opts | word | from_redir | '- ' )*
        	    {
        	         this->matchToken(77, &FOLLOW_77_in_cmd1914);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:572:11: ( opts | word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt30=5;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt30=1;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt30=2;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt30=3;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt30=4;
        	            	}
        	                break;

        	            }

        	            switch (alt30)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:572:13: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd1918);
        	        	        opts20=opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             s.str(""); s.clear();
        	        	            				s << (this->get_strstream()->toStringTT(opts20.start, opts20.stop))
        	        	            ; s.getline(buffer,80);
        	        	            				optsuniq(buffer,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:577:6: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd1931);
        	        	        word21=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(word21.start, word21.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:581:27: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd1965);
        	        	        from_redir22=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir22
        	        	            .empty())
        	        	            					r->makeUnion(from_redir22
        	        	            );
        	        	                                            else /* sonst subshell */
        	        	                                                    r->makeUnion(lastquery);
        	        	                                            
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:588:27: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd2027);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop30;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop30: ; /* Jump out to here if this rule does not match */


        	        {

        	            			r->makeUnion(fromPipe);
        	            			/* uniq is realized by groups, so group
        	            			f.a. x elem select 
        	            			begin with $1*/
        	            			for (int i=1;i<=fromPipe->getColumnsCount(); i++)
        	            				r->addSelect("$"+std::to_string(i));
        	            			r->addGroup(fromPipe->getColumns());
        	            			
        	        }


        	    }
        	    break;
        	case 10:
        	    // SimpleBashSQL.g:599:5: 'wc -l' ( opts | word | from_redir | '- ' )*
        	    {
        	         this->matchToken(79, &FOLLOW_79_in_cmd2063);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:600:4: ( opts | word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt31=5;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt31=1;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt31=2;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt31=3;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt31=4;
        	            	}
        	                break;

        	            }

        	            switch (alt31)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:600:6: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd2076);
        	        	        opts23=opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();
        	        	            				s << (this->get_strstream()->toStringTT(opts23.start, opts23.stop))
        	        	            ; s.getline(buffer,80);
        	        	            				optswc(buffer,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:606:6: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd2090);
        	        	        word24=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             s.str(""); s.clear(); s << (this->get_strstream()->toStringTT(word24.start, word24.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:610:27: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd2124);
        	        	        from_redir25=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir25
        	        	            .empty())
        	        	            					r->makeUnion(from_redir25
        	        	            );
        	        	                                            else /* sonst subshell */
        	        	                                                    r->makeUnion(lastquery);
        	        	                                            
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:617:27: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd2186);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop31;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop31: ; /* Jump out to here if this rule does not match */


        	        {

        	            			r->addSelect("count(*)");
        	            			r->makeUnion(fromPipe);
        	            			
        	        }


        	    }
        	    break;
        	case 11:
        	    // SimpleBashSQL.g:623:11: 'awk' ( OPTS )* '\\'' ( '\\n' )* ( awkbody[r] ( '\\n' )* )+ '\\'' ( assignment | OPTS )* ( word | from_redir | '- ' )*
        	    {
        	         this->matchToken(54, &FOLLOW_54_in_cmd2228);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:623:17: ( OPTS )*

        	        for (;;)
        	        {
        	            int alt32=2;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt32=1;
        	            	}
        	                break;

        	            }

        	            switch (alt32)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:623:17: OPTS
        	        	    {
        	        	         this->matchToken(OPTS, &FOLLOW_OPTS_in_cmd2230);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop32;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop32: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(52, &FOLLOW_52_in_cmd2233);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:623:28: ( '\\n' )*

        	        for (;;)
        	        {
        	            int alt33=2;
        	            switch ( this->LA(1) )
        	            {
        	            case 53:
        	            	{
        	            		alt33=1;
        	            	}
        	                break;

        	            }

        	            switch (alt33)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:623:29: '\\n'
        	        	    {
        	        	         this->matchToken(53, &FOLLOW_53_in_cmd2236);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop33;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop33: ; /* Jump out to here if this rule does not match */


        	        // SimpleBashSQL.g:624:4: ( awkbody[r] ( '\\n' )* )+
        	        {
        	            int cnt35=0;

        	            for (;;)
        	            {
        	                int alt35=2;
        	        	switch ( this->LA(1) )
        	        	{
        	        	case NUMBER:
        	        	case WORD:
        	        	case 18:
        	        	case 81:
        	        		{
        	        			alt35=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt35)
        	        	{
        	        	    case 1:
        	        	        // SimpleBashSQL.g:624:5: awkbody[r] ( '\\n' )*
        	        	        {
        	        	            this->followPush(FOLLOW_awkbody_in_cmd2245);
        	        	            awkbody(r);

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            // SimpleBashSQL.g:624:16: ( '\\n' )*

        	        	            for (;;)
        	        	            {
        	        	                int alt34=2;
        	        	                switch ( this->LA(1) )
        	        	                {
        	        	                case 53:
        	        	                	{
        	        	                		alt34=1;
        	        	                	}
        	        	                    break;

        	        	                }

        	        	                switch (alt34)
        	        	                {
        	        	            	case 1:
        	        	            	    // SimpleBashSQL.g:624:17: '\\n'
        	        	            	    {
        	        	            	         this->matchToken(53, &FOLLOW_53_in_cmd2249);
        	        	            	        if  (this->hasException())
        	        	            	        {
        	        	            	            goto rulecmdEx;
        	        	            	        }


        	        	            	    }
        	        	            	    break;

        	        	            	default:
        	        	            	    goto loop34;	/* break out of the loop */
        	        	            	    break;
        	        	                }
        	        	            }
        	        	            loop34: ; /* Jump out to here if this rule does not match */


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt35 >= 1 )
        	        		{
        	        		    goto loop35;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		new ANTLR_Exception< SimpleBashSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        	        		goto rulecmdEx;
        	        	}
        	        	cnt35++;
        	            }
        	            loop35: ;	/* Jump to here if this rule does not match */
        	        }

        	         this->matchToken(52, &FOLLOW_52_in_cmd2255);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:624:31: ( assignment | OPTS )*

        	        for (;;)
        	        {
        	            int alt36=3;
        	            switch ( this->LA(1) )
        	            {
        	            case WORD:
        	            	{
        	            		switch ( this->LA(2) )
        	            		{
        	            		case 45:
        	            			{
        	            				alt36=1;
        	            			}
        	            		    break;

        	            		}

        	            	}
        	                break;
        	            case 18:
        	            	{
        	            		switch ( this->LA(2) )
        	            		{
        	            		case WORD:
        	            			{
        	            				switch ( this->LA(3) )
        	            				{
        	            				case 18:
        	            					{
        	            						switch ( this->LA(4) )
        	            						{
        	            						case 45:
        	            							{
        	            								alt36=1;
        	            							}
        	            						    break;

        	            						}

        	            					}
        	            				    break;

        	            				}

        	            			}
        	            		    break;

        	            		}

        	            	}
        	                break;
        	            case OPTS:
        	            	{
        	            		alt36=2;
        	            	}
        	                break;

        	            }

        	            switch (alt36)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:624:32: assignment
        	        	    {
        	        	        this->followPush(FOLLOW_assignment_in_cmd2258);
        	        	        assignment();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:624:43: OPTS
        	        	    {
        	        	         this->matchToken(OPTS, &FOLLOW_OPTS_in_cmd2260);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop36;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop36: ; /* Jump out to here if this rule does not match */


        	        // SimpleBashSQL.g:627:4: ( word | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt37=4;
        	            switch ( this->LA(1) )
        	            {
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt37=1;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt37=2;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt37=3;
        	            	}
        	                break;

        	            }

        	            switch (alt37)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:627:5: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd2298);
        	        	        word26=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {

        	        	            				s.str(""); s.clear();  s << (this->get_strstream()->toStringTT(word26.start, word26.stop))
        	        	            ;
        	        	            				r->makeUnion(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:632:6: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd2312);
        	        	        from_redir27=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir27
        	        	            .empty())
        	        	            					r->makeUnion(from_redir27
        	        	            );
        	        	            				else /* sonst subshell */
        	        	            					r->makeUnion(lastquery);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:639:6: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd2325);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop37;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop37: ; /* Jump out to here if this rule does not match */


        	        {

        	            			r->makeUnion(fromPipe);
        	            			
        	        }


        	    }
        	    break;
        	case 12:
        	    // SimpleBashSQL.g:644:4: 'datamash' ( opts | word number | from_redir | '- ' )*
        	    {
        	         this->matchToken(58, &FOLLOW_58_in_cmd2341);
        	        if  (this->hasException())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:644:15: ( opts | word number | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt38=5;
        	            switch ( this->LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt38=1;
        	            	}
        	                break;
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt38=2;
        	            	}
        	                break;
        	            case 39:
        	            case 40:
        	            case 42:
        	            	{
        	            		alt38=3;
        	            	}
        	                break;
        	            case 30:
        	            	{
        	            		alt38=4;
        	            	}
        	                break;

        	            }

        	            switch (alt38)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:644:17: opts
        	        	    {
        	        	        this->followPush(FOLLOW_opts_in_cmd2345);
        	        	        opts28=opts();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             s.str(""); s.clear();
        	        	            				s << (this->get_strstream()->toStringTT(opts28.start, opts28.stop))
        	        	            ; s.getline(buffer,80);
        	        	            				optsdatamash(buffer,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:649:6: word number
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd2358);
        	        	        word29=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        this->followPush(FOLLOW_number_in_cmd2360);
        	        	        number30=number();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             s.str(""); s.clear();
        	        	            				/*aggregate function and the columns
        	        	            				  adds them into the current select stm
        	        	            				*/
        	        	            				s<<(this->get_strstream()->toStringTT(word29.start, word29.stop))
        	        	            <<"($"<<(this->get_strstream()->toStringTT(number30.start, number30.stop))
        	        	            <<")";
        	        	            				r->addSelect(s.str());
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:657:27: from_redir
        	        	    {
        	        	        this->followPush(FOLLOW_from_redir_in_cmd2394);
        	        	        from_redir31=from_redir();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (!from_redir31
        	        	            .empty())
        	        	            					r->makeUnion(from_redir31
        	        	            );
        	        	                                            else /* sonst subshell */
        	        	                                                    r->makeUnion(lastquery);
        	        	                                            
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:664:27: '- '
        	        	    {
        	        	         this->matchToken(30, &FOLLOW_30_in_cmd2456);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop38;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop38: ; /* Jump out to here if this rule does not match */


        	        {

        	            			r->makeUnion(fromPipe);
        	            			
        	        }


        	    }
        	    break;
        	case 13:
        	    // SimpleBashSQL.g:670:4: ( word )*
        	    {
        	        // SimpleBashSQL.g:670:4: ( word )*

        	        for (;;)
        	        {
        	            int alt39=2;
        	            switch ( this->LA(1) )
        	            {
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt39=1;
        	            	}
        	                break;

        	            }

        	            switch (alt39)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:670:4: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_cmd2494);
        	        	        word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop39;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop39: ; /* Jump out to here if this rule does not match */


        	        {

        	            			/*the used sqltool first*/
        	            			if(fromPipe != NULL && sqltool!=""){
        	            				cout << sqltool << " ";
        	            				fromPipe->print();
        	            			}
        	            			else if(fromPipe!=NULL){
        	            				fromPipe->print();
        	            			}
        	            			delete r;
        	            			r=NULL;
        	            		
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecmdEx; /* Prevent compiler warnings */
    rulecmdEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {

                	/* query r is the most recent query  */
                	lastquery=r;

            }
        }

    return r;
}
/* $ANTLR end cmd */

/**
 * $ANTLR start assignment
 * SimpleBashSQL.g:685:1: assignment : word '=' word ;
 */
void
SimpleBashSQLParser::assignment()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:685:11: ( word '=' word )
        // SimpleBashSQL.g:685:13: word '=' word
        {
            this->followPush(FOLLOW_word_in_assignment2509);
            word();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleassignmentEx;
            }


             this->matchToken(45, &FOLLOW_45_in_assignment2510);
            if  (this->hasException())
            {
                goto ruleassignmentEx;
            }


            this->followPush(FOLLOW_word_in_assignment2511);
            word();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleassignmentEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end assignment */

/**
 * $ANTLR start awkbody
 * SimpleBashSQL.g:689:1: awkbody[TheQuery* r] : (a1= awkpattern ( ( '&&' | '||' ) a2= awkpattern )* )? '{' ( '\\n' )* ( awkcmds[r] ( '\\n' )* )+ '}' ;
 */
void
SimpleBashSQLParser::awkbody(TheQuery* r)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    string a1;
    string a2;
    /* Initialize rule variables
     */


    	stringstream s;


 
    {
        // SimpleBashSQL.g:693:3: ( (a1= awkpattern ( ( '&&' | '||' ) a2= awkpattern )* )? '{' ( '\\n' )* ( awkcmds[r] ( '\\n' )* )+ '}' )
        // SimpleBashSQL.g:693:5: (a1= awkpattern ( ( '&&' | '||' ) a2= awkpattern )* )? '{' ( '\\n' )* ( awkcmds[r] ( '\\n' )* )+ '}'
        {
            // SimpleBashSQL.g:693:5: (a1= awkpattern ( ( '&&' | '||' ) a2= awkpattern )* )?
            {
                int alt42=2;
                switch ( this->LA(1) )
                {
                    case NUMBER:
                    case WORD:
                    case 18:
                    	{
                    		alt42=1;
                    	}
                        break;
                }

                switch (alt42)
                {
            	case 1:
            	    // SimpleBashSQL.g:693:7: a1= awkpattern ( ( '&&' | '||' ) a2= awkpattern )*
            	    {
            	        this->followPush(FOLLOW_awkpattern_in_awkbody2534);
            	        a1=awkpattern();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkbodyEx;
            	        }


            	        {

            	            		r->addCondition(a1
            	            );
            	            		
            	        }


            	        // SimpleBashSQL.g:698:3: ( ( '&&' | '||' ) a2= awkpattern )*

            	        for (;;)
            	        {
            	            int alt41=2;
            	            switch ( this->LA(1) )
            	            {
            	            case 21:
            	            case 82:
            	            	{
            	            		alt41=1;
            	            	}
            	                break;

            	            }

            	            switch (alt41)
            	            {
            	        	case 1:
            	        	    // SimpleBashSQL.g:698:4: ( '&&' | '||' ) a2= awkpattern
            	        	    {
            	        	        if ( this->LA(1) == 21 || this->LA(1) == 82 )
            	        	        {
            	        	            this->consume();
            	        	            this->set_perror_recovery(false);
            	        	        }
            	        	        else
            	        	        {
            	        	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	        	            this->get_exception()->set_expectingSet(NULL);

            	        	            goto ruleawkbodyEx;
            	        	        }


            	        	        this->followPush(FOLLOW_awkpattern_in_awkbody2557);
            	        	        a2=awkpattern();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleawkbodyEx;
            	        	        }


            	        	        {

            	        	            		r->addCondition(a2
            	        	            );
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop41;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop41: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(81, &FOLLOW_81_in_awkbody2605);
            if  (this->hasException())
            {
                goto ruleawkbodyEx;
            }


            // SimpleBashSQL.g:704:21: ( '\\n' )*

            for (;;)
            {
                int alt43=2;
                switch ( this->LA(1) )
                {
                case 53:
                	{
                		alt43=1;
                	}
                    break;

                }

                switch (alt43)
                {
            	case 1:
            	    // SimpleBashSQL.g:704:22: '\\n'
            	    {
            	         this->matchToken(53, &FOLLOW_53_in_awkbody2608);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkbodyEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop43;	/* break out of the loop */
            	    break;
                }
            }
            loop43: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:704:29: ( awkcmds[r] ( '\\n' )* )+
            {
                int cnt45=0;

                for (;;)
                {
                    int alt45=2;
            	switch ( this->LA(1) )
            	{
            	case WORD:
            	case 18:
            	case 69:
            	case 72:
            		{
            			alt45=1;
            		}
            	    break;

            	}

            	switch (alt45)
            	{
            	    case 1:
            	        // SimpleBashSQL.g:704:30: awkcmds[r] ( '\\n' )*
            	        {
            	            this->followPush(FOLLOW_awkcmds_in_awkbody2613);
            	            awkcmds(r);

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleawkbodyEx;
            	            }


            	            // SimpleBashSQL.g:704:41: ( '\\n' )*

            	            for (;;)
            	            {
            	                int alt44=2;
            	                switch ( this->LA(1) )
            	                {
            	                case 53:
            	                	{
            	                		alt44=1;
            	                	}
            	                    break;

            	                }

            	                switch (alt44)
            	                {
            	            	case 1:
            	            	    // SimpleBashSQL.g:704:42: '\\n'
            	            	    {
            	            	         this->matchToken(53, &FOLLOW_53_in_awkbody2617);
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto ruleawkbodyEx;
            	            	        }


            	            	    }
            	            	    break;

            	            	default:
            	            	    goto loop44;	/* break out of the loop */
            	            	    break;
            	                }
            	            }
            	            loop44: ; /* Jump out to here if this rule does not match */


            	        }
            	        break;

            	    default:

            		if ( cnt45 >= 1 )
            		{
            		    goto loop45;
            		}
            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SimpleBashSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleawkbodyEx;
            	}
            	cnt45++;
                }
                loop45: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(83, &FOLLOW_83_in_awkbody2624);
            if  (this->hasException())
            {
                goto ruleawkbodyEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawkbodyEx; /* Prevent compiler warnings */
    ruleawkbodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end awkbody */

/**
 * $ANTLR start awkpattern
 * SimpleBashSQL.g:708:1: awkpattern returns [string cond] : awkpatternparsed ;
 */
string
SimpleBashSQLParser::awkpattern()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    string cond;


    awkpatternparsed_return awkpatternparsed32;
    /* Initialize rule variables
     */
     


    	stringstream s;


 
    {
        // SimpleBashSQL.g:730:2: ( awkpatternparsed )
        // SimpleBashSQL.g:730:4: awkpatternparsed
        {
            this->followPush(FOLLOW_awkpatternparsed_in_awkpattern2656);
            awkpatternparsed32=awkpatternparsed();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleawkpatternEx;
            }


            {

                		s << (this->get_strstream()->toStringTT(awkpatternparsed32.start, awkpatternparsed32.stop))
                ;
                	
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawkpatternEx; /* Prevent compiler warnings */
    ruleawkpatternEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {

                	cond=s.str();
                	/*contains NR? not so in sql*/
                	if(!cond.find("NR"))
                		cond="true";
                	/*contains NF? not so in sql*/
                	if(!cond.find("NF"))
                		cond="true";
                	/*replaces all appearances of " by ' for sql string*/
                	replace_inline_grammar(cond,"\"", "'");
                	replace_inline_grammar(cond,"==", "=");
                	/* x ~/ pattern / ==> x like 'pattern'  */
                	replace_inline_grammar(cond,"~/", " like '");
                	replace_inline_grammar(cond,"/", "'");
                	/*awk regex to sql regex*/
                	replace_inline_grammar(cond,".*", "%");
                	replace_inline_grammar(cond,".", "?");

            }
        }

    return cond;
}
/* $ANTLR end awkpattern */

/**
 * $ANTLR start awkpatternparsed
 * SimpleBashSQL.g:737:1: awkpatternparsed : ( (w1= word |n1= number ) ( '!=' | '<' | '>' | '==' | '<=' | '>=' ) (w2= word |n2= number ) | ( word | number ) '~/' word '/' );
 */
SimpleBashSQLParser::awkpatternparsed_return
SimpleBashSQLParser::awkpatternparsed()
{
    SimpleBashSQLParser::awkpatternparsed_return retval(this);


    word_return w1;
    number_return n1;
    word_return w2;
    number_return n2;
    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        {
            //  SimpleBashSQL.g:738:2: ( (w1= word |n1= number ) ( '!=' | '<' | '>' | '==' | '<=' | '>=' ) (w2= word |n2= number ) | ( word | number ) '~/' word '/' )

            ANTLR_UINT32 alt49;

            alt49=2;

            switch ( this->LA(1) )
            {
            case WORD:
            	{
            		switch ( this->LA(2) )
            		{
            		case 17:
            		case 39:
            		case 43:
            		case 46:
            		case 48:
            		case 49:
            			{
            				alt49=1;
            			}
            		    break;
            		case 84:
            			{
            				alt49=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 49 );
            		    ex->set_state( 1 );


            		    goto ruleawkpatternparsedEx;

            		}

            	}
                break;
            case 18:
            	{
            		switch ( this->LA(2) )
            		{
            		case WORD:
            			{
            				switch ( this->LA(3) )
            				{
            				case 18:
            					{
            						switch ( this->LA(4) )
            						{
            						case 17:
            						case 39:
            						case 43:
            						case 46:
            						case 48:
            						case 49:
            							{
            								alt49=1;
            							}
            						    break;
            						case 84:
            							{
            								alt49=2;
            							}
            						    break;

            						default:
            						    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            						    ex->set_decisionNum( 49 );
            						    ex->set_state( 7 );


            						    goto ruleawkpatternparsedEx;

            						}

            					}
            				    break;

            				default:
            				    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 49 );
            				    ex->set_state( 6 );


            				    goto ruleawkpatternparsedEx;

            				}

            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 49 );
            		    ex->set_state( 2 );


            		    goto ruleawkpatternparsedEx;

            		}

            	}
                break;
            case NUMBER:
            	{
            		switch ( this->LA(2) )
            		{
            		case 17:
            		case 39:
            		case 43:
            		case 46:
            		case 48:
            		case 49:
            			{
            				alt49=1;
            			}
            		    break;
            		case 84:
            			{
            				alt49=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 49 );
            		    ex->set_state( 3 );


            		    goto ruleawkpatternparsedEx;

            		}

            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 49 );
                ex->set_state( 0 );


                goto ruleawkpatternparsedEx;

            }

            switch (alt49)
            {
        	case 1:
        	    // SimpleBashSQL.g:738:3: (w1= word |n1= number ) ( '!=' | '<' | '>' | '==' | '<=' | '>=' ) (w2= word |n2= number )
        	    {
        	        // SimpleBashSQL.g:738:3: (w1= word |n1= number )
        	        {
        	            int alt46=2;
        	            switch ( this->LA(1) )
        	            {
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt46=1;
        	            	}
        	                break;
        	            case NUMBER:
        	            	{
        	            		alt46=2;
        	            	}
        	                break;

        	            default:
        	                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 46 );
        	                ex->set_state( 0 );


        	                goto ruleawkpatternparsedEx;

        	            }

        	            switch (alt46)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:738:4: w1= word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_awkpatternparsed2674);
        	        	        w1=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleawkpatternparsedEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:738:12: n1= number
        	        	    {
        	        	        this->followPush(FOLLOW_number_in_awkpatternparsed2678);
        	        	        n1=number();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleawkpatternparsedEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        if ( this->LA(1) == 17 || this->LA(1) == 39 || this->LA(1) == 43 || this->LA(1) == 46 || ((this->LA(1) >= 48) && (this->LA(1) <= 49)) )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto ruleawkpatternparsedEx;
        	        }


        	        // SimpleBashSQL.g:738:53: (w2= word |n2= number )
        	        {
        	            int alt47=2;
        	            switch ( this->LA(1) )
        	            {
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt47=1;
        	            	}
        	                break;
        	            case NUMBER:
        	            	{
        	            		alt47=2;
        	            	}
        	                break;

        	            default:
        	                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 47 );
        	                ex->set_state( 0 );


        	                goto ruleawkpatternparsedEx;

        	            }

        	            switch (alt47)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:738:54: w2= word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_awkpatternparsed2698);
        	        	        w2=word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleawkpatternparsedEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:738:62: n2= number
        	        	    {
        	        	        this->followPush(FOLLOW_number_in_awkpatternparsed2702);
        	        	        n2=number();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleawkpatternparsedEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:739:4: ( word | number ) '~/' word '/'
        	    {
        	        // SimpleBashSQL.g:739:4: ( word | number )
        	        {
        	            int alt48=2;
        	            switch ( this->LA(1) )
        	            {
        	            case WORD:
        	            case 18:
        	            	{
        	            		alt48=1;
        	            	}
        	                break;
        	            case NUMBER:
        	            	{
        	            		alt48=2;
        	            	}
        	                break;

        	            default:
        	                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 48 );
        	                ex->set_state( 0 );


        	                goto ruleawkpatternparsedEx;

        	            }

        	            switch (alt48)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:739:5: word
        	        	    {
        	        	        this->followPush(FOLLOW_word_in_awkpatternparsed2709);
        	        	        word();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleawkpatternparsedEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:739:10: number
        	        	    {
        	        	        this->followPush(FOLLOW_number_in_awkpatternparsed2711);
        	        	        number();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleawkpatternparsedEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(84, &FOLLOW_84_in_awkpatternparsed2714);
        	        if  (this->hasException())
        	        {
        	            goto ruleawkpatternparsedEx;
        	        }


        	        this->followPush(FOLLOW_word_in_awkpatternparsed2716);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleawkpatternparsedEx;
        	        }


        	         this->matchToken(35, &FOLLOW_35_in_awkpatternparsed2718);
        	        if  (this->hasException())
        	        {
        	            goto ruleawkpatternparsedEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleawkpatternparsedEx; /* Prevent compiler warnings */
    ruleawkpatternparsedEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end awkpatternparsed */

/**
 * $ANTLR start awkcmds
 * SimpleBashSQL.g:743:1: awkcmds[TheQuery* r] : ( 'print' ( awklist[vm,r] ) | awkop[vm] | awkif[r] ) ( ';' )? ;
 */
void
SimpleBashSQLParser::awkcmds(TheQuery* r)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


    	/*keyvalue store for the variables in awk*/
    	std::map<std::string, std::string> vm;
    	stringstream s;


 
    {
        // SimpleBashSQL.g:749:2: ( ( 'print' ( awklist[vm,r] ) | awkop[vm] | awkif[r] ) ( ';' )? )
        // SimpleBashSQL.g:749:5: ( 'print' ( awklist[vm,r] ) | awkop[vm] | awkif[r] ) ( ';' )?
        {
            // SimpleBashSQL.g:749:5: ( 'print' ( awklist[vm,r] ) | awkop[vm] | awkif[r] )
            {
                int alt50=3;
                switch ( this->LA(1) )
                {
                case 72:
                	{
                		alt50=1;
                	}
                    break;
                case WORD:
                case 18:
                	{
                		alt50=2;
                	}
                    break;
                case 69:
                	{
                		alt50=3;
                	}
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 50 );
                    ex->set_state( 0 );


                    goto ruleawkcmdsEx;

                }

                switch (alt50)
                {
            	case 1:
            	    // SimpleBashSQL.g:749:6: 'print' ( awklist[vm,r] )
            	    {
            	         this->matchToken(72, &FOLLOW_72_in_awkcmds2738);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkcmdsEx;
            	        }


            	        // SimpleBashSQL.g:749:15: ( awklist[vm,r] )
            	        // SimpleBashSQL.g:749:16: awklist[vm,r]
            	        {
            	            this->followPush(FOLLOW_awklist_in_awkcmds2742);
            	            awklist(vm, r);

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleawkcmdsEx;
            	            }


            	        }


            	    }
            	    break;
            	case 2:
            	    // SimpleBashSQL.g:750:4: awkop[vm]
            	    {
            	        this->followPush(FOLLOW_awkop_in_awkcmds2749);
            	        awkop(vm);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkcmdsEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // SimpleBashSQL.g:751:4: awkif[r]
            	    {
            	        this->followPush(FOLLOW_awkif_in_awkcmds2755);
            	        awkif(r);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkcmdsEx;
            	        }


            	    }
            	    break;

                }
            }

            // SimpleBashSQL.g:752:4: ( ';' )?
            {
                int alt51=2;
                switch ( this->LA(1) )
                {
                    case 36:
                    	{
                    		alt51=1;
                    	}
                        break;
                }

                switch (alt51)
                {
            	case 1:
            	    // SimpleBashSQL.g:752:5: ';'
            	    {
            	         this->matchToken(36, &FOLLOW_36_in_awkcmds2762);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkcmdsEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawkcmdsEx; /* Prevent compiler warnings */
    ruleawkcmdsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end awkcmds */

/**
 * $ANTLR start awkop
 * SimpleBashSQL.g:756:1: awkop[map<std::string,std::string> &vm] : word ( '=' | '+=' | '*=' | '-=' ) awkmath ;
 */
void
SimpleBashSQLParser::awkop(map<std::string,std::string> &vm)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    word_return word33;
    awkmath_return awkmath34;
    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:757:2: ( word ( '=' | '+=' | '*=' | '-=' ) awkmath )
        // SimpleBashSQL.g:757:4: word ( '=' | '+=' | '*=' | '-=' ) awkmath
        {
            this->followPush(FOLLOW_word_in_awkop2777);
            word33=word();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleawkopEx;
            }


            if ( this->LA(1) == 27 || this->LA(1) == 29 || this->LA(1) == 34 || this->LA(1) == 45 )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleawkopEx;
            }


            this->followPush(FOLLOW_awkmath_in_awkop2789);
            awkmath34=awkmath();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleawkopEx;
            }


            {

                		stringstream s1,s2;
                		s1<<(this->get_strstream()->toStringTT(word33.start, word33.stop))
                ; s2<<(this->get_strstream()->toStringTT(awkmath34.start, awkmath34.stop))
                ;
                		vm[s1.str()]=s2.str();
                	
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawkopEx; /* Prevent compiler warnings */
    ruleawkopEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end awkop */

/**
 * $ANTLR start awkmath
 * SimpleBashSQL.g:765:1: awkmath : ( '(' )? ( word | number ) ( ')' )? ( ( '*' | '+' | '-' | '/' ) awkmath )? ;
 */
SimpleBashSQLParser::awkmath_return
SimpleBashSQLParser::awkmath()
{
    SimpleBashSQLParser::awkmath_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        // SimpleBashSQL.g:766:2: ( ( '(' )? ( word | number ) ( ')' )? ( ( '*' | '+' | '-' | '/' ) awkmath )? )
        // SimpleBashSQL.g:766:4: ( '(' )? ( word | number ) ( ')' )? ( ( '*' | '+' | '-' | '/' ) awkmath )?
        {
            // SimpleBashSQL.g:766:4: ( '(' )?
            {
                int alt52=2;
                switch ( this->LA(1) )
                {
                    case 24:
                    	{
                    		alt52=1;
                    	}
                        break;
                }

                switch (alt52)
                {
            	case 1:
            	    // SimpleBashSQL.g:766:4: '('
            	    {
            	         this->matchToken(24, &FOLLOW_24_in_awkmath2803);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkmathEx;
            	        }


            	    }
            	    break;

                }
            }

            // SimpleBashSQL.g:766:9: ( word | number )
            {
                int alt53=2;
                switch ( this->LA(1) )
                {
                case WORD:
                case 18:
                	{
                		alt53=1;
                	}
                    break;
                case NUMBER:
                	{
                		alt53=2;
                	}
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 53 );
                    ex->set_state( 0 );


                    goto ruleawkmathEx;

                }

                switch (alt53)
                {
            	case 1:
            	    // SimpleBashSQL.g:766:10: word
            	    {
            	        this->followPush(FOLLOW_word_in_awkmath2807);
            	        word();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkmathEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // SimpleBashSQL.g:766:15: number
            	    {
            	        this->followPush(FOLLOW_number_in_awkmath2809);
            	        number();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkmathEx;
            	        }


            	    }
            	    break;

                }
            }

            // SimpleBashSQL.g:766:23: ( ')' )?
            {
                int alt54=2;
                switch ( this->LA(1) )
                {
                    case 25:
                    	{
                    		alt54=1;
                    	}
                        break;
                }

                switch (alt54)
                {
            	case 1:
            	    // SimpleBashSQL.g:766:23: ')'
            	    {
            	         this->matchToken(25, &FOLLOW_25_in_awkmath2812);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkmathEx;
            	        }


            	    }
            	    break;

                }
            }

            // SimpleBashSQL.g:767:5: ( ( '*' | '+' | '-' | '/' ) awkmath )?
            {
                int alt55=2;
                switch ( this->LA(1) )
                {
                    case 26:
                    case 28:
                    case 31:
                    case 35:
                    	{
                    		alt55=1;
                    	}
                        break;
                }

                switch (alt55)
                {
            	case 1:
            	    // SimpleBashSQL.g:767:6: ( '*' | '+' | '-' | '/' ) awkmath
            	    {
            	        if ( this->LA(1) == 26 || this->LA(1) == 28 || this->LA(1) == 31 || this->LA(1) == 35 )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	        }
            	        else
            	        {
            	            new ANTLR_Exception< SimpleBashSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto ruleawkmathEx;
            	        }


            	        this->followPush(FOLLOW_awkmath_in_awkmath2831);
            	        awkmath();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkmathEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawkmathEx; /* Prevent compiler warnings */
    ruleawkmathEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end awkmath */

/**
 * $ANTLR start awklist
 * SimpleBashSQL.g:770:1: awklist[map<std::string,std::string> &vm, TheQuery* r] : w1= awkexpr ;
 */
void
SimpleBashSQLParser::awklist(map<std::string,std::string> &vm, TheQuery* r)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    awkexpr_return w1;
    /* Initialize rule variables
     */


    	stringstream s;


 
    {
        // SimpleBashSQL.g:774:2: (w1= awkexpr )
        // SimpleBashSQL.g:774:4: w1= awkexpr
        {
            this->followPush(FOLLOW_awkexpr_in_awklist2851);
            w1=awkexpr();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleawklistEx;
            }


            {

                		s<<(this->get_strstream()->toStringTT(w1.start, w1.stop))
                ;
                		r->addSelect(s.str());
                	
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawklistEx; /* Prevent compiler warnings */
    ruleawklistEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end awklist */

/**
 * $ANTLR start awkif
 * SimpleBashSQL.g:781:1: awkif[TheQuery* r] : 'if' '(' awkpattern ')' ( '{' awkcmds[r] '}' | awkcmds[r] ) ( 'else' ( '{' awkpattern '}' | awkcmds[r] ) ) ;
 */
void
SimpleBashSQLParser::awkif(TheQuery* r)
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:782:2: ( 'if' '(' awkpattern ')' ( '{' awkcmds[r] '}' | awkcmds[r] ) ( 'else' ( '{' awkpattern '}' | awkcmds[r] ) ) )
        // SimpleBashSQL.g:782:4: 'if' '(' awkpattern ')' ( '{' awkcmds[r] '}' | awkcmds[r] ) ( 'else' ( '{' awkpattern '}' | awkcmds[r] ) )
        {
             this->matchToken(69, &FOLLOW_69_in_awkif2866);
            if  (this->hasException())
            {
                goto ruleawkifEx;
            }


             this->matchToken(24, &FOLLOW_24_in_awkif2868);
            if  (this->hasException())
            {
                goto ruleawkifEx;
            }


            this->followPush(FOLLOW_awkpattern_in_awkif2870);
            awkpattern();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleawkifEx;
            }


             this->matchToken(25, &FOLLOW_25_in_awkif2872);
            if  (this->hasException())
            {
                goto ruleawkifEx;
            }


            // SimpleBashSQL.g:782:28: ( '{' awkcmds[r] '}' | awkcmds[r] )
            {
                int alt56=2;
                switch ( this->LA(1) )
                {
                case 81:
                	{
                		alt56=1;
                	}
                    break;
                case WORD:
                case 18:
                case 69:
                case 72:
                	{
                		alt56=2;
                	}
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 56 );
                    ex->set_state( 0 );


                    goto ruleawkifEx;

                }

                switch (alt56)
                {
            	case 1:
            	    // SimpleBashSQL.g:782:29: '{' awkcmds[r] '}'
            	    {
            	         this->matchToken(81, &FOLLOW_81_in_awkif2875);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkifEx;
            	        }


            	        this->followPush(FOLLOW_awkcmds_in_awkif2877);
            	        awkcmds(r);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkifEx;
            	        }


            	         this->matchToken(83, &FOLLOW_83_in_awkif2880);
            	        if  (this->hasException())
            	        {
            	            goto ruleawkifEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // SimpleBashSQL.g:782:49: awkcmds[r]
            	    {
            	        this->followPush(FOLLOW_awkcmds_in_awkif2883);
            	        awkcmds(r);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleawkifEx;
            	        }


            	    }
            	    break;

                }
            }

            // SimpleBashSQL.g:783:4: ( 'else' ( '{' awkpattern '}' | awkcmds[r] ) )
            // SimpleBashSQL.g:783:5: 'else' ( '{' awkpattern '}' | awkcmds[r] )
            {
                 this->matchToken(62, &FOLLOW_62_in_awkif2891);
                if  (this->hasException())
                {
                    goto ruleawkifEx;
                }


                // SimpleBashSQL.g:783:12: ( '{' awkpattern '}' | awkcmds[r] )
                {
                    int alt57=2;
                    switch ( this->LA(1) )
                    {
                    case 81:
                    	{
                    		alt57=1;
                    	}
                        break;
                    case WORD:
                    case 18:
                    case 69:
                    case 72:
                    	{
                    		alt57=2;
                    	}
                        break;

                    default:
                        ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 57 );
                        ex->set_state( 0 );


                        goto ruleawkifEx;

                    }

                    switch (alt57)
                    {
                	case 1:
                	    // SimpleBashSQL.g:783:13: '{' awkpattern '}'
                	    {
                	         this->matchToken(81, &FOLLOW_81_in_awkif2894);
                	        if  (this->hasException())
                	        {
                	            goto ruleawkifEx;
                	        }


                	        this->followPush(FOLLOW_awkpattern_in_awkif2896);
                	        awkpattern();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto ruleawkifEx;
                	        }


                	         this->matchToken(83, &FOLLOW_83_in_awkif2898);
                	        if  (this->hasException())
                	        {
                	            goto ruleawkifEx;
                	        }


                	    }
                	    break;
                	case 2:
                	    // SimpleBashSQL.g:783:33: awkcmds[r]
                	    {
                	        this->followPush(FOLLOW_awkcmds_in_awkif2901);
                	        awkcmds(r);

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto ruleawkifEx;
                	        }


                	    }
                	    break;

                    }
                }

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleawkifEx; /* Prevent compiler warnings */
    ruleawkifEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end awkif */

/**
 * $ANTLR start awkexpr
 * SimpleBashSQL.g:786:1: awkexpr : ( word | alchar );
 */
SimpleBashSQLParser::awkexpr_return
SimpleBashSQLParser::awkexpr()
{
    SimpleBashSQLParser::awkexpr_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        {
            //  SimpleBashSQL.g:787:2: ( word | alchar )

            ANTLR_UINT32 alt58;

            alt58=2;

            switch ( this->LA(1) )
            {
            case WORD:
            case 18:
            	{
            		alt58=1;
            	}
                break;
            case ALCHAR:
            	{
            		alt58=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 58 );
                ex->set_state( 0 );


                goto ruleawkexprEx;

            }

            switch (alt58)
            {
        	case 1:
        	    // SimpleBashSQL.g:787:4: word
        	    {
        	        this->followPush(FOLLOW_word_in_awkexpr2915);
        	        word();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleawkexprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:788:4: alchar
        	    {
        	        this->followPush(FOLLOW_alchar_in_awkexpr2920);
        	        alchar();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleawkexprEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleawkexprEx; /* Prevent compiler warnings */
    ruleawkexprEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end awkexpr */

/**
 * $ANTLR start pattern
 * SimpleBashSQL.g:791:1: pattern :;
 */
void
SimpleBashSQLParser::pattern()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:791:8: ()
        // SimpleBashSQL.g:792:2: 
        {
        }

    }
    // This is where rules clean up and exit
    //
    goto rulepatternEx; /* Prevent compiler warnings */
    rulepatternEx: ;


    return ;
}
/* $ANTLR end pattern */

/**
 * $ANTLR start number
 * SimpleBashSQL.g:799:1: number : NUMBER ;
 */
SimpleBashSQLParser::number_return
SimpleBashSQLParser::number()
{
    SimpleBashSQLParser::number_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        // SimpleBashSQL.g:799:7: ( NUMBER )
        // SimpleBashSQL.g:799:9: NUMBER
        {
             this->matchToken(NUMBER, &FOLLOW_NUMBER_in_number2941);
            if  (this->hasException())
            {
                goto rulenumberEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumberEx; /* Prevent compiler warnings */
    rulenumberEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end number */

/**
 * $ANTLR start word
 * SimpleBashSQL.g:800:1: word : ( WORD | '\"' WORD '\"' );
 */
SimpleBashSQLParser::word_return
SimpleBashSQLParser::word()
{
    SimpleBashSQLParser::word_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        {
            //  SimpleBashSQL.g:800:5: ( WORD | '\"' WORD '\"' )

            ANTLR_UINT32 alt59;

            alt59=2;

            switch ( this->LA(1) )
            {
            case WORD:
            	{
            		alt59=1;
            	}
                break;
            case 18:
            	{
            		alt59=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SimpleBashSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 59 );
                ex->set_state( 0 );


                goto rulewordEx;

            }

            switch (alt59)
            {
        	case 1:
        	    // SimpleBashSQL.g:800:7: WORD
        	    {
        	         this->matchToken(WORD, &FOLLOW_WORD_in_word2947);
        	        if  (this->hasException())
        	        {
        	            goto rulewordEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:800:13: '\"' WORD '\"'
        	    {
        	         this->matchToken(18, &FOLLOW_18_in_word2950);
        	        if  (this->hasException())
        	        {
        	            goto rulewordEx;
        	        }


        	         this->matchToken(WORD, &FOLLOW_WORD_in_word2952);
        	        if  (this->hasException())
        	        {
        	            goto rulewordEx;
        	        }


        	         this->matchToken(18, &FOLLOW_18_in_word2954);
        	        if  (this->hasException())
        	        {
        	            goto rulewordEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewordEx; /* Prevent compiler warnings */
    rulewordEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end word */

/**
 * $ANTLR start opts
 * SimpleBashSQL.g:801:1: opts : OPTS ;
 */
SimpleBashSQLParser::opts_return
SimpleBashSQLParser::opts()
{
    SimpleBashSQLParser::opts_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder();


 
    {
        // SimpleBashSQL.g:801:5: ( OPTS )
        // SimpleBashSQL.g:801:6: OPTS
        {
             this->matchToken(OPTS, &FOLLOW_OPTS_in_opts2959);
            if  (this->hasException())
            {
                goto ruleoptsEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoptsEx; /* Prevent compiler warnings */
    ruleoptsEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end opts */

/**
 * $ANTLR start alchar
 * SimpleBashSQL.g:802:1: alchar : ALCHAR ;
 */
void
SimpleBashSQLParser::alchar()
{
        SimpleBashSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SimpleBashSQL.g:802:7: ( ALCHAR )
        // SimpleBashSQL.g:802:8: ALCHAR
        {
             this->matchToken(ALCHAR, &FOLLOW_ALCHAR_in_alchar2964);
            if  (this->hasException())
            {
                goto rulealcharEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealcharEx; /* Prevent compiler warnings */
    rulealcharEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alchar */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */



/* End of code
 * =============================================================================
 */
