grammar SimpleBashSQL;
 
options
{
    language=Cpp;
}
 
tokens
{
    PIPE = '|';
}

@lexer::traits {
     class  SimpleBashSQLLexer;
     class  SimpleBashSQLParser;
     typedef antlr3::Traits< SimpleBashSQLLexer, SimpleBashSQLParser > SimpleBashSQLLexerTraits;
     typedef SimpleBashSQLLexerTraits SimpleBashSQLParserTraits;
}


@header
{
#ifndef MYHEAD
#define MYHEAD
 #include "SimpleBashSQLLexer.hpp" 
 #include <assert.h>
 #include <iostream>
 #include "thequery.hpp"
 using namespace std;

#endif
}

@members
{
	TheQuery *lastquery=NULL;
	char tobeprint=1;
	/*when it should work as a bashscript, a sqltool is needed*/
	string sqltool="";
/*------------------------------------------------------------------
 * Methods for Bash commands
 *------------------------------------------------------------------*/

	/** grep: parse pattern for grep as a condition for WHERE
		the columns will be linked with '||'
		fromopts: opts like -v verbose to include */
	int zugrep(std::string pattern, int fromopts, TheQuery *abfrage)
	{
		stringstream condition;
		condition << "$1";

		for(int i=2; i<=abfrage->getColumnsCount(); i++){
			condition << " || $" << i;
		}
		condition << " like '\%" << pattern << "\%'";
		if(fromopts==0)
			abfrage->addCondition(condition.str());
		else if(fromopts==1)
			abfrage->addCondition("NOT("+condition.str()+")");

	}
	
	/** parses a list from bash options like d1,2,4-6
		into a vector like 1,2,4,5,6 returns the vector */
	std::vector<int> parseListe(char*e)
	{
		std::vector<int> mylist;
		int a,b,ret;
		do{
			e++;
			ret=sscanf(e,"\%d-\%d",&a,&b);
			/* a is first field, b the last*/
			if(ret==0)/*error*/
				return mylist;
			/* all columns from a till b */
			else if(ret==2){
				for(;a<=b;a++){
				   mylist.push_back(a);
				}
			}else{
				/*only one selected*/
				mylist.push_back(a);
			}
			while((*e>='0' && *e<='9')||*e=='-')
				e++;
		}while(*e==',');

		return mylist;
	}

	/* sort */
	int optssort(char* e, TheQuery* q){
		/*until last character*/
		while(*++e!=0){
			switch (*e){
			case 'k':
				q->addOrder(parseListe(e));
				break;
			case 'u':
				q->setDistinct();
				break;
			case 'r':
				//strcat(q->orderby,"desc");
				break;
			}
		}
		return 1;
	}
	
	/*  cut */
	int optscut(char* e, TheQuery* q){
		/*until last character*/
		while(*++e!=0){
			switch (*e){
			case 'f':
				q->addSelect(parseListe(e));
				break;
			}
		}
		return 1;
	}

	/*  cut */
	int optsdatamash(char* e, TheQuery* q){
		/*until last character*/
		while(*++e!=0){
			switch (*e){
			case 'g':
				q->addGroup(parseListe(e));
				break;
			}
		}
		return 1;
	}

	/*  grep */
	int optsgrep(char* e, TheQuery* q){
		int ret = 0;
		/*until last character*/
		while(*++e!=0){
			switch (*e){
			case 'v':
				ret=1;
				break;
			case 'c':
				q->addSelect("count(*)");
				break;
			}
		}
		return ret;
	}

	/*  join */
	int optsjoin(char* e, TheQuery* q){
		/*until last character*/
		/*while(*++e!=0){
			switch (*e){
			case 'f':
				parseListe(e,q->felder);
				break;
			}
		}*/
		return 1;
	}

	/*  uniq */
	int optsuniq(char* e, TheQuery* q){
		/*until last character*/
		while(*++e!=0){
			switch (*e){
			case 'c':
				q->addSelect("count(*)");
				break;
			}
		}
		return 1;
	}

	/*  cut */
	int optswc(char* e, TheQuery* q){
		/*until last character*/
		while(*++e!=0){
			switch (*e){
			case 'l':
				break;
			}
		}
		return 1;
	}
	/*replaces each appearance of oldStr with newStr in str*/
	void replace_inline_grammar(std::string& str, const std::string& oldStr, const std::string& newStr)
	{
	  size_t pos = 0;
	  while((pos = str.find(oldStr, pos)) != std::string::npos)
	  {
	    str.replace(pos, oldStr.length(), newStr);
	    pos += newStr.length();
	  }
	}

	void printhelp()
	{
		cout << " Usage: " << endl;
		cout << " simplebashsql scriptname [sqltool] " << endl;
	}

/*------------------------------------------------------------------
 * Main
 *------------------------------------------------------------------*/
	int main(int argc, char * argv[])
 	{
		if(argc<2){
			printf("\%s: missing operand\n",argv[0]);
			printhelp();
			return 1;
		}else if(argc>2){
			/*second parameter is the sqltool*/
			sqltool = argv[2];
		}

		ANTLR_UINT8* fName = (ANTLR_UINT8*) argv[1];
		SimpleBashSQLLexer::InputStreamType input(fName, ANTLR_ENC_8BIT);
		SimpleBashSQLLexer lxr(&input); // TLexerNew is generated by ANTLR
		SimpleBashSQLParser::TokenStreamType tstream(ANTLR_SIZE_HINT, lxr.get_tokSource() );
		SimpleBashSQLParser psr(&tstream); // TParserNew is generated by ANTLR3
		psr.file();
		return 0;
	}
}
 
/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

/* BASH-Grammar */
file: newline*;

newline: ('\n')* simple_list[false] ('\n' | ';' | '&')
	| comment { cout << $comment.text; };

comment: '#' alchar*
	| '#!/bin/bash';

/*list of pipeline, connected by && ||, when Subshell print nothing*/
simple_list[bool isSub] 
@init{
lastquery=NULL;
}
	: ('!')? pipeline_cmd[isSub] (('&&' | '||') pipeline_cmd[isSub])*;

/*list of the real cmds :) 
  here at the end, the query will be printed*/
pipeline_cmd[bool isSub]: c1=command
			{ 
			/*only if the lastquery could not be translated &&
				in bashmode && should be printed */
			if(tobeprint && !lastquery && sqltool !="")
				cout << $c1.text;
			}
			(PIPE c2=command
				{ 
				if(tobeprint && !lastquery && sqltool !="")
					cout << " | " << $c2.text;
				}
			)*
			{
			/* on normal sql mode */
			if(!isSub && lastquery && sqltool =="")
				lastquery->print();
			if(!isSub && lastquery && sqltool !=""){
				cout << sqltool << " ";
				lastquery->print();
			}
			printf("\n");
			tobeprint=1;
			}
		;

command: cmd (other_redir|to_redir)* | shell_cmd (redirection)*;
subshell: '(' compound_list[true] ')';

compound_list[bool isSubshell]
	: simple_list[isSubshell] 
	( ('\n' | ';' | '&') ('\n')* simple_list[isSubshell])*; 

redirection: from_redir | other_redir ;

to_redir: ('>'|'>>') word {
	/* on normal sql mode */
	if(sqltool=="" && lastquery){
		std::cout << "WITH " << $word.text << " AS ("  << endl;
		lastquery->print();
		std::cout << " )" << endl;
		lastquery=NULL;
		tobeprint=0;
	}else if(lastquery){
	/* on bash mode use sqltool */
		std::cout << sqltool << " ";
		lastquery->print();
		std::cout << " > " << $word.text << endl;
		lastquery=NULL;
		tobeprint=0;
	}
	/*TODO hashmap with lastqueries */
};

/*returns the name when inputfilename exists, otherwise subshell*/
from_redir returns[string fname]
		: ('<'|'<<'|'<<<') word
			{
			stringstream s; s << $word.text; 
			fname=s.str();
			}
		| '<' subshell
			{
			fname="";
			}
		;

other_redir: 
                   number '>' word
                |  number '<' word
                |  number '>>' word
                |  number '<<' word
                |  '<&' number
                |  number '<&' number
                |  '>&' number
                |  number '>&' number
                |  '<&' word
                |  number '<&' word
                |  '>&' word
                |  number '>&' word
                |  '<<-' word
                |  number '<<-' word
                |  '>&' '-'
                |  number '>&' '-'
                |  '<&' '-'
                |  number '<&' '-'
                |  '&>' word
                |  number '<>' word
                |  '<>' word
                |  '>|' word
                |  number '>|' word
;

shell_cmd: 	for_command
                  |  case_command
                  |  'while' compound_list[true] 'do' compound_list[true] 'done'
                  |  'until' compound_list[true] 'do' compound_list[true] 'done'
                  |  if_command
                  |  subshell
                  |  group_command
                  |  function_def;

for_command:  for_header 
			{cout << $for_header.text << endl;}
		compound_list[true] ('done' | '}' )
			{printf("done\n");tobeprint=0;}
;
for_header:  'for' word 'in' word* ('\n'|';') ('do' | '{'); 

if_command: 'if' compound_list[true] 'then' compound_list[true] ('elif' compound_list[true])* 'else' compound_list[true] 'fi';

group_command : '{' compound_list[true] '}';

function_def :  ('function')* word '(' ')' ('\n' | ';')  group_command
		;
case_command:  'case' word ('\n' | ';') 'in' ('\n' | ';') case_clause* 'esac';

case_clause: pattern ')' compound_list[true] ';;';

/* Rules for parsing bash command to SQL */
cmd returns [TheQuery *r] 
@init{
	/* new TheQuery r,
	afterwards, set old query (lastquery) as table-reference
	set lastquery as null, so queries from subshell will won't be
	included twice */
	TheQuery* fromPipe=lastquery;
	lastquery=NULL;
	r = new TheQuery();
	stringstream s;
	char buffer[80];
	int helpsize=0, join_on, a_int=0;
}
@after{
	/* query r is the most recent query  */
	lastquery=r;
}
	:
	  'cut' 	( opts
	  			{
				s.str(""); s.clear();
				s << $opts.text; s.getline(buffer,80);
				optscut(buffer,r);
				}
			| word
				{
				s.str(""); s.clear(); s << $word.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery); 
				}
			| '- '
			)+
			{r->makeUnion(fromPipe);}

	| 'cat' 	( opts
			| word 
				{
				s.str(""); s.clear();  s << $word.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery);
				}
			| '- '
			)*
			{r->makeUnion(fromPipe);}

	| 'grep' 	( o1=opts
				{
				s.str(""); s.clear();
				s << $o1.text; s.getline(buffer,80);
				a_int=optsgrep(buffer,r);
				} 
			)*
			p=word /*pattern*/
			( o2=opts
				{
				s.str(""); s.clear();
				s << $o2.text; s.getline(buffer,80);
				optsgrep(buffer,r);
				} 
			| f=word 
				{
				s.str(""); s.clear(); s << $f.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery);
				}
			| '- '
			)*
			{
			r->makeUnion(fromPipe);
			s.str(""); s.clear(); s << $p.text;
			zugrep(s.str(),a_int,r);
			}

	| 'sort'	( opts 
				{
				s.str(""); s.clear();
				s << $opts.text; s.getline(buffer,80);
				optssort(buffer,r);
				}
			| word
				{
				s.str(""); s.clear(); s << $word.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, if filename specified*/
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery);
				}
			)*
			{r->makeUnion(fromPipe);}

	| 'head'	( opts /*TODO: should select top... */
			| '-1' | '-2'
			| word 
				{
				s.str(""); s.clear();  s << $word.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery);
				}
			| '- '
			)*
			{r->makeUnion(fromPipe);}


	| 'tail'	( opts /* like a reverse select top */
			| '-1' | '-2'
			| word 
				{
				s.str(""); s.clear();  s << $word.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery);
				}
			| '- '
			)*
			{r->makeUnion(fromPipe);}

	
	| 'join' (('-1' n1=number)
                | ('-2' n2=number)
                | OPTS
                | word
			{
			s.str(""); s.clear();
			s << $word.text; r->makeCross(s.str());
			/* helpsize to detect first field of 2nd table*/
			helpsize= helpsize==0 ? 
				r->getColumnsCount() : helpsize;
                        }
                | '- '  
			{
			r->makeCross(fromPipe);
			/* helpsize to detect first field of 2nd table*/
			helpsize= helpsize==0 ? 
				r->getColumnsCount() : helpsize;
                        }
                | from_redir
                        {/* fname!=NULL, wenn Dateiname */
			if (!$from_redir.fname.empty())
				r->makeUnion($from_redir.fname);
                        else /* sonst subshell */
                                r->makeCross(lastquery);
			/* helpsize to detect first field of 2nd table*/
			helpsize= helpsize==0 ? 
				r->getColumnsCount() : helpsize;
                        }
                )+
		{
		s.str(""); s.clear(); s << $n2.text;
		/*get relative column number*/
		join_on=stoi(s.str())+helpsize;
		s.str(""); s.clear(); 
		s<< "t1.\$" <<$n1.text << "=t2.\$" << join_on;
		r->addCondition(s.str());
		/*print the relevant columns*/
		int max=r->getColumnsCount();
		for(int i=1; i<=max;i++)
			r->addSelect("$"+std::to_string(i));
		r->deleteSelect(join_on);
		}

	| 'tee'		word /* TODO add opts, to a file */
			{
				delete r;
				r=fromPipe;
			}

	| 'uniq'	( opts
				{ s.str(""); s.clear();
				s << $opts.text; s.getline(buffer,80);
				optsuniq(buffer,r);
				}
			| word
				{ s.str(""); s.clear(); s << $word.text;
				r->makeUnion(s.str());
				}
                        | from_redir
                                {/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
                                else /* sonst subshell */
                                        r->makeUnion(lastquery);
                                }
                        | '- ' )*
                        {
			r->makeUnion(fromPipe);
			/* uniq is realized by groups, so group
			f.a. x elem select 
			begin with $1*/
			for (int i=1;i<=fromPipe->getColumnsCount(); i++)
				r->addSelect("$"+std::to_string(i));
			r->addGroup(fromPipe->getColumns());
			}

	 | 'wc -l'      
			( opts 
				{
				s.str(""); s.clear();
				s << $opts.text; s.getline(buffer,80);
				optswc(buffer,r);
				}
			| word
				{ s.str(""); s.clear(); s << $word.text;
				r->makeUnion(s.str());
				}
                        | from_redir
                                {/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
                                else /* sonst subshell */
                                        r->makeUnion(lastquery);
                                }
                        | '- ' )*
                        {
			r->addSelect("count(*)");
			r->makeUnion(fromPipe);
			}

        | 'awk' OPTS* '\'' ('\n')* 
			(awkbody[r] ('\n')*)+ '\'' (assignment|OPTS)*
                        
			/*and data?*/
			(word 
				{
				s.str(""); s.clear();  s << $word.text;
				r->makeUnion(s.str());
				}
			| from_redir
				{/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
				else /* sonst subshell */
					r->makeUnion(lastquery);
				}
			| '- '
			)*
			{
			r->makeUnion(fromPipe);
			}
	| 'datamash'	( opts
				{ s.str(""); s.clear();
				s << $opts.text; s.getline(buffer,80);
				optsdatamash(buffer,r);
				}
			| word number
				{ s.str(""); s.clear();
				/*aggregate function and the columns
				  adds them into the current select stm
				*/
				s<<$word.text<<"(\$"<<$number.text<<")";
				r->addSelect(s.str());
				}
                        | from_redir
                                {/* fname!=NULL, wenn Dateiname */
				if (!$from_redir.fname.empty())
					r->makeUnion($from_redir.fname);
                                else /* sonst subshell */
                                        r->makeUnion(lastquery);
                                }
                        | '- ' )*
                        {
			r->makeUnion(fromPipe);
			}

	/*default, cmd not implemented */
	| word* 
		{
			/*the used sqltool first*/
			if(fromPipe != NULL && sqltool!=""){
				cout << sqltool << " ";
				fromPipe->print();
			}
			else if(fromPipe!=NULL){
				fromPipe->print();
			}
			delete r;
			r=NULL;
		}
	;

assignment: word'='word;

/*now awk*/
/*the body of an awk cmd with pattern {action}*/
awkbody[TheQuery* r]
@init{
	stringstream s;
}
		: ( a1=awkpattern 
		{
		r->addCondition($a1.cond);
		}
		
		(('&&' | '||') a2=awkpattern	
		{
		r->addCondition($a2.cond);
		}
		)*
                )? 
                '{' ('\n')* (awkcmds[r] ('\n')* )+ '}'
        ;

/*translates patterns from awk to sql*/
awkpattern returns [string cond]
@init{
	stringstream s;
}
@after{
	cond=s.str();
	/*contains NR? not so in sql*/
	if(!cond.find("NR"))
		cond="true";
	/*contains NF? not so in sql*/
	if(!cond.find("NF"))
		cond="true";
	/*replaces all appearances of " by ' for sql string*/
	replace_inline_grammar(cond,"\"", "'");
	replace_inline_grammar(cond,"==", "=");
	/* x ~/ pattern / ==> x like 'pattern'  */
	replace_inline_grammar(cond,"~/", " like '");
	replace_inline_grammar(cond,"/", "'");
	/*awk regex to sql regex*/
	replace_inline_grammar(cond,".*", "\%");
	replace_inline_grammar(cond,".", "?");
}
	: awkpatternparsed
	{
		s << $awkpatternparsed.text;
	}
	;

/*here patterns will be parsed*/
awkpatternparsed
	:(w1=word|n1=number) ('!='|'<'|'>'|'=='|'<='|'>=') (w2=word|n2=number)
	| (word|number) '~/' word '/'
	;

/*the action (print, if, arith...)*/
awkcmds[TheQuery* r]
@init{
	/*keyvalue store for the variables in awk*/
	std::map<std::string, std::string> vm;
	stringstream s;
}
	:  ('print'  (awklist[vm,r])
	| awkop[vm]
	| awkif[r]
	) (';')?
	;


awkop[map<std::string,std::string> &vm]
	: word ('='|'+='|'*='|'-=') awkmath
	{
		stringstream s1,s2;
		s1<<$word.text; s2<<$awkmath.text;
		vm[s1.str()]=s2.str();
	}
	;

awkmath
	: '('? (word|number) ')'? 
	   (('*'|'+'|'-'|'/') awkmath)?
	;

awklist[map<std::string,std::string> &vm, TheQuery* r]
@init{
	stringstream s;
}
	: w1=awkexpr
	{
		s<<$w1.text;
		r->addSelect(s.str());
	}
	;

awkif[TheQuery* r]
	: 'if' '(' awkpattern ')' ('{' awkcmds[r] '}'| awkcmds[r])
	  ('else' ('{' awkpattern '}'| awkcmds[r]))
	;

awkexpr
	: word
	| alchar
	;

pattern: 
	;

/*------------------------------------------------------------------
 * LEXER RULES
 *------------------------------------------------------------------*/
/* convert each lexer token to an equal parser rule for output text
	text can only be obtaines from a parser rule, like e.g. stringstream s; s<<$number.text; */
number: NUMBER;
word: WORD| '"' WORD '"';
opts:OPTS;
alchar:ALCHAR;

/*Lexer rules */

NUMBER		: (DIGIT)+
      		;

WORD		: (LETTER|DIGIT) (LETTER|DIGIT|'-')*;

OPTS		: ('-'|'+') (LETTER|DIGIT|'-')+
		;

ALCHAR		: (LETTER|DIGIT|SONDER)+;

WHITESPACE  	: ( '\t' | ' ' | '\r' | '\u000C' | '\\' ('\n')+)+
              	{
                	 $channel = HIDDEN;
              	}
            	;

COMMENT		: '#' ~('\n')* '\n' 
		{
			$channel = HIDDEN;
		}
		;

fragment
DIGIT       	: '0'..'9';

fragment
LETTER		: (ALPHA|ESCAPED|'.'|'_'|','|'$'|'*');

fragment
ALPHA		: ('A'..'Z'|'a'..'z');

fragment
ESCAPED		: '\\'(';'|'|');

fragment
SONDER          : ('%' | '\'' | '`' | '!' );
