/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2
 *
 *     -  From the grammar source file : SimpleCalc.g
 *     -                            On : 2014-09-18 14:23:49
 *     -                 for the lexer : SimpleCalcLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SimpleCalcLexer.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;


/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



SimpleCalcLexer::~SimpleCalcLexer()
{
}

void
SimpleCalcLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SimpleCalc.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SimpleCalcLexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called SimpleCalcLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSimpleCalcLexer initialized for the lex start
 *     - Fail NULL
 */
SimpleCalcLexer::SimpleCalcLexer(StreamType* instream)
:SimpleCalcLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called SimpleCalcLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSimpleCalcLexer initialized for the lex start
 *     - Fail NULL
 */
SimpleCalcLexer::SimpleCalcLexer(StreamType* instream, RecognizerSharedStateType* state)
:SimpleCalcLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void SimpleCalcLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SimpleCalcLexer.h here so you can get a sense
     * of what goes where.
     */

}

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIV
 *
 * Looks to match the characters the constitute the token DIV
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mDIV()
{
    ANTLR_UINT32	_type;
      

    _type	    = DIV;


    // SimpleCalc.g:7:5: ( '/' )
    // SimpleCalc.g:7:7: '/'
    {
         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleDIVEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDIVEx; /* Prevent compiler warnings */
    ruleDIVEx: ;

}
// $ANTLR end DIV

//   Comes from: 8:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS
 *
 * Looks to match the characters the constitute the token MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mMINUS()
{
    ANTLR_UINT32	_type;
      

    _type	    = MINUS;


    // SimpleCalc.g:8:7: ( '-' )
    // SimpleCalc.g:8:9: '-'
    {
         this->matchc('-');
        if  (this->hasException())
        {
            goto ruleMINUSEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleMINUSEx; /* Prevent compiler warnings */
    ruleMINUSEx: ;

}
// $ANTLR end MINUS

//   Comes from: 9:6: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MULT
 *
 * Looks to match the characters the constitute the token MULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mMULT()
{
    ANTLR_UINT32	_type;
      

    _type	    = MULT;


    // SimpleCalc.g:9:6: ( '*' )
    // SimpleCalc.g:9:8: '*'
    {
         this->matchc('*');
        if  (this->hasException())
        {
            goto ruleMULTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleMULTEx; /* Prevent compiler warnings */
    ruleMULTEx: ;

}
// $ANTLR end MULT

//   Comes from: 10:6: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS
 *
 * Looks to match the characters the constitute the token PLUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mPLUS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLUS;


    // SimpleCalc.g:10:6: ( '+' )
    // SimpleCalc.g:10:8: '+'
    {
         this->matchc('+');
        if  (this->hasException())
        {
            goto rulePLUSEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLUSEx; /* Prevent compiler warnings */
    rulePLUSEx: ;

}
// $ANTLR end PLUS

//   Comes from: 65:13: ( ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NUMBER
 *
 * Looks to match the characters the constitute the token NUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mNUMBER()
{
    ANTLR_UINT32	_type;
      

    _type	    = NUMBER;


    // SimpleCalc.g:65:13: ( ( DIGIT )+ )
    // SimpleCalc.g:65:15: ( DIGIT )+
    {
        // SimpleCalc.g:65:15: ( DIGIT )+
        {
            int cnt1=0;

            for (;;)
            {
                int alt1=2;
        	switch ( this->LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt1=1;
        		}
        	    break;

        	}

        	switch (alt1)
        	{
        	    case 1:
        	        // SimpleCalc.g:
        	        {
        	            if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< SimpleCalcLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleNUMBEREx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt1 >= 1 )
        		{
        		    goto loop1;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< SimpleCalcLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleNUMBEREx;
        	}
        	cnt1++;
            }
            loop1: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNUMBEREx; /* Prevent compiler warnings */
    ruleNUMBEREx: ;

}
// $ANTLR end NUMBER

//   Comes from: 68:13: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mWHITESPACE()
{
    ANTLR_UINT32	_type;
      

    _type	    = WHITESPACE;


    // SimpleCalc.g:68:13: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
    // SimpleCalc.g:68:15: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
    {
        // SimpleCalc.g:68:15: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
        {
            int cnt2=0;

            for (;;)
            {
                int alt2=2;
        	switch ( this->LA(1) )
        	{
        	case '\t':
        	case '\n':
        	case '\f':
        	case '\r':
        	case ' ':
        		{
        			alt2=1;
        		}
        	    break;

        	}

        	switch (alt2)
        	{
        	    case 1:
        	        // SimpleCalc.g:
        	        {
        	            if ( ((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || ((this->LA(1) >= '\f') && (this->LA(1) <= '\r')) || this->LA(1) == ' ' )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< SimpleCalcLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleWHITESPACEEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt2 >= 1 )
        		{
        		    goto loop2;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< SimpleCalcLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleWHITESPACEEx;
        	}
        	cnt2++;
            }
            loop2: ;	/* Jump to here if this rule does not match */
        }

        {

                             this->get_state()->get_channel() = HIDDEN;
                          
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

//   Comes from: 76:13: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SimpleCalcLexer::mDIGIT()
{
    ANTLR_UINT32	_type;
      


    // SimpleCalc.g:76:13: ( '0' .. '9' )
    // SimpleCalc.g:
    {
        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< SimpleCalcLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleDIGITEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
SimpleCalcLexer::mTokens()
{
    {
        //  SimpleCalc.g:1:8: ( DIV | MINUS | MULT | PLUS | NUMBER | WHITESPACE )

        ANTLR_UINT32 alt3;

        alt3=6;

        switch ( this->LA(1) )
        {
        case '/':
        	{
        		alt3=1;
        	}
            break;
        case '-':
        	{
        		alt3=2;
        	}
            break;
        case '*':
        	{
        		alt3=3;
        	}
            break;
        case '+':
        	{
        		alt3=4;
        	}
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        	{
        		alt3=5;
        	}
            break;
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case ' ':
        	{
        		alt3=6;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SimpleCalcLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 3 );
            ex->set_state( 0 );


            goto ruleTokensEx;

        }

        switch (alt3)
        {
    	case 1:
    	    // SimpleCalc.g:1:10: DIV
    	    {
    	        /* 1:10: DIV */
    	        mDIV();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // SimpleCalc.g:1:14: MINUS
    	    {
    	        /* 1:14: MINUS */
    	        mMINUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // SimpleCalc.g:1:20: MULT
    	    {
    	        /* 1:20: MULT */
    	        mMULT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // SimpleCalc.g:1:25: PLUS
    	    {
    	        /* 1:25: PLUS */
    	        mPLUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // SimpleCalc.g:1:30: NUMBER
    	    {
    	        /* 1:30: NUMBER */
    	        mNUMBER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // SimpleCalc.g:1:37: WHITESPACE
    	    {
    	        /* 1:37: WHITESPACE */
    	        mWHITESPACE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */



/* End of code
 * =============================================================================
 */
