grammar SimpleCalc;
 
options
{
    language=C;
}
 
tokens
{
    PLUS    = '+' ;
    MINUS   = '-' ;
    MULT    = '*' ;
    DIV = '/' ;
    PIPE = '|';
    REDIR ='>';
}
 
@header
{
#ifndef MYHEAD
#define MYHEAD
 
 #include assert.h
 #include "SimpleCalcLexer.h"
 #define MAXFIELDS 5

 typedef struct myquery{
	char 'select'[80], from[80], where[800], groupby[20], orderby[20], as[20];
	int felder[MAXFIELDS];
	
	/* findet join statt? felder 1, felder2, tabelle1, tabelle2 */
	char join, f1[3],f2[3],t2[20];
	/* findet union statt?  */
	char sqlunion;
	struct myquery *src, *src2;
  } query;


#endif
}

@members
{
	query *lastquery=NULL;
	
/*------------------------------------------------------------------
 * Methoden fuer die SQL-Abfrage
 *------------------------------------------------------------------*/
	/*str_split fuer die lookup der Spaltenbezeichner*/
	char** str_split(char* a_str, const char a_delim)
	{
	    char** result    = 0;
	    size_t count     = 0;
	    char* tmp        = a_str;
	    char* last_comma = 0;
	    char delim[2];
	    delim[0] = a_delim;
	    delim[1] = 0;

	    /* Count how many elements will be extracted. */
	    while (*tmp)
	    {
		if (a_delim == *tmp)
		{
		    count++;
		    last_comma = tmp;
		}
		tmp++;
	    }

	    /* Add space for trailing token. */
	    count += last_comma  (a_str + strlen(a_str) - 1);

	    /* Add space for terminating null string so caller
	       knows where the list of returned strings ends. */
	    count++;

	    result = malloc(sizeof(char*) * count);

	    if (result)
	    {
		size_t idx  = 0;
		char* token = strtok(a_str, delim);

		while (token)
		{
		    assert(idx  count);
		    *(result + idx++) = strdup(token);
		    token = strtok(0, delim);
		}
		assert(idx == count - 1);
		*(result + idx) = 0;
	    }

	    return result;
	}
		
	/*nimmt die erste Zeile einer Datei als Spaltenbezeichner*/
	char** lookup(char* filename, char delimit)
	{
		FILE *f;
		char * line = NULL;
		size_t len = 0;
		ssize_t read;
		char** ptr;	
		f=fopen(filename,"r");
		if(!f)
			return NULL;
		if( read = getline(&line, &len, f) ==-1)
			return NULL;
		fclose(f);
		return str_split(line,delimit);
	}

	/** setzt die Abfrage auf Standardwerte */
	int reset(query* abfrage){
		int i;
		if(abfrage-src!=NULL)
			for(i=0; iMAXFIELDS;i++)
				abfrage-felder[i]=abfrage-src-felder[i];
		else
			for(i=0; iMAXFIELDS;i++)
				abfrage-felder[i]=i+1;

		strcpy(abfrage-as,"input");
		strcpy(abfrage-f1,"1");
		strcpy(abfrage-f1,"1");
		abfrage-join=0;
	}

	/** gibt die Abfrage in SQL aus */
	int ausgeben(query* e)
	{
		int i=0; char buffer[3];
		if (e==NULL)
			return -1;

		/* 'select' relevanten felder  */
		while(e-felder[i+1]!=-1 && i+1MAXFIELDS){
			sprintf(buffer,"$\%d,",e-felder[i++]);
			strcat(e-'select',buffer);
		} 
		sprintf(buffer,"$\%d",e-felder[i]);
		strcat(e-'select',buffer);

		printf("SELECT \%s FROM \%s",
			e-'select', e-from);
		
		/* bei Join und union: Quelle1 abfragen */
		if(e-join && e-src2!=NULL){
			printf("(\n\t");
			ausgeben(e-src2);
			printf(") AS \%s",e-src2-as);
		}
		/*findet ein join oder eine union statt?*/
		if(e-join)
			printf(" join \%s",e-t2);
		if(e-sqlunion)
			printf(" union ");
		/* rekursiv alle Unterabfragen */
		if(e-src!=NULL){
			printf("(\n\t");
			ausgeben(e-src);
			printf(") AS \%s",e-src-as);
		}

		/*nur bei join */
		if(e-join)
			printf(" on 1.$\%s = 2.$\%s",e-f1,e-f2);

		if(strlen(e-where)!=0)
			printf(" WHERE \%s",
				e- where);
		if(strlen(e-groupby)!=0)
			printf(" GROUP BY \%s",
				e-groupby);
		if(strlen(e-orderby)!=0)
			printf(" ORDER BY \%s",
				e- where, e-groupby, e-orderby);
		printf("\n");
		return 1;
	}
 
/*------------------------------------------------------------------
 * Methoden zu den Bash-Kommandos
 *------------------------------------------------------------------*/
	/* vereint zwei Tabellen */
	query *makeunion(char* eingabe, query* q)
	{
		query* neu;
		/* erstes Argument? = gleich rein */
		if(strlen(q-from)==0 && q-src==NULL){
			strcpy(q-from,eingabe);
			return q;
		}
		/* sonst: mache union*/
		neu=(query*)malloc(sizeof(query));
		neu-src=q;
		reset(neu);
		neu-sqlunion=1;
		strcpy(neu-from,eingabe);
		return neu;
	}

	/** zu grep: parse pattern fuer grep*/
	int zugrep(char* pattern, query* abfrage )
	{
		int i=0; char buffer[3];
		strcat(abfrage- where, "(");
		while(abfrage-felder[i]!=-1 && iMAXFIELDS){
			 sprintf(buffer,"$\%d",abfrage-felder[i++]);
			 strcat(abfrage-where,buffer);
			 strcat(abfrage-where," like \'\%");
			 strcat(abfrage-where,pattern);
			 strcat(abfrage-where,"\%\' or ");
		}
		strcat(abfrage- where, "false)");
	}
	
	/** parst eine in Optionen angegebene Liste wie d1,2,4-6
		in ein Feld zu 1,2,4,5,6 */
	int parseListe(char*e, int* feld)
	{
		int crtf=0;
		int a,b,ret;
		do{
			e++;
			ret=sscanf(e,"\%d-\%d",&a,&b);
			/* felder beginnen bei 0*/
			a--; b--;
			if(ret==0)/*error*/
				return -1;
			/* von - bis  */
			else if(ret==2){
				for(;a=b;a++)
				   feld[crtf++]=feld[a];
			}/*einzelne Auswahl */else{
				feld[crtf++]=feld[a];
			}
			while((*e='0' && *e='9')||*e=='-')
				e++;
		}while(*e==',');
		feld[crtf]=-1;
		return 1;
	}

	/* zu sort */
	int optssort(char* e, query* q){
		int i;
		char buffer[3];
		int* feld=(int*) malloc(MAXFIELDS*sizeof(int));
		for (i=0;iMAXFIELDS;i++)	
			feld[i]=q-felder[i];
		/*bis Ende erreicht*/
		while(*++e!=0){
			switch (*e){
			case 'k':
				i=0;
				parseListe(e,feld);
				while(feld[i+1]!=-1 && i+1MAXFIELDS){
					sprintf(buffer,"$\%d,",feld[i++]);
					strcat(q-groupby,buffer);
				}
				sprintf(buffer,"$\%d",feld[i]);
				strcat(q-groupby,buffer);
				break;
			}
		}
		return 1;
	}
	
	/* zu cut */
	int optscut(char* e, query* q){
		/*bis Ende erreicht*/
		while(*++e!=0){
			switch (*e){
			case 'f':
				parseListe(e,q-felder);
				break;
			}
		}
		return 1;
	}

	/* zu grep */
	int optsgrep(char* e, query* q){
		/*bis Ende erreicht*/
		while(*++e!=0){
			switch (*e){
			case 'v':
				strcat(q-where, "NOT ");
				break;
			case 'c':
				strcpy(q-'select', "count(*)");
				break;
			}
		}
		return 1;
	}

	/* zu join */
	int optsjoin(char* e, query* q){
		/*bis Ende erreicht*/
		while(*++e!=0){
			switch (*e){
			case 'f':
				parseListe(e,q-felder);
				break;
			}
		}
		return 1;
	}
/*------------------------------------------------------------------
 * Main
 *------------------------------------------------------------------*/
	int main(int argc, char * argv[])
 	{
		pANTLR3_INPUT_STREAM           input;
		pSimpleCalcLexer               lex;
		pANTLR3_COMMON_TOKEN_STREAM    tokens;
		pSimpleCalcParser              parser;
		
		if(argc!=2){
			printf("\%s: fehlender Operand\n",argv[0]);
			return 1;
		}
		
		input = antlr3FileStreamNew ((pANTLR3_UINT8)argv[1], ANTLR3_ENC_8BIT);
		lex    = SimpleCalcLexerNew                (input);
		tokens = antlr3CommonTokenStreamSourceNew  (ANTLR3_SIZE_HINT, TOKENSOURCE(lex));
		parser = SimpleCalcParserNew               (tokens);

		parser  -file(parser);

		// Must manually clean up
		//
		parser -free(parser);
		tokens -free(tokens);
		lex    -free(lex);
		input  -close(input);

		return 0;
	}
 
}
 
/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/
file: line*;

assignment_word: word '=' word;

redirection:  	'>' WORD
                |  '<' WORD
                |  NUMBER '>' WORD
                |  NUMBER '<' WORD
                |  '>>' WORD
                |  NUMBER '>>' WORD
                |  '<<' WORD
                |  NUMBER '<<' WORD
                |  '<&' NUMBER
                |  NUMBER '<&' NUMBER
                |  '>&' NUMBER
                |  NUMBER '>&' NUMBER
                |  '<&' WORD
                |  NUMBER '<&' WORD
                |  '>&' WORD
                |  NUMBER '>&' WORD
                |  '<<-' WORD
                |  NUMBER '<<-' WORD
                |  '>&' '-'
                |  NUMBER '>&' '-'
                |  '<&' '-'
                |  NUMBER '<&' '-'
                |  '&>' WORD
                |  NUMBER '<>' WORD
                |  '<>' WORD
                |  '>|' WORD
                |  NUMBER '>|' WORD
;

simple_command_element: WORD
                          |  assignment_word
                          |  redirection;

redirection_list : redirection
                    |  redirection_list redirection;

simple_command :  simple_command_element
                   |  simple_command simple_command_element;

command : simple_command
            |  shell_command
            |  shell_command redirection_list;

shell_command :  for_command
                  |  case_command
                  |  'while' compound_list 'do' compound_list 'done'
                  |  'until' compound_list 'do' compound_list 'done'
                  |  select_command
                  |  if_command
                  |  subshell
                  |  group_command
                  |  function_def
		;

for_command :  'for' WORD newline_list 'do' compound_list 'done'
            |  'for' WORD newline_list '{' compound_list '}'
            |  'for' WORD ';' newline_list 'do' compound_list 'done'
            |  'for' WORD ';' newline_list '{' compound_list '}'
            |  'for' WORD newline_list 'in' word_list list_terminator
                   newline_list 'do' compound_list 'done'
            |  'for' WORD newline_list 'in' word_list list_terminator
                   newline_list '{' compound_list '}'
	;

select_command :  'select' WORD newline_list 'do' list 'done'
                   |  'select' WORD newline_list '{' list '}'
                   |  'select' WORD ';' newline_list 'do' list 'done'
                   |  'select' WORD ';' newline_list '{' list '}'
                   |  'select' WORD newline_list 'in' word_list
                           list_terminator newline_list 'do' list 'done'
                   |  'select' WORD newline_list 'in' word_list
                           list_terminator newline_list '{' list '}'
		;
case_command :  'case' WORD newline_list 'in' newline_list 'esac'
                 |  'case' WORD newline_list 'in' case_clause_sequence
                         newline_list 'esac'
                 |  'case' WORD newline_list 'in' case_clause 'esac'
;

function_def :  WORD '(' ')' newline_list group_command
                 |  'function' WORD '(' ')' newline_list group_command
                 |  'function' WORD newline_list group_command
	;
subshell :  '(' compound_list ')';

if_command : 'if' compound_list 'then' compound_list (elif_clause 'fi')+
;

group_command :  '{' list '}';

elif_clause : 'elif' compound_list 'then' compound_list (elif_clause)* 'else compound_list;

case_clause : case_clause_sequence pattern_list ;

pattern_list :  newline_list '(' pattern ')' compound_list
                 |  newline_list '(' pattern ')' newline_list
;
pattern :  WORD
            |  pattern '|' WORD	;


list :   newline_list list0;

compound_list :  list;

list_terminator : '\n'
                   |  ';';

newline_list :
                  |  newline_list '\n';

simple_list :  simple_list1
                |  simple_list1 '&'
                |  simple_list1 ';'
		;

simple_list1 :  simple_list1 '&&' newline_list simple_list1
                 |  simple_list1 '||' newline_list simple_list1
                 |  simple_list1 '&' simple_list1
                 |  simple_list1 ';' simple_list1
                 |  pipeline_command
		;
pipeline_command : pipeline
                    |  '!' pipeline
                    |  timespec pipeline
                    |  timespec '!' pipeline
                    |  '!' timespec pipeline
		;
pipeline :
          pipeline '|' newline_list pipeline
	;

time_opt : '-p';

timespec :  time
             |  time time_opt;


line: cmd (PIPE  cmd)* (REDIR WORD)? ('\n'|';')  {
		ausgeben(lastquery);lastquery=NULL;
	}
	;

cmd returns [query *r]
@init{
	/* neue Query r, vorherige Abfrage als FROM-Tabelle
		NULL, wenn erstes Kommando */
	char tmp=0; //zaehlt args
	r=(query*) malloc(sizeof(query));
	r-src=lastquery;
	reset(r);
}
@after{
	lastquery=r;
}
	:
	  'cut' 	( OPTS { optscut($OPTS.text-chars,r);}
			| WORD { r=makeunion($WORD.text-chars,r);}
			)+
	| 'cat' 	( WORD { r=makeunion($WORD.text-chars,r); } )*
	| 'grep' 	( o1=OPTS { optsgrep($o1.text-chars,r); } )*
			p=WORD	  { zugrep($p.text-chars,r); }
			( o2=OPTS { optsgrep($o2.text-chars,r);   } 
			| f=WORD  { r=makeunion($f.text-chars,r); }
			)*
	| 'sort'	( OPTS { optssort($OPTS.text-chars,r);}
			| WORD { r=makeunion($WORD.text-chars,r);}
			)*
	| 'join' (('-1' n1=NUMBER	{strcpy(r-f1,$n1.text-chars);} )
		| ('-2' n2=NUMBER	{strcpy(r-f2,$n2.text-chars);} )
		| OPTS
		| WORD	{	if(tmp++==0) /* erstes Argument*/
					strcpy(r-from,$WORD.text-chars);
					else
					strcpy(r-t2,$WORD.text-chars);
				}
		| '- '	{	if (tmp++==0){ /*erstes Arg? = swap*/
					r-src2=r-src; r-src=NULL;
				}
		}
		)+ {r-join=1;}
	| 'wc -l'	{strcpy(r-'select',"count(*)");}
	| words {
			ausgeben(lastquery-src); lastquery=NULL;
			printf("\%s \n",$words.text-chars);
	}
	;

words: WORD+ (PIPE WORD+)?;

fromsub: '<' '(' CMD ')'
	;

 
 
/*------------------------------------------------------------------
 * LEXER RULES
 *------------------------------------------------------------------*/
 
NUMBER		: (DIGIT)+
      		;

WORD		: (LETTER)+
		;

OPTS		: ('-'|'+') (LETTER|DIGIT|'-')+
		;

WHITESPACE  	: ( '\t' | ' ' | '\r' | '\u000C' | '\\' '\n' )+
              	{
                	 $channel = HIDDEN;
              	}
            	;
 
fragment
DIGIT       	: '0'..'9'
            	;

fragment
LETTER		: ('A'..'Z'|'a'..'z'|'.'|'_'|','|'\|')
		;

