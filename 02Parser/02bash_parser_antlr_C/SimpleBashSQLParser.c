/** \file
 *  This C source file was generated by $ANTLR version 3.5.2
 *
 *     -  From the grammar source file : SimpleBashSQL.g
 *     -                            On : 2014-12-24 00:18:41
 *     -                for the parser : SimpleBashSQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

#ifndef MYHEAD
#define MYHEAD
 
 #include <assert.h>
 #include "SimpleBashSQLLexer.h"
 #define MAXFIELDS 5
 #define DELIMIT ','

 typedef struct myquery{
	char select[10], from[30],
	where[200], groupby[5],
	orderby[5], as[20];
	/*numerische Repraesentation der Felder*/
	char felder[MAXFIELDS], groups[MAXFIELDS], orders[MAXFIELDS];
	/*sprechende Namen */
	char *fname[MAXFIELDS];
	/* findet join statt? felder 1, felder2, tabelle1, tabelle2 */
	char join, f1,f2,t2[20];
	/* findet union statt?  */
	char sqlunion,sort,group,nrfields;
	struct myquery *src, *src2;
  } query;


#endif

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SimpleBashSQLParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSimpleBashSQLParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSimpleBashSQLParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSimpleBashSQLParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSimpleBashSQLParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   SimpleBashSQLParserTokenNames[63+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALCHAR",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "OPTS",
        (pANTLR3_UINT8) "PIPE",
        (pANTLR3_UINT8) "SONDER",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "WORD",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'\"'",
        (pANTLR3_UINT8) "'#'",
        (pANTLR3_UINT8) "'&&'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'&>'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'- '",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'-1'",
        (pANTLR3_UINT8) "'-2'",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "';;'",
        (pANTLR3_UINT8) "'<&'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<<'",
        (pANTLR3_UINT8) "'<<-'",
        (pANTLR3_UINT8) "'<<<'",
        (pANTLR3_UINT8) "'<>'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'>&'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>>'",
        (pANTLR3_UINT8) "'>|'",
        (pANTLR3_UINT8) "'\\''",
        (pANTLR3_UINT8) "'\\n'",
        (pANTLR3_UINT8) "'awk'",
        (pANTLR3_UINT8) "'case'",
        (pANTLR3_UINT8) "'cat'",
        (pANTLR3_UINT8) "'cut'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'done'",
        (pANTLR3_UINT8) "'elif'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'esac'",
        (pANTLR3_UINT8) "'fi'",
        (pANTLR3_UINT8) "'for'",
        (pANTLR3_UINT8) "'function'",
        (pANTLR3_UINT8) "'grep'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'in'",
        (pANTLR3_UINT8) "'join'",
        (pANTLR3_UINT8) "'print'",
        (pANTLR3_UINT8) "'sort'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'uniq'",
        (pANTLR3_UINT8) "'until'",
        (pANTLR3_UINT8) "'wc -l'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	file    (pSimpleBashSQLParser ctx);
static 
 void
	newline    (pSimpleBashSQLParser ctx);
static 
 SimpleBashSQLParser_comment_return
	comment    (pSimpleBashSQLParser ctx);
static 
 void
	simple_list    (pSimpleBashSQLParser ctx);
static 
 void
	pipeline_cmd    (pSimpleBashSQLParser ctx);
static 
 SimpleBashSQLParser_command_return
	command    (pSimpleBashSQLParser ctx);
static 
 void
	subshell    (pSimpleBashSQLParser ctx);
static 
 void
	compound_list    (pSimpleBashSQLParser ctx);
static 
 void
	redirection    (pSimpleBashSQLParser ctx);
static 
 void
	to_redir    (pSimpleBashSQLParser ctx);
static 
 char*
	from_redir    (pSimpleBashSQLParser ctx);
static 
 void
	other_redir    (pSimpleBashSQLParser ctx);
static 
 void
	shell_cmd    (pSimpleBashSQLParser ctx);
static 
 void
	for_command    (pSimpleBashSQLParser ctx);
static 
 SimpleBashSQLParser_for_header_return
	for_header    (pSimpleBashSQLParser ctx);
static 
 void
	if_command    (pSimpleBashSQLParser ctx);
static 
 void
	group_command    (pSimpleBashSQLParser ctx);
static 
 void
	function_def    (pSimpleBashSQLParser ctx);
static 
 void
	case_command    (pSimpleBashSQLParser ctx);
static 
 void
	case_clause    (pSimpleBashSQLParser ctx);
static 
 query *
	cmd    (pSimpleBashSQLParser ctx);
static 
 void
	words    (pSimpleBashSQLParser ctx);
static 
 void
	assignment    (pSimpleBashSQLParser ctx);
static 
 void
	word    (pSimpleBashSQLParser ctx);
static 
 void
	awkbody    (pSimpleBashSQLParser ctx, query* r);
static 
 SimpleBashSQLParser_pattern_return
	pattern    (pSimpleBashSQLParser ctx);
static void	SimpleBashSQLParserFree(pSimpleBashSQLParser ctx);
static void     SimpleBashSQLParserReset (pSimpleBashSQLParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SimpleBashSQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SimpleBashSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSimpleBashSQLParser
SimpleBashSQLParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return SimpleBashSQLParserNewSSD(instream, NULL);
}

/** \brief Create a new SimpleBashSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSimpleBashSQLParser
SimpleBashSQLParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSimpleBashSQLParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pSimpleBashSQLParser) ANTLR3_CALLOC(1, sizeof(SimpleBashSQLParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SimpleBashSQLParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our SimpleBashSQLParser interface
     */
    ctx->file	= file;
    ctx->newline	= newline;
    ctx->comment	= comment;
    ctx->simple_list	= simple_list;
    ctx->pipeline_cmd	= pipeline_cmd;
    ctx->command	= command;
    ctx->subshell	= subshell;
    ctx->compound_list	= compound_list;
    ctx->redirection	= redirection;
    ctx->to_redir	= to_redir;
    ctx->from_redir	= from_redir;
    ctx->other_redir	= other_redir;
    ctx->shell_cmd	= shell_cmd;
    ctx->for_command	= for_command;
    ctx->for_header	= for_header;
    ctx->if_command	= if_command;
    ctx->group_command	= group_command;
    ctx->function_def	= function_def;
    ctx->case_command	= case_command;
    ctx->case_clause	= case_clause;
    ctx->cmd	= cmd;
    ctx->words	= words;
    ctx->assignment	= assignment;
    ctx->word	= word;
    ctx->awkbody	= awkbody;
    ctx->pattern	= pattern;
    ctx->free			= SimpleBashSQLParserFree;
    ctx->reset			= SimpleBashSQLParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = SimpleBashSQLParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
SimpleBashSQLParserReset (pSimpleBashSQLParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 SimpleBashSQLParserFree(pSimpleBashSQLParser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return SimpleBashSQLParserTokenNames;
}


    	query *lastquery=NULL;
    	char tobeprint=1;
    /*------------------------------------------------------------------
     * Methoden fuer die SQL-Abfrage
     *------------------------------------------------------------------*/
    	/*str_split fuer die lookup der Spaltenbezeichner*/
    	char** str_split(char* a_str, const char a_delim)
    	{
    	    char** result    = 0;
    	    size_t count     = 0;
    	    char* tmp        = a_str;
    	    char* last_comma = 0;
    	    char delim[2];
    	    delim[0] = a_delim;
    	    delim[1] = 0;

    	    /* Count how many elements will be extracted. */
    	    while (*tmp)
    	    {
    		if (a_delim == *tmp)
    		{
    		    count++;
    		    last_comma = tmp;
    		}
    		tmp++;
    	    }

    	    /* Add space for trailing token. */
    	    count += last_comma < (a_str + strlen(a_str) - 1);

    	    /* Add space for terminating null string so caller
    	       knows where the list of returned strings ends. */
    	    count++;

    	    result = malloc(sizeof(char*) * count);

    	    if (result)
    	    {
    		size_t idx  = 0;
    		char* token = strtok(a_str, delim);

    		while (token)
    		{
    		    assert(idx < count);
    		    *(result + idx++) = strdup(token);
    		    token = strtok(0, delim);
    		}
    		assert(idx == count - 1);
    		*(result + idx) = 0;
    	    }

    	    return result;
    	}
    		
    	/*nimmt die erste Zeile einer Datei als Spaltenbezeichner
    	  gibt Feld mit Strings der Namen zurueck*/
    	int lookup(char* filename, char delimit,query *q)
    	{
    		FILE *f;
    		char * line = NULL;
    		size_t len = 0;
    		ssize_t read;
    		char **ptr, **forfree;
    		/* beginne mit den neuen Feldern */
    		char i=q->nrfields;
    		
    		f=fopen(filename,"r");
    		if(!f)
    			return -1;
    		if( read = getline(&line, &len, f) == -1 )
    			return -1;
    		fclose(f);

    		ptr=str_split(line,delimit);
    		forfree=ptr;
    		while(*ptr && i<MAXFIELDS)
    			q->fname[i++]=*ptr++;
    		
    		q->nrfields=i;
    		free(forfree);
    		return 1;
    	}

    	/** setzt die Abfrage auf Standardwerte */
    	int reset(query* abfrage){
    		int i;
    		if(!abfrage)
    			return -1;

    		if(abfrage->src!=NULL){
    			/*wenn Felder durch SRC festgelegt sind*/
    			for(i=0; i<MAXFIELDS;i++){
    				abfrage->felder[i]=abfrage->src->felder[i];
    				abfrage->orders[i]=abfrage->src->felder[i];
    				abfrage->groups[i]=abfrage->src->felder[i];
    				if(abfrage->src->felder[i]>=0)
    					abfrage->fname[i]=
    						abfrage->src->fname[abfrage->src->felder[i]];
    			}
    			abfrage->nrfields=abfrage->src->nrfields;
    		}else{
    			/*sonst*/
    			abfrage->nrfields=0;
    			for(i=0; i<MAXFIELDS;i++){
    				abfrage->felder[i]=i;
    				abfrage->orders[i]=i;
    				abfrage->groups[i]=i;
    				abfrage->fname[i]=(char*)malloc(4*sizeof(char));
    				sprintf(abfrage->fname[i],"$%d",i);
    			}
    		}
    		strcpy(abfrage->select,"");
    		strcpy(abfrage->from,"");
    		strcpy(abfrage->where,"");
    		strcpy(abfrage->groupby,"");
    		strcpy(abfrage->orderby,"");
    		strcpy(abfrage->as,"");
    		abfrage->join=0;
    		abfrage->f1=1;
    		abfrage->f2=1;
    		abfrage->sqlunion=0;
    		abfrage->sort=0;
    		abfrage->group=0;
    	}
    	
    	/*gibt den Speicher wieder frei*/
    	int deletequeries(query* q)
    	{
    		if(q->src)
    			deletequeries(q->src);
    		if(q->src2)
    			deletequeries(q->src);
    		free(q);
    	}

    	/** gibt die Abfrage in SQL aus */
    	int ausgeben(query* e)
    	{
    		int i=0;
    		if (e==NULL)
    			return -1;

    		if(strlen(e->as))
    			printf("WITH %s AS (",e->as);

    		/*##### SELECT #####*/
    		printf("SELECT %s",e->select);
    		/* select relevanten felder, wenn kein * in select */
    		if(!strchr(e->select,'*')){
    			while(e->felder[i+1]!=-1 && i+1<MAXFIELDS)
    				printf("%s,",e->fname[e->felder[i++]]);
    			printf("%s ",e->fname[e->felder[i]]);
    		}
    		
    		/*##### FROM #####*/
    		printf("FROM %s ",e->from);
    		/* bei Join und union: Quelle2 abfragen */
    		if(e->src2!=NULL){
    			printf("(\n\t");
    			ausgeben(e->src2);
    			printf(") ");
    		}
    		/*findet ein join oder eine union statt?*/
    		if(e->join)
    			printf("AS a JOIN %s ",e->t2);
    		if(e->sqlunion)
    			printf("UNION ");
    		
    		/* rekursiv alle Unterabfragen */
    		if(e->src!=NULL){
    			printf("(\n\t");
    			ausgeben(e->src);
    			printf(") ");
    		}
    		printf("AS b");
    		
    		/*nur bei join, Joinbedingung*/
    		if(e->join)
    			printf(" on a.$%d = b.$%d",e->f1,e->f2);

    		/*##### REST, bei Bedarf #####*/
    		if(strlen(e->where)!=0)
    			printf(" WHERE %s",
    				e-> where);
    		
    		if(e->group){
    			i=0;
    			printf(" GROUP BY %s",e->groupby);
    			while(e->groups[i+1]!=-1 && i+1<MAXFIELDS)
    				printf("$%d,",e->groups[i++]);
    			printf("$%d ",e->groups[i]);
    		}

    		if(e->sort){
    			i=0;
    			printf(" ORDER BY ");
    			while(e->orders[i+1]!=-1 && i+1<MAXFIELDS)
    				printf("$%d,",e->orders[i++]);
    			printf("$%d %s",e->orders[i],e->orderby);
    		}
    		
    		if(strlen(e->as))
    			printf(")");
    		
    		printf("\n");
    		
    		return 1;
    	}
     
    /*------------------------------------------------------------------
     * Methoden zu den Bash-Kommandos
     *------------------------------------------------------------------*/
    	/* vereint zwei Tabellen */
    	query *makeunion(char* eingabe, query* q)
    	{
    		query* neu;
    		/* erstes Argument? => gleich rein */
    		if(strlen(q->from)==0 && q->src==NULL){
    			strcpy(q->from,eingabe);
    			lookup(eingabe,DELIMIT,q);
    			return q;
    		}
    		/* sonst: mache union*/
    		neu=(query*)malloc(sizeof(query));
    		neu->src=q;
    		reset(neu);
    		neu->sqlunion=1;
    		strcpy(neu->from,eingabe);
    		return neu;
    	}
    	/* vereint zwei Tabellen, SQL-Anfrage als Eingabe */
    	query *makeunion_query(query* eingabe, query* q)
    	{
    		query* neu;
    		/* erstes Argument? => gleich rein */
    		if(strlen(q->from)==0 && q->src==NULL){
    			q->src=eingabe;
    			return q;
    		}
    		/* sonst: mache union*/
    		neu=(query*)malloc(sizeof(query));
    		neu->src=q;
    		reset(neu);
    		neu->sqlunion=1;
    		neu->src2=eingabe;
    		return neu;
    	}

    	/** zu grep: parse pattern fuer grep*/
    	int zugrep(char* pattern, query* abfrage )
    	{
    		int i=0; char buffer[3];
    		strcat(abfrage-> where, "(");
    		while(abfrage->felder[i]!=-1 && i<MAXFIELDS){
    			 sprintf(buffer,"$%d",abfrage->felder[i++]);
    			 strcat(abfrage->where,buffer);
    			 strcat(abfrage->where," like \'%");
    			 strcat(abfrage->where,pattern);
    			 strcat(abfrage->where,"%\' or ");
    		}
    		strcat(abfrage-> where, "false)");
    	}
    	
    	/** parst eine in Optionen angegebene Liste wie d1,2,4-6
    		in ein Feld zu 1,2,4,5,6 */
    	int parseListe(char*e, char* feld)
    	{
    		int crtf=0;
    		int a,b,ret;
    		do{
    			e++;
    			ret=sscanf(e,"%d-%d",&a,&b);
    			/* felder beginnen bei 0*/
    			a--; b--;
    			if(ret==0)/*error*/
    				return -1;
    			/* von - bis  */
    			else if(ret==2){
    				for(;a<=b;a++)
    				   feld[crtf++]=feld[a];
    			}/*einzelne Auswahl */else{
    				feld[crtf++]=feld[a];
    			}
    			while((*e>='0' && *e<='9')||*e=='-')
    				e++;
    		}while(*e==',');
    		feld[crtf]=-1;
    		return 1;
    	}

    	/* zu sort */
    	int optssort(char* e, query* q){
    		/*bis Ende erreicht*/
    		while(*++e!=0){
    			switch (*e){
    			case 'k':
    				parseListe(e,q->orders);
    				break;
    			case 'u':
    				strcat(q->select,"distinct");
    				break;
    			case 'r':
    				strcat(q->orderby,"desc");
    				break;
    			}
    		}
    		return 1;
    	}
    	
    	/* zu cut */
    	int optscut(char* e, query* q){
    		/*bis Ende erreicht*/
    		while(*++e!=0){
    			switch (*e){
    			case 'f':
    				parseListe(e,q->felder);
    				break;
    			}
    		}
    		return 1;
    	}

    	/* zu grep */
    	int optsgrep(char* e, query* q){
    		/*bis Ende erreicht*/
    		while(*++e!=0){
    			switch (*e){
    			case 'v':
    				strcat(q->where, "NOT ");
    				break;
    			case 'c':
    				strcpy(q->select, "count(*)");
    				break;
    			}
    		}
    		return 1;
    	}

    	/* zu join */
    	int optsjoin(char* e, query* q){
    		/*bis Ende erreicht*/
    		while(*++e!=0){
    			switch (*e){
    			case 'f':
    				parseListe(e,q->felder);
    				break;
    			}
    		}
    		return 1;
    	}

    	/* zu uniq */
    	int optsuniq(char* e, query* q){
    		/*bis Ende erreicht*/
    		while(*++e!=0){
    			switch (*e){
    			case 'c':
    				strcat(q->select,"count(*)");
    				break;
    			}
    		}
    		return 1;
    	}

    	/* zu cut */
    	int optswc(char* e, query* q){
    		/*bis Ende erreicht*/
    		while(*++e!=0){
    			switch (*e){
    			case 'l':
    				break;
    			}
    		}
    		return 1;
    	}

    /*------------------------------------------------------------------
     * Main
     *------------------------------------------------------------------*/
    	int main(int argc, char * argv[])
     	{
    		pANTLR3_INPUT_STREAM           input;
    		pSimpleBashSQLLexer               lex;
    		pANTLR3_COMMON_TOKEN_STREAM    tokens;
    		pSimpleBashSQLParser              parser;
    		
    		if(argc!=2){
    			printf("%s: fehlender Operand\n",argv[0]);
    			return 1;
    		}
    		
    		input = antlr3FileStreamNew ((pANTLR3_UINT8)argv[1], ANTLR3_ENC_8BIT);
    		lex    = SimpleBashSQLLexerNew                (input);
    		tokens = antlr3CommonTokenStreamSourceNew  (ANTLR3_SIZE_HINT, TOKENSOURCE(lex));
    		parser = SimpleBashSQLParserNew               (tokens);

    		parser  ->file(parser);

    		// Must manually clean up
    		//
    		parser ->free(parser);
    		tokens ->free(tokens);
    		lex    ->free(lex);
    		input  ->close(input);

    		return 0;
    	}
     


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newline_in_file68  */
static	ANTLR3_BITWORD FOLLOW_newline_in_file68_bits[]	= { ANTLR3_UINT64_LIT(0xF5781F000008B012), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_newline_in_file68	= { FOLLOW_newline_in_file68_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_newline77  */
static	ANTLR3_BITWORD FOLLOW_40_in_newline77_bits[]	= { ANTLR3_UINT64_LIT(0xF5781F0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_newline77	= { FOLLOW_40_in_newline77_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_list_in_newline81  */
static	ANTLR3_BITWORD FOLLOW_simple_list_in_newline81_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004020000) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_list_in_newline81	= { FOLLOW_simple_list_in_newline81_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_newline83  */
static	ANTLR3_BITWORD FOLLOW_set_in_newline83_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_newline83	= { FOLLOW_set_in_newline83_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_newline98  */
static	ANTLR3_BITWORD FOLLOW_comment_in_newline98_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_newline98	= { FOLLOW_comment_in_newline98_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_comment107  */
static	ANTLR3_BITWORD FOLLOW_15_in_comment107_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000001090) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_comment107	= { FOLLOW_15_in_comment107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_comment110  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_comment110_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000001090) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_comment110	= { FOLLOW_NUMBER_in_comment110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALCHAR_in_comment115  */
static	ANTLR3_BITWORD FOLLOW_ALCHAR_in_comment115_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000001010) };
static  ANTLR3_BITSET_LIST FOLLOW_ALCHAR_in_comment115	= { FOLLOW_ALCHAR_in_comment115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_comment120  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_comment120_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_comment120	= { FOLLOW_WORD_in_comment120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_comment125  */
static	ANTLR3_BITWORD FOLLOW_40_in_comment125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_comment125	= { FOLLOW_40_in_comment125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_simple_list141  */
static	ANTLR3_BITWORD FOLLOW_13_in_simple_list141_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000081010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_simple_list141	= { FOLLOW_13_in_simple_list141_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pipeline_cmd_in_simple_list145  */
static	ANTLR3_BITWORD FOLLOW_pipeline_cmd_in_simple_list145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pipeline_cmd_in_simple_list145	= { FOLLOW_pipeline_cmd_in_simple_list145_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_simple_list148  */
static	ANTLR3_BITWORD FOLLOW_set_in_simple_list148_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000081010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_simple_list148	= { FOLLOW_set_in_simple_list148_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pipeline_cmd_in_simple_list156  */
static	ANTLR3_BITWORD FOLLOW_pipeline_cmd_in_simple_list156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pipeline_cmd_in_simple_list156	= { FOLLOW_pipeline_cmd_in_simple_list156_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_pipeline_cmd168  */
static	ANTLR3_BITWORD FOLLOW_command_in_pipeline_cmd168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_pipeline_cmd168	= { FOLLOW_command_in_pipeline_cmd168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PIPE_in_pipeline_cmd178  */
static	ANTLR3_BITWORD FOLLOW_PIPE_in_pipeline_cmd178_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000081010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_PIPE_in_pipeline_cmd178	= { FOLLOW_PIPE_in_pipeline_cmd178_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_command_in_pipeline_cmd182  */
static	ANTLR3_BITWORD FOLLOW_command_in_pipeline_cmd182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_command_in_pipeline_cmd182	= { FOLLOW_command_in_pipeline_cmd182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cmd_in_command205  */
static	ANTLR3_BITWORD FOLLOW_cmd_in_command205_bits[]	= { ANTLR3_UINT64_LIT(0x0000007A90040082) };
static  ANTLR3_BITSET_LIST FOLLOW_cmd_in_command205	= { FOLLOW_cmd_in_command205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_redir_in_command208  */
static	ANTLR3_BITWORD FOLLOW_to_redir_in_command208_bits[]	= { ANTLR3_UINT64_LIT(0x0000007A90040082) };
static  ANTLR3_BITSET_LIST FOLLOW_to_redir_in_command208	= { FOLLOW_to_redir_in_command208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_redir_in_command212  */
static	ANTLR3_BITWORD FOLLOW_other_redir_in_command212_bits[]	= { ANTLR3_UINT64_LIT(0x0000007A90040082) };
static  ANTLR3_BITSET_LIST FOLLOW_other_redir_in_command212	= { FOLLOW_other_redir_in_command212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_shell_cmd_in_command218  */
static	ANTLR3_BITWORD FOLLOW_shell_cmd_in_command218_bits[]	= { ANTLR3_UINT64_LIT(0x0000007BF0040082) };
static  ANTLR3_BITSET_LIST FOLLOW_shell_cmd_in_command218	= { FOLLOW_shell_cmd_in_command218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_redirection_in_command221  */
static	ANTLR3_BITWORD FOLLOW_redirection_in_command221_bits[]	= { ANTLR3_UINT64_LIT(0x0000007BF0040082) };
static  ANTLR3_BITSET_LIST FOLLOW_redirection_in_command221	= { FOLLOW_redirection_in_command221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_subshell229  */
static	ANTLR3_BITWORD FOLLOW_19_in_subshell229_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_subshell229	= { FOLLOW_19_in_subshell229_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_subshell231  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_subshell231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_subshell231	= { FOLLOW_compound_list_in_subshell231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_subshell233  */
static	ANTLR3_BITWORD FOLLOW_20_in_subshell233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_subshell233	= { FOLLOW_20_in_subshell233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_list_in_compound_list240  */
static	ANTLR3_BITWORD FOLLOW_simple_list_in_compound_list240_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004020002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_list_in_compound_list240	= { FOLLOW_simple_list_in_compound_list240_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_compound_list244  */
static	ANTLR3_BITWORD FOLLOW_set_in_compound_list244_bits[]	= { ANTLR3_UINT64_LIT(0xF5781F0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_compound_list244	= { FOLLOW_set_in_compound_list244_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_compound_list257  */
static	ANTLR3_BITWORD FOLLOW_40_in_compound_list257_bits[]	= { ANTLR3_UINT64_LIT(0xF5781F0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_compound_list257	= { FOLLOW_40_in_compound_list257_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simple_list_in_compound_list261  */
static	ANTLR3_BITWORD FOLLOW_simple_list_in_compound_list261_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004020002) };
static  ANTLR3_BITSET_LIST FOLLOW_simple_list_in_compound_list261	= { FOLLOW_simple_list_in_compound_list261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_redir_in_redirection271  */
static	ANTLR3_BITWORD FOLLOW_to_redir_in_redirection271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_to_redir_in_redirection271	= { FOLLOW_to_redir_in_redirection271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_redirection275  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_redirection275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_redirection275	= { FOLLOW_from_redir_in_redirection275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_redir_in_redirection279  */
static	ANTLR3_BITWORD FOLLOW_other_redir_in_redirection279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_redir_in_redirection279	= { FOLLOW_other_redir_in_redirection279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_to_redir287  */
static	ANTLR3_BITWORD FOLLOW_set_in_to_redir287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_to_redir287	= { FOLLOW_set_in_to_redir287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_to_redir293  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_to_redir293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_to_redir293	= { FOLLOW_WORD_in_to_redir293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_from_redir308  */
static	ANTLR3_BITWORD FOLLOW_set_in_from_redir308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_from_redir308	= { FOLLOW_set_in_from_redir308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_from_redir316  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_from_redir316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_from_redir316	= { FOLLOW_WORD_in_from_redir316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_from_redir324  */
static	ANTLR3_BITWORD FOLLOW_29_in_from_redir324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_from_redir324	= { FOLLOW_29_in_from_redir324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subshell_in_from_redir326  */
static	ANTLR3_BITWORD FOLLOW_subshell_in_from_redir326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subshell_in_from_redir326	= { FOLLOW_subshell_in_from_redir326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir355  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir355_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir355	= { FOLLOW_NUMBER_in_other_redir355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_other_redir357  */
static	ANTLR3_BITWORD FOLLOW_36_in_other_redir357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_other_redir357	= { FOLLOW_36_in_other_redir357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir359  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir359	= { FOLLOW_WORD_in_other_redir359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir380  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir380	= { FOLLOW_NUMBER_in_other_redir380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_other_redir382  */
static	ANTLR3_BITWORD FOLLOW_29_in_other_redir382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_other_redir382	= { FOLLOW_29_in_other_redir382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir384  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir384	= { FOLLOW_WORD_in_other_redir384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir405  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir405_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir405	= { FOLLOW_NUMBER_in_other_redir405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_other_redir407  */
static	ANTLR3_BITWORD FOLLOW_37_in_other_redir407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_other_redir407	= { FOLLOW_37_in_other_redir407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir409  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir409	= { FOLLOW_WORD_in_other_redir409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir430  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir430	= { FOLLOW_NUMBER_in_other_redir430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_other_redir432  */
static	ANTLR3_BITWORD FOLLOW_30_in_other_redir432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_other_redir432	= { FOLLOW_30_in_other_redir432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir434  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir434	= { FOLLOW_WORD_in_other_redir434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_other_redir455  */
static	ANTLR3_BITWORD FOLLOW_28_in_other_redir455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_other_redir455	= { FOLLOW_28_in_other_redir455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir457  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir457_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir457	= { FOLLOW_NUMBER_in_other_redir457_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir478  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir478	= { FOLLOW_NUMBER_in_other_redir478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_other_redir480  */
static	ANTLR3_BITWORD FOLLOW_28_in_other_redir480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_other_redir480	= { FOLLOW_28_in_other_redir480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir482  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir482	= { FOLLOW_NUMBER_in_other_redir482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_other_redir503  */
static	ANTLR3_BITWORD FOLLOW_35_in_other_redir503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_other_redir503	= { FOLLOW_35_in_other_redir503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir505  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir505	= { FOLLOW_NUMBER_in_other_redir505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir526  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir526	= { FOLLOW_NUMBER_in_other_redir526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_other_redir528  */
static	ANTLR3_BITWORD FOLLOW_35_in_other_redir528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_other_redir528	= { FOLLOW_35_in_other_redir528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir530  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir530	= { FOLLOW_NUMBER_in_other_redir530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_other_redir551  */
static	ANTLR3_BITWORD FOLLOW_28_in_other_redir551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_other_redir551	= { FOLLOW_28_in_other_redir551_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir553  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir553	= { FOLLOW_WORD_in_other_redir553_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir574  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir574	= { FOLLOW_NUMBER_in_other_redir574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_other_redir576  */
static	ANTLR3_BITWORD FOLLOW_28_in_other_redir576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_other_redir576	= { FOLLOW_28_in_other_redir576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir578  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir578	= { FOLLOW_WORD_in_other_redir578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_other_redir599  */
static	ANTLR3_BITWORD FOLLOW_35_in_other_redir599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_other_redir599	= { FOLLOW_35_in_other_redir599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir601  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir601	= { FOLLOW_WORD_in_other_redir601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir622  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir622	= { FOLLOW_NUMBER_in_other_redir622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_other_redir624  */
static	ANTLR3_BITWORD FOLLOW_35_in_other_redir624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_other_redir624	= { FOLLOW_35_in_other_redir624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir626  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir626	= { FOLLOW_WORD_in_other_redir626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_other_redir647  */
static	ANTLR3_BITWORD FOLLOW_31_in_other_redir647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_other_redir647	= { FOLLOW_31_in_other_redir647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir649  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir649	= { FOLLOW_WORD_in_other_redir649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir670  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir670	= { FOLLOW_NUMBER_in_other_redir670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_other_redir672  */
static	ANTLR3_BITWORD FOLLOW_31_in_other_redir672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_other_redir672	= { FOLLOW_31_in_other_redir672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir674  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir674	= { FOLLOW_WORD_in_other_redir674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_other_redir695  */
static	ANTLR3_BITWORD FOLLOW_35_in_other_redir695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_other_redir695	= { FOLLOW_35_in_other_redir695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_other_redir697  */
static	ANTLR3_BITWORD FOLLOW_23_in_other_redir697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_other_redir697	= { FOLLOW_23_in_other_redir697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir718  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir718	= { FOLLOW_NUMBER_in_other_redir718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_other_redir720  */
static	ANTLR3_BITWORD FOLLOW_35_in_other_redir720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_other_redir720	= { FOLLOW_35_in_other_redir720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_other_redir722  */
static	ANTLR3_BITWORD FOLLOW_23_in_other_redir722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_other_redir722	= { FOLLOW_23_in_other_redir722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_other_redir743  */
static	ANTLR3_BITWORD FOLLOW_28_in_other_redir743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_other_redir743	= { FOLLOW_28_in_other_redir743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_other_redir745  */
static	ANTLR3_BITWORD FOLLOW_23_in_other_redir745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_other_redir745	= { FOLLOW_23_in_other_redir745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir766  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir766	= { FOLLOW_NUMBER_in_other_redir766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_other_redir768  */
static	ANTLR3_BITWORD FOLLOW_28_in_other_redir768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_other_redir768	= { FOLLOW_28_in_other_redir768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_other_redir770  */
static	ANTLR3_BITWORD FOLLOW_23_in_other_redir770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_other_redir770	= { FOLLOW_23_in_other_redir770_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_other_redir791  */
static	ANTLR3_BITWORD FOLLOW_18_in_other_redir791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_other_redir791	= { FOLLOW_18_in_other_redir791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir793  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir793	= { FOLLOW_WORD_in_other_redir793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir814  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir814	= { FOLLOW_NUMBER_in_other_redir814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_other_redir816  */
static	ANTLR3_BITWORD FOLLOW_33_in_other_redir816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_other_redir816	= { FOLLOW_33_in_other_redir816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir818  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir818	= { FOLLOW_WORD_in_other_redir818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_other_redir839  */
static	ANTLR3_BITWORD FOLLOW_33_in_other_redir839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_other_redir839	= { FOLLOW_33_in_other_redir839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir841  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir841	= { FOLLOW_WORD_in_other_redir841_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_other_redir862  */
static	ANTLR3_BITWORD FOLLOW_38_in_other_redir862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_other_redir862	= { FOLLOW_38_in_other_redir862_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir864  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir864	= { FOLLOW_WORD_in_other_redir864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_other_redir885  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_other_redir885_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_other_redir885	= { FOLLOW_NUMBER_in_other_redir885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_other_redir887  */
static	ANTLR3_BITWORD FOLLOW_38_in_other_redir887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_other_redir887	= { FOLLOW_38_in_other_redir887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_other_redir889  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_other_redir889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_other_redir889	= { FOLLOW_WORD_in_other_redir889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_for_command_in_shell_cmd898  */
static	ANTLR3_BITWORD FOLLOW_for_command_in_shell_cmd898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_for_command_in_shell_cmd898	= { FOLLOW_for_command_in_shell_cmd898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_case_command_in_shell_cmd921  */
static	ANTLR3_BITWORD FOLLOW_case_command_in_shell_cmd921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_case_command_in_shell_cmd921	= { FOLLOW_case_command_in_shell_cmd921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_shell_cmd944  */
static	ANTLR3_BITWORD FOLLOW_63_in_shell_cmd944_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_shell_cmd944	= { FOLLOW_63_in_shell_cmd944_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_shell_cmd946  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_shell_cmd946_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_shell_cmd946	= { FOLLOW_compound_list_in_shell_cmd946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_shell_cmd948  */
static	ANTLR3_BITWORD FOLLOW_45_in_shell_cmd948_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_shell_cmd948	= { FOLLOW_45_in_shell_cmd948_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_shell_cmd950  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_shell_cmd950_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_shell_cmd950	= { FOLLOW_compound_list_in_shell_cmd950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_shell_cmd952  */
static	ANTLR3_BITWORD FOLLOW_46_in_shell_cmd952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_shell_cmd952	= { FOLLOW_46_in_shell_cmd952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_shell_cmd975  */
static	ANTLR3_BITWORD FOLLOW_61_in_shell_cmd975_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_61_in_shell_cmd975	= { FOLLOW_61_in_shell_cmd975_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_shell_cmd977  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_shell_cmd977_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_shell_cmd977	= { FOLLOW_compound_list_in_shell_cmd977_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_shell_cmd979  */
static	ANTLR3_BITWORD FOLLOW_45_in_shell_cmd979_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_shell_cmd979	= { FOLLOW_45_in_shell_cmd979_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_shell_cmd981  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_shell_cmd981_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_shell_cmd981	= { FOLLOW_compound_list_in_shell_cmd981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_shell_cmd983  */
static	ANTLR3_BITWORD FOLLOW_46_in_shell_cmd983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_shell_cmd983	= { FOLLOW_46_in_shell_cmd983_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_if_command_in_shell_cmd1006  */
static	ANTLR3_BITWORD FOLLOW_if_command_in_shell_cmd1006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_if_command_in_shell_cmd1006	= { FOLLOW_if_command_in_shell_cmd1006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subshell_in_shell_cmd1029  */
static	ANTLR3_BITWORD FOLLOW_subshell_in_shell_cmd1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subshell_in_shell_cmd1029	= { FOLLOW_subshell_in_shell_cmd1029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_command_in_shell_cmd1052  */
static	ANTLR3_BITWORD FOLLOW_group_command_in_shell_cmd1052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_command_in_shell_cmd1052	= { FOLLOW_group_command_in_shell_cmd1052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_function_def_in_shell_cmd1075  */
static	ANTLR3_BITWORD FOLLOW_function_def_in_shell_cmd1075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_function_def_in_shell_cmd1075	= { FOLLOW_function_def_in_shell_cmd1075_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_for_header_in_for_command1083  */
static	ANTLR3_BITWORD FOLLOW_for_header_in_for_command1083_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_for_header_in_for_command1083	= { FOLLOW_for_header_in_for_command1083_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_for_command1090  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_for_command1090_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_for_command1090	= { FOLLOW_compound_list_in_for_command1090_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_for_command1092  */
static	ANTLR3_BITWORD FOLLOW_set_in_for_command1092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_for_command1092	= { FOLLOW_set_in_for_command1092_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_for_header1110  */
static	ANTLR3_BITWORD FOLLOW_51_in_for_header1110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_for_header1110	= { FOLLOW_51_in_for_header1110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_for_header1112  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_for_header1112_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_for_header1112	= { FOLLOW_WORD_in_for_header1112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_for_header1114  */
static	ANTLR3_BITWORD FOLLOW_55_in_for_header1114_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004001010) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_for_header1114	= { FOLLOW_55_in_for_header1114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_for_header1116  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_for_header1116_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004001010) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_for_header1116	= { FOLLOW_WORD_in_for_header1116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALCHAR_in_for_header1119  */
static	ANTLR3_BITWORD FOLLOW_ALCHAR_in_for_header1119_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ALCHAR_in_for_header1119	= { FOLLOW_ALCHAR_in_for_header1119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_for_header1122  */
static	ANTLR3_BITWORD FOLLOW_set_in_for_header1122_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_for_header1122	= { FOLLOW_set_in_for_header1122_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_for_header1128  */
static	ANTLR3_BITWORD FOLLOW_set_in_for_header1128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_for_header1128	= { FOLLOW_set_in_for_header1128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_if_command1142  */
static	ANTLR3_BITWORD FOLLOW_54_in_if_command1142_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_if_command1142	= { FOLLOW_54_in_if_command1142_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_if_command1144  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_if_command1144_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_if_command1144	= { FOLLOW_compound_list_in_if_command1144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_if_command1146  */
static	ANTLR3_BITWORD FOLLOW_59_in_if_command1146_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_if_command1146	= { FOLLOW_59_in_if_command1146_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_if_command1148  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_if_command1148_bits[]	= { ANTLR3_UINT64_LIT(0x0001800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_if_command1148	= { FOLLOW_compound_list_in_if_command1148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_if_command1151  */
static	ANTLR3_BITWORD FOLLOW_47_in_if_command1151_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_47_in_if_command1151	= { FOLLOW_47_in_if_command1151_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_if_command1153  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_if_command1153_bits[]	= { ANTLR3_UINT64_LIT(0x0001800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_if_command1153	= { FOLLOW_compound_list_in_if_command1153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_if_command1157  */
static	ANTLR3_BITWORD FOLLOW_48_in_if_command1157_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_if_command1157	= { FOLLOW_48_in_if_command1157_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_if_command1159  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_if_command1159_bits[]	= { ANTLR3_UINT64_LIT(0x0004000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_if_command1159	= { FOLLOW_compound_list_in_if_command1159_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_if_command1161  */
static	ANTLR3_BITWORD FOLLOW_50_in_if_command1161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_if_command1161	= { FOLLOW_50_in_if_command1161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_group_command1169  */
static	ANTLR3_BITWORD FOLLOW_64_in_group_command1169_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_group_command1169	= { FOLLOW_64_in_group_command1169_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_group_command1171  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_group_command1171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_group_command1171	= { FOLLOW_compound_list_in_group_command1171_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_group_command1173  */
static	ANTLR3_BITWORD FOLLOW_66_in_group_command1173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_66_in_group_command1173	= { FOLLOW_66_in_group_command1173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_function_def1183  */
static	ANTLR3_BITWORD FOLLOW_52_in_function_def1183_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_function_def1183	= { FOLLOW_52_in_function_def1183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_function_def1187  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_function_def1187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_function_def1187	= { FOLLOW_WORD_in_function_def1187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_function_def1189  */
static	ANTLR3_BITWORD FOLLOW_19_in_function_def1189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_function_def1189	= { FOLLOW_19_in_function_def1189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_function_def1191  */
static	ANTLR3_BITWORD FOLLOW_20_in_function_def1191_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_function_def1191	= { FOLLOW_20_in_function_def1191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_function_def1193  */
static	ANTLR3_BITWORD FOLLOW_set_in_function_def1193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_function_def1193	= { FOLLOW_set_in_function_def1193_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_group_command_in_function_def1202  */
static	ANTLR3_BITWORD FOLLOW_group_command_in_function_def1202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_group_command_in_function_def1202	= { FOLLOW_group_command_in_function_def1202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_case_command1212  */
static	ANTLR3_BITWORD FOLLOW_42_in_case_command1212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_case_command1212	= { FOLLOW_42_in_case_command1212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_case_command1214  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_case_command1214_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_case_command1214	= { FOLLOW_WORD_in_case_command1214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_case_command1216  */
static	ANTLR3_BITWORD FOLLOW_set_in_case_command1216_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_case_command1216	= { FOLLOW_set_in_case_command1216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_case_command1224  */
static	ANTLR3_BITWORD FOLLOW_55_in_case_command1224_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_case_command1224	= { FOLLOW_55_in_case_command1224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_case_command1226  */
static	ANTLR3_BITWORD FOLLOW_set_in_case_command1226_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000001080) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_case_command1226	= { FOLLOW_set_in_case_command1226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_case_clause_in_case_command1234  */
static	ANTLR3_BITWORD FOLLOW_case_clause_in_case_command1234_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000001080) };
static  ANTLR3_BITSET_LIST FOLLOW_case_clause_in_case_command1234	= { FOLLOW_case_clause_in_case_command1234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_49_in_case_command1237  */
static	ANTLR3_BITWORD FOLLOW_49_in_case_command1237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_49_in_case_command1237	= { FOLLOW_49_in_case_command1237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pattern_in_case_clause1244  */
static	ANTLR3_BITWORD FOLLOW_pattern_in_case_clause1244_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_pattern_in_case_clause1244	= { FOLLOW_pattern_in_case_clause1244_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_case_clause1246  */
static	ANTLR3_BITWORD FOLLOW_20_in_case_clause1246_bits[]	= { ANTLR3_UINT64_LIT(0xF5781E0000083010), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_case_clause1246	= { FOLLOW_20_in_case_clause1246_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compound_list_in_case_clause1248  */
static	ANTLR3_BITWORD FOLLOW_compound_list_in_case_clause1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_compound_list_in_case_clause1248	= { FOLLOW_compound_list_in_case_clause1248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_case_clause1250  */
static	ANTLR3_BITWORD FOLLOW_27_in_case_clause1250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_case_clause1250	= { FOLLOW_27_in_case_clause1250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_cmd1276  */
static	ANTLR3_BITWORD FOLLOW_44_in_cmd1276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401100) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_cmd1276	= { FOLLOW_44_in_cmd1276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1281  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1281	= { FOLLOW_OPTS_in_cmd1281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1296  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1296	= { FOLLOW_WORD_in_cmd1296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1309  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1309	= { FOLLOW_from_redir_in_cmd1309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1322  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1322	= { FOLLOW_22_in_cmd1322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_cmd1331  */
static	ANTLR3_BITWORD FOLLOW_43_in_cmd1331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_cmd1331	= { FOLLOW_43_in_cmd1331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1336  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1336	= { FOLLOW_OPTS_in_cmd1336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1343  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1343	= { FOLLOW_WORD_in_cmd1343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1357  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1357	= { FOLLOW_from_redir_in_cmd1357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1370  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1370	= { FOLLOW_22_in_cmd1370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_cmd1378  */
static	ANTLR3_BITWORD FOLLOW_53_in_cmd1378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001100) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_cmd1378	= { FOLLOW_53_in_cmd1378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1385  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001100) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1385	= { FOLLOW_OPTS_in_cmd1385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1397  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1397	= { FOLLOW_WORD_in_cmd1397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1410  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1410	= { FOLLOW_OPTS_in_cmd1410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1422  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1422	= { FOLLOW_WORD_in_cmd1422_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1432  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1432	= { FOLLOW_from_redir_in_cmd1432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1445  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1445	= { FOLLOW_22_in_cmd1445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_cmd1454  */
static	ANTLR3_BITWORD FOLLOW_58_in_cmd1454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_cmd1454	= { FOLLOW_58_in_cmd1454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1458  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1458	= { FOLLOW_OPTS_in_cmd1458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1467  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1467	= { FOLLOW_WORD_in_cmd1467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1476  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1476	= { FOLLOW_from_redir_in_cmd1476_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1489  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1489	= { FOLLOW_22_in_cmd1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_cmd1499  */
static	ANTLR3_BITWORD FOLLOW_56_in_cmd1499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401100) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_cmd1499	= { FOLLOW_56_in_cmd1499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_cmd1503  */
static	ANTLR3_BITWORD FOLLOW_24_in_cmd1503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_cmd1503	= { FOLLOW_24_in_cmd1503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_cmd1507  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_cmd1507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401102) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_cmd1507	= { FOLLOW_NUMBER_in_cmd1507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_cmd1518  */
static	ANTLR3_BITWORD FOLLOW_25_in_cmd1518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_cmd1518	= { FOLLOW_25_in_cmd1518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_cmd1522  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_cmd1522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401102) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_cmd1522	= { FOLLOW_NUMBER_in_cmd1522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1532  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1532	= { FOLLOW_OPTS_in_cmd1532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1538  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1538	= { FOLLOW_WORD_in_cmd1538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1546  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1546	= { FOLLOW_22_in_cmd1546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1554  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000163401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1554	= { FOLLOW_from_redir_in_cmd1554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_cmd1571  */
static	ANTLR3_BITWORD FOLLOW_60_in_cmd1571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_cmd1571	= { FOLLOW_60_in_cmd1571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1575  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1575	= { FOLLOW_OPTS_in_cmd1575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1590  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1590	= { FOLLOW_WORD_in_cmd1590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1603  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1603	= { FOLLOW_from_redir_in_cmd1603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1616  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1616	= { FOLLOW_22_in_cmd1616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_cmd1629  */
static	ANTLR3_BITWORD FOLLOW_62_in_cmd1629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_62_in_cmd1629	= { FOLLOW_62_in_cmd1629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1633  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1633	= { FOLLOW_OPTS_in_cmd1633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_cmd1648  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_cmd1648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_cmd1648	= { FOLLOW_WORD_in_cmd1648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_redir_in_cmd1661  */
static	ANTLR3_BITWORD FOLLOW_from_redir_in_cmd1661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_from_redir_in_cmd1661	= { FOLLOW_from_redir_in_cmd1661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_cmd1674  */
static	ANTLR3_BITWORD FOLLOW_22_in_cmd1674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000160401102) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_cmd1674	= { FOLLOW_22_in_cmd1674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_cmd1687  */
static	ANTLR3_BITWORD FOLLOW_41_in_cmd1687_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_cmd1687	= { FOLLOW_41_in_cmd1687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1689  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1689_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1689	= { FOLLOW_OPTS_in_cmd1689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_cmd1692  */
static	ANTLR3_BITWORD FOLLOW_39_in_cmd1692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001080), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_cmd1692	= { FOLLOW_39_in_cmd1692_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_awkbody_in_cmd1694  */
static	ANTLR3_BITWORD FOLLOW_awkbody_in_cmd1694_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_awkbody_in_cmd1694	= { FOLLOW_awkbody_in_cmd1694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_cmd1697  */
static	ANTLR3_BITWORD FOLLOW_39_in_cmd1697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_cmd1697	= { FOLLOW_39_in_cmd1697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTS_in_cmd1699  */
static	ANTLR3_BITWORD FOLLOW_OPTS_in_cmd1699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTS_in_cmd1699	= { FOLLOW_OPTS_in_cmd1699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_words_in_cmd1705  */
static	ANTLR3_BITWORD FOLLOW_words_in_cmd1705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_words_in_cmd1705	= { FOLLOW_words_in_cmd1705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALCHAR_in_words1716  */
static	ANTLR3_BITWORD FOLLOW_ALCHAR_in_words1716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001012) };
static  ANTLR3_BITSET_LIST FOLLOW_ALCHAR_in_words1716	= { FOLLOW_ALCHAR_in_words1716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_words1719  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_words1719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001002) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_words1719	= { FOLLOW_WORD_in_words1719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_assignment1727  */
static	ANTLR3_BITWORD FOLLOW_set_in_assignment1727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_assignment1727	= { FOLLOW_set_in_assignment1727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_assignment1732  */
static	ANTLR3_BITWORD FOLLOW_34_in_assignment1732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001010) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_assignment1732	= { FOLLOW_34_in_assignment1732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_assignment1733  */
static	ANTLR3_BITWORD FOLLOW_set_in_assignment1733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_assignment1733	= { FOLLOW_set_in_assignment1733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_word1745  */
static	ANTLR3_BITWORD FOLLOW_14_in_word1745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004010) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_word1745	= { FOLLOW_14_in_word1745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALCHAR_in_word1747  */
static	ANTLR3_BITWORD FOLLOW_ALCHAR_in_word1747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004010) };
static  ANTLR3_BITSET_LIST FOLLOW_ALCHAR_in_word1747	= { FOLLOW_ALCHAR_in_word1747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_word1750  */
static	ANTLR3_BITWORD FOLLOW_14_in_word1750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_word1750	= { FOLLOW_14_in_word1750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_word1755  */
static	ANTLR3_BITWORD FOLLOW_39_in_word1755_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_word1755	= { FOLLOW_39_in_word1755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALCHAR_in_word1757  */
static	ANTLR3_BITWORD FOLLOW_ALCHAR_in_word1757_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_ALCHAR_in_word1757	= { FOLLOW_ALCHAR_in_word1757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_word1760  */
static	ANTLR3_BITWORD FOLLOW_39_in_word1760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_word1760	= { FOLLOW_39_in_word1760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pattern_in_awkbody1770  */
static	ANTLR3_BITWORD FOLLOW_pattern_in_awkbody1770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_pattern_in_awkbody1770	= { FOLLOW_pattern_in_awkbody1770_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_awkbody1786  */
static	ANTLR3_BITWORD FOLLOW_64_in_awkbody1786_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000001080), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_awkbody1786	= { FOLLOW_64_in_awkbody1786_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_awkbody1789  */
static	ANTLR3_BITWORD FOLLOW_57_in_awkbody1789_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000201080), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_57_in_awkbody1789	= { FOLLOW_57_in_awkbody1789_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_awkbody1791  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_awkbody1791_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000201080), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_awkbody1791	= { FOLLOW_NUMBER_in_awkbody1791_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_21_in_awkbody1795  */
static	ANTLR3_BITWORD FOLLOW_21_in_awkbody1795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_21_in_awkbody1795	= { FOLLOW_21_in_awkbody1795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_awkbody1797  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_awkbody1797_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000201080), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_awkbody1797	= { FOLLOW_NUMBER_in_awkbody1797_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WORD_in_awkbody1803  */
static	ANTLR3_BITWORD FOLLOW_WORD_in_awkbody1803_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001080), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WORD_in_awkbody1803	= { FOLLOW_WORD_in_awkbody1803_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_awkbody1806  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_awkbody1806_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_awkbody1806	= { FOLLOW_NUMBER_in_awkbody1806_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_awkbody1811  */
static	ANTLR3_BITWORD FOLLOW_66_in_awkbody1811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_66_in_awkbody1811	= { FOLLOW_66_in_awkbody1811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1821  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1821_bits[]	= { ANTLR3_UINT64_LIT(0x0000001420000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1821	= { FOLLOW_set_in_pattern1821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1827  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1827_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400001080) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1827	= { FOLLOW_set_in_pattern1827_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_pattern1835  */
static	ANTLR3_BITWORD FOLLOW_34_in_pattern1835_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001080) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_pattern1835	= { FOLLOW_34_in_pattern1835_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1839  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1839	= { FOLLOW_set_in_pattern1839_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1847  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001080) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1847	= { FOLLOW_set_in_pattern1847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1857  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1857_bits[]	= { ANTLR3_UINT64_LIT(0x0000001420000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1857	= { FOLLOW_set_in_pattern1857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1863  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400001080) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1863	= { FOLLOW_set_in_pattern1863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_pattern1871  */
static	ANTLR3_BITWORD FOLLOW_34_in_pattern1871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001080) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_pattern1871	= { FOLLOW_34_in_pattern1871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_pattern1875  */
static	ANTLR3_BITWORD FOLLOW_set_in_pattern1875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_pattern1875	= { FOLLOW_set_in_pattern1875_bits, 2	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start file
 * SimpleBashSQL.g:465:1: file : ( newline )* ;
 */
static void
file(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:465:5: ( ( newline )* )
        // SimpleBashSQL.g:465:7: ( newline )*
        {
            // SimpleBashSQL.g:465:7: ( newline )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case ALCHAR:
                case NUMBER:
                case PIPE:
                case WORD:
                case 13:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 26:
                case 27:
                case 28:
                case 31:
                case 33:
                case 35:
                case 36:
                case 37:
                case 38:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 56:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // SimpleBashSQL.g:465:7: newline
            	    {
            	        FOLLOWPUSH(FOLLOW_newline_in_file68);
            	        newline(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefileEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefileEx; /* Prevent compiler warnings */
    rulefileEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end file */

/**
 * $ANTLR start newline
 * SimpleBashSQL.g:467:1: newline : ( ( '\\n' )* simple_list ( '\\n' | ';' | '&' ) | comment );
 */
static void
newline(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_comment_return comment1;
    #undef	RETURN_TYPE_comment1
    #define	RETURN_TYPE_comment1 SimpleBashSQLParser_comment_return

    /* Initialize rule variables
     */

    {
        {
            //  SimpleBashSQL.g:467:8: ( ( '\\n' )* simple_list ( '\\n' | ';' | '&' ) | comment )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case ALCHAR:
            case NUMBER:
            case PIPE:
            case WORD:
            case 13:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 26:
            case 27:
            case 28:
            case 31:
            case 33:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 56:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 65:
            case 66:
            	{
            		alt3=1;
            	}
                break;
            case 15:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto rulenewlineEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // SimpleBashSQL.g:467:10: ( '\\n' )* simple_list ( '\\n' | ';' | '&' )
        	    {
        	        // SimpleBashSQL.g:467:10: ( '\\n' )*

        	        for (;;)
        	        {
        	            int alt2=2;
        	            switch ( LA(1) )
        	            {
        	            case 40:
        	            	{
        	            		alt2=1;
        	            	}
        	                break;

        	            }

        	            switch (alt2)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:467:11: '\\n'
        	        	    {
        	        	         MATCHT(40, &FOLLOW_40_in_newline77);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulenewlineEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop2;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop2: ; /* Jump out to here if this rule does not match */


        	        FOLLOWPUSH(FOLLOW_simple_list_in_newline81);
        	        simple_list(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenewlineEx;
        	        }


        	        if ( LA(1) == 17 || LA(1) == 26 || LA(1) == 40 )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_newline83;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_newline83);
        	            goto rulenewlineEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:468:4: comment
        	    {
        	        FOLLOWPUSH(FOLLOW_comment_in_newline98);
        	        comment1=comment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenewlineEx;
        	        }


        	        {
        	            printf("%s\n",(STRSTREAM->toStringTT(STRSTREAM, comment1.start, comment1.stop))
        	            ->chars);
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulenewlineEx; /* Prevent compiler warnings */
    rulenewlineEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end newline */

/**
 * $ANTLR start comment
 * SimpleBashSQL.g:470:1: comment : '#' ( NUMBER )* ( ALCHAR )* ( WORD )* ( '\\n' ) ;
 */
static SimpleBashSQLParser_comment_return
comment(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_comment_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // SimpleBashSQL.g:470:8: ( '#' ( NUMBER )* ( ALCHAR )* ( WORD )* ( '\\n' ) )
        // SimpleBashSQL.g:470:10: '#' ( NUMBER )* ( ALCHAR )* ( WORD )* ( '\\n' )
        {
             MATCHT(15, &FOLLOW_15_in_comment107);
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }


            // SimpleBashSQL.g:470:14: ( NUMBER )*

            for (;;)
            {
                int alt4=2;
                switch ( LA(1) )
                {
                case NUMBER:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // SimpleBashSQL.g:470:15: NUMBER
            	    {
            	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_comment110);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommentEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:470:24: ( ALCHAR )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) )
                {
                case ALCHAR:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // SimpleBashSQL.g:470:25: ALCHAR
            	    {
            	         MATCHT(ALCHAR, &FOLLOW_ALCHAR_in_comment115);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommentEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:470:34: ( WORD )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case WORD:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // SimpleBashSQL.g:470:35: WORD
            	    {
            	         MATCHT(WORD, &FOLLOW_WORD_in_comment120);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommentEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:470:42: ( '\\n' )
            // SimpleBashSQL.g:470:43: '\\n'
            {
                 MATCHT(40, &FOLLOW_40_in_comment125);
                if  (HASEXCEPTION())
                {
                    goto rulecommentEx;
                }


            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecommentEx; /* Prevent compiler warnings */
    rulecommentEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end comment */

/**
 * $ANTLR start simple_list
 * SimpleBashSQL.g:472:1: simple_list : ( '!' )? pipeline_cmd ( ( '&&' | '||' ) pipeline_cmd )* ;
 */
static void
simple_list(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */


    lastquery=NULL;

    {
        // SimpleBashSQL.g:476:2: ( ( '!' )? pipeline_cmd ( ( '&&' | '||' ) pipeline_cmd )* )
        // SimpleBashSQL.g:476:4: ( '!' )? pipeline_cmd ( ( '&&' | '||' ) pipeline_cmd )*
        {
            // SimpleBashSQL.g:476:4: ( '!' )?
            {
                int alt7=2;
                switch ( LA(1) )
                {
                    case 13:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7)
                {
            	case 1:
            	    // SimpleBashSQL.g:476:5: '!'
            	    {
            	         MATCHT(13, &FOLLOW_13_in_simple_list141);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_listEx;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_pipeline_cmd_in_simple_list145);
            pipeline_cmd(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimple_listEx;
            }


            // SimpleBashSQL.g:476:24: ( ( '&&' | '||' ) pipeline_cmd )*

            for (;;)
            {
                int alt8=2;
                switch ( LA(1) )
                {
                case 16:
                case 65:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // SimpleBashSQL.g:476:25: ( '&&' | '||' ) pipeline_cmd
            	    {
            	        if ( LA(1) == 16 || LA(1) == 65 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_simple_list148;

            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_simple_list148);
            	            goto rulesimple_listEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_pipeline_cmd_in_simple_list156);
            	        pipeline_cmd(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimple_listEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesimple_listEx; /* Prevent compiler warnings */
    rulesimple_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end simple_list */

/**
 * $ANTLR start pipeline_cmd
 * SimpleBashSQL.g:478:1: pipeline_cmd : c1= command ( PIPE c2= command )* ;
 */
static void
pipeline_cmd(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_command_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 SimpleBashSQLParser_command_return

    SimpleBashSQLParser_command_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 SimpleBashSQLParser_command_return

    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:478:14: (c1= command ( PIPE c2= command )* )
        // SimpleBashSQL.g:478:16: c1= command ( PIPE c2= command )*
        {
            FOLLOWPUSH(FOLLOW_command_in_pipeline_cmd168);
            c1=command(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepipeline_cmdEx;
            }


            {
                 
                			if(tobeprint && !lastquery && (STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
                ->chars)
                				printf("%s",(STRSTREAM->toStringTT(STRSTREAM, c1.start, c1.stop))
                ->chars);
                			
            }


            // SimpleBashSQL.g:483:3: ( PIPE c2= command )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) )
                {
                case PIPE:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9)
                {
            	case 1:
            	    // SimpleBashSQL.g:483:4: PIPE c2= command
            	    {
            	         MATCHT(PIPE, &FOLLOW_PIPE_in_pipeline_cmd178);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepipeline_cmdEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_command_in_pipeline_cmd182);
            	        c2=command(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepipeline_cmdEx;
            	        }


            	        {
            	             
            	            			if(tobeprint && !lastquery)
            	            		  		printf(" | %s",(STRSTREAM->toStringTT(STRSTREAM, c2.start, c2.stop))
            	            ->chars);
            	            			
            	        }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


            {

                		if(lastquery)
                			ausgeben(lastquery);
                		printf("\n");
                		tobeprint=1;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepipeline_cmdEx; /* Prevent compiler warnings */
    rulepipeline_cmdEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end pipeline_cmd */

/**
 * $ANTLR start command
 * SimpleBashSQL.g:497:1: command : ( cmd ( to_redir | other_redir )* | shell_cmd ( redirection )* );
 */
static SimpleBashSQLParser_command_return
command(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_command_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  SimpleBashSQL.g:497:8: ( cmd ( to_redir | other_redir )* | shell_cmd ( redirection )* )

            ANTLR3_UINT32 alt12;

            alt12=2;

            switch ( LA(1) )
            {
            case ALCHAR:
            case NUMBER:
            case PIPE:
            case 16:
            case 17:
            case 18:
            case 20:
            case 26:
            case 27:
            case 28:
            case 31:
            case 33:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 50:
            case 53:
            case 56:
            case 58:
            case 59:
            case 60:
            case 62:
            case 65:
            case 66:
            	{
            		alt12=1;
            	}
                break;
            case WORD:
            	{
            		switch ( LA(2) )
            		{
            		case 19:
            			{
            				alt12=2;
            			}
            		    break;
            		case NUMBER:
            		case PIPE:
            		case WORD:
            		case 16:
            		case 17:
            		case 18:
            		case 20:
            		case 26:
            		case 27:
            		case 28:
            		case 31:
            		case 33:
            		case 35:
            		case 36:
            		case 37:
            		case 38:
            		case 40:
            		case 45:
            		case 46:
            		case 47:
            		case 48:
            		case 50:
            		case 59:
            		case 65:
            		case 66:
            			{
            				alt12=1;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 12;
            		    EXCEPTION->state        = 2;


            		    goto rulecommandEx;

            		}

            	}
                break;
            case 19:
            case 42:
            case 51:
            case 52:
            case 54:
            case 61:
            case 63:
            case 64:
            	{
            		alt12=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto rulecommandEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // SimpleBashSQL.g:497:10: cmd ( to_redir | other_redir )*
        	    {
        	        FOLLOWPUSH(FOLLOW_cmd_in_command205);
        	        cmd(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // SimpleBashSQL.g:497:14: ( to_redir | other_redir )*

        	        for (;;)
        	        {
        	            int alt10=3;
        	            switch ( LA(1) )
        	            {
        	            case 36:
        	            case 37:
        	            	{
        	            		alt10=1;
        	            	}
        	                break;
        	            case NUMBER:
        	            case 18:
        	            case 28:
        	            case 31:
        	            case 33:
        	            case 35:
        	            case 38:
        	            	{
        	            		alt10=2;
        	            	}
        	                break;

        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:497:15: to_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_to_redir_in_command208);
        	        	        to_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:497:26: other_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_other_redir_in_command212);
        	        	        other_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop10;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop10: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:497:42: shell_cmd ( redirection )*
        	    {
        	        FOLLOWPUSH(FOLLOW_shell_cmd_in_command218);
        	        shell_cmd(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecommandEx;
        	        }


        	        // SimpleBashSQL.g:497:52: ( redirection )*

        	        for (;;)
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	            case NUMBER:
        	            case 18:
        	            case 28:
        	            case 29:
        	            case 30:
        	            case 31:
        	            case 32:
        	            case 33:
        	            case 35:
        	            case 36:
        	            case 37:
        	            case 38:
        	            	{
        	            		alt11=1;
        	            	}
        	                break;

        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:497:53: redirection
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_redirection_in_command221);
        	        	        redirection(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecommandEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop11;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop11: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecommandEx; /* Prevent compiler warnings */
    rulecommandEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end command */

/**
 * $ANTLR start subshell
 * SimpleBashSQL.g:498:1: subshell : '(' compound_list ')' ;
 */
static void
subshell(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:498:9: ( '(' compound_list ')' )
        // SimpleBashSQL.g:498:11: '(' compound_list ')'
        {
             MATCHT(19, &FOLLOW_19_in_subshell229);
            if  (HASEXCEPTION())
            {
                goto rulesubshellEx;
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_subshell231);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubshellEx;
            }


             MATCHT(20, &FOLLOW_20_in_subshell233);
            if  (HASEXCEPTION())
            {
                goto rulesubshellEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubshellEx; /* Prevent compiler warnings */
    rulesubshellEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end subshell */

/**
 * $ANTLR start compound_list
 * SimpleBashSQL.g:500:1: compound_list : simple_list ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list )* ;
 */
static void
compound_list(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:500:14: ( simple_list ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list )* )
        // SimpleBashSQL.g:500:16: simple_list ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list )*
        {
            FOLLOWPUSH(FOLLOW_simple_list_in_compound_list240);
            simple_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecompound_listEx;
            }


            // SimpleBashSQL.g:500:28: ( ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) )
                {
                case 17:
                case 26:
                case 40:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14)
                {
            	case 1:
            	    // SimpleBashSQL.g:500:30: ( '\\n' | ';' | '&' ) ( '\\n' )* simple_list
            	    {
            	        if ( LA(1) == 17 || LA(1) == 26 || LA(1) == 40 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_compound_list244;

            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_compound_list244);
            	            goto rulecompound_listEx;
            	        }


            	        // SimpleBashSQL.g:500:49: ( '\\n' )*

            	        for (;;)
            	        {
            	            int alt13=2;
            	            switch ( LA(1) )
            	            {
            	            case 40:
            	            	{
            	            		alt13=1;
            	            	}
            	                break;

            	            }

            	            switch (alt13)
            	            {
            	        	case 1:
            	        	    // SimpleBashSQL.g:500:50: '\\n'
            	        	    {
            	        	         MATCHT(40, &FOLLOW_40_in_compound_list257);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecompound_listEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop13;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop13: ; /* Jump out to here if this rule does not match */


            	        FOLLOWPUSH(FOLLOW_simple_list_in_compound_list261);
            	        simple_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecompound_listEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecompound_listEx; /* Prevent compiler warnings */
    rulecompound_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end compound_list */

/**
 * $ANTLR start redirection
 * SimpleBashSQL.g:502:1: redirection : ( to_redir | from_redir | other_redir );
 */
static void
redirection(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  SimpleBashSQL.g:502:12: ( to_redir | from_redir | other_redir )

            ANTLR3_UINT32 alt15;

            alt15=3;

            switch ( LA(1) )
            {
            case 36:
            case 37:
            	{
            		alt15=1;
            	}
                break;
            case 29:
            case 30:
            case 32:
            	{
            		alt15=2;
            	}
                break;
            case NUMBER:
            case 18:
            case 28:
            case 31:
            case 33:
            case 35:
            case 38:
            	{
            		alt15=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruleredirectionEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // SimpleBashSQL.g:502:14: to_redir
        	    {
        	        FOLLOWPUSH(FOLLOW_to_redir_in_redirection271);
        	        to_redir(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleredirectionEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:502:25: from_redir
        	    {
        	        FOLLOWPUSH(FOLLOW_from_redir_in_redirection275);
        	        from_redir(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleredirectionEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:502:38: other_redir
        	    {
        	        FOLLOWPUSH(FOLLOW_other_redir_in_redirection279);
        	        other_redir(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleredirectionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleredirectionEx; /* Prevent compiler warnings */
    ruleredirectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end redirection */

/**
 * $ANTLR start to_redir
 * SimpleBashSQL.g:504:1: to_redir : ( '>' | '>>' ) WORD ;
 */
static void
to_redir(pSimpleBashSQLParser ctx)
{
    pANTLR3_COMMON_TOKEN    WORD2;

    /* Initialize rule variables
     */

    WORD2       = NULL;

    {
        // SimpleBashSQL.g:504:9: ( ( '>' | '>>' ) WORD )
        // SimpleBashSQL.g:504:11: ( '>' | '>>' ) WORD
        {
            if ( ((LA(1) >= 36) && (LA(1) <= 37)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_to_redir287;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_to_redir287);
                goto ruleto_redirEx;
            }


            WORD2 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_to_redir293);
            if  (HASEXCEPTION())
            {
                goto ruleto_redirEx;
            }


            {

                		if(lastquery)
                			strcpy(lastquery->as,(WORD2->getText(WORD2))->chars);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleto_redirEx; /* Prevent compiler warnings */
    ruleto_redirEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end to_redir */

/**
 * $ANTLR start from_redir
 * SimpleBashSQL.g:509:1: from_redir returns [char* fname] : ( ( '<' | '<<' | '<<<' ) WORD | '<' subshell );
 */
static char*
from_redir(pSimpleBashSQLParser ctx)
{
    char* fname;


    pANTLR3_COMMON_TOKEN    WORD3;

    /* Initialize rule variables
     */

    WORD3       = NULL;

    {
        {
            //  SimpleBashSQL.g:510:3: ( ( '<' | '<<' | '<<<' ) WORD | '<' subshell )

            ANTLR3_UINT32 alt16;

            alt16=2;

            switch ( LA(1) )
            {
            case 29:
            	{
            		switch ( LA(2) )
            		{
            		case WORD:
            			{
            				alt16=1;
            			}
            		    break;
            		case 19:
            			{
            				alt16=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 16;
            		    EXCEPTION->state        = 1;


            		    goto rulefrom_redirEx;

            		}

            	}
                break;
            case 30:
            case 32:
            	{
            		alt16=1;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulefrom_redirEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // SimpleBashSQL.g:510:5: ( '<' | '<<' | '<<<' ) WORD
        	    {
        	        if ( ((LA(1) >= 29) && (LA(1) <= 30)) || LA(1) == 32 )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_from_redir308;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_from_redir308);
        	            goto rulefrom_redirEx;
        	        }


        	        WORD3 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_from_redir316);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefrom_redirEx;
        	        }


        	        {
        	            fname=(WORD3->getText(WORD3))->chars;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:511:5: '<' subshell
        	    {
        	         MATCHT(29, &FOLLOW_29_in_from_redir324);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefrom_redirEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_subshell_in_from_redir326);
        	        subshell(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefrom_redirEx;
        	        }


        	        {
        	            fname=NULL;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefrom_redirEx; /* Prevent compiler warnings */
    rulefrom_redirEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return fname;
}
/* $ANTLR end from_redir */

/**
 * $ANTLR start other_redir
 * SimpleBashSQL.g:513:1: other_redir : ( NUMBER '>' WORD | NUMBER '<' WORD | NUMBER '>>' WORD | NUMBER '<<' WORD | '<&' NUMBER | NUMBER '<&' NUMBER | '>&' NUMBER | NUMBER '>&' NUMBER | '<&' WORD | NUMBER '<&' WORD | '>&' WORD | NUMBER '>&' WORD | '<<-' WORD | NUMBER '<<-' WORD | '>&' '-' | NUMBER '>&' '-' | '<&' '-' | NUMBER '<&' '-' | '&>' WORD | NUMBER '<>' WORD | '<>' WORD | '>|' WORD | NUMBER '>|' WORD );
 */
static void
other_redir(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  SimpleBashSQL.g:513:12: ( NUMBER '>' WORD | NUMBER '<' WORD | NUMBER '>>' WORD | NUMBER '<<' WORD | '<&' NUMBER | NUMBER '<&' NUMBER | '>&' NUMBER | NUMBER '>&' NUMBER | '<&' WORD | NUMBER '<&' WORD | '>&' WORD | NUMBER '>&' WORD | '<<-' WORD | NUMBER '<<-' WORD | '>&' '-' | NUMBER '>&' '-' | '<&' '-' | NUMBER '<&' '-' | '&>' WORD | NUMBER '<>' WORD | '<>' WORD | '>|' WORD | NUMBER '>|' WORD )

            ANTLR3_UINT32 alt17;

            alt17=23;

            switch ( LA(1) )
            {
            case NUMBER:
            	{
            		switch ( LA(2) )
            		{
            		case 36:
            			{
            				alt17=1;
            			}
            		    break;
            		case 29:
            			{
            				alt17=2;
            			}
            		    break;
            		case 37:
            			{
            				alt17=3;
            			}
            		    break;
            		case 30:
            			{
            				alt17=4;
            			}
            		    break;
            		case 28:
            			{
            				switch ( LA(3) )
            				{
            				case NUMBER:
            					{
            						alt17=6;
            					}
            				    break;
            				case WORD:
            					{
            						alt17=10;
            					}
            				    break;
            				case 23:
            					{
            						alt17=18;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 17;
            				    EXCEPTION->state        = 12;


            				    goto ruleother_redirEx;

            				}

            			}
            		    break;
            		case 35:
            			{
            				switch ( LA(3) )
            				{
            				case NUMBER:
            					{
            						alt17=8;
            					}
            				    break;
            				case WORD:
            					{
            						alt17=12;
            					}
            				    break;
            				case 23:
            					{
            						alt17=16;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 17;
            				    EXCEPTION->state        = 13;


            				    goto ruleother_redirEx;

            				}

            			}
            		    break;
            		case 31:
            			{
            				alt17=14;
            			}
            		    break;
            		case 33:
            			{
            				alt17=20;
            			}
            		    break;
            		case 38:
            			{
            				alt17=23;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 17;
            		    EXCEPTION->state        = 1;


            		    goto ruleother_redirEx;

            		}

            	}
                break;
            case 28:
            	{
            		switch ( LA(2) )
            		{
            		case NUMBER:
            			{
            				alt17=5;
            			}
            		    break;
            		case WORD:
            			{
            				alt17=9;
            			}
            		    break;
            		case 23:
            			{
            				alt17=17;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 17;
            		    EXCEPTION->state        = 2;


            		    goto ruleother_redirEx;

            		}

            	}
                break;
            case 35:
            	{
            		switch ( LA(2) )
            		{
            		case NUMBER:
            			{
            				alt17=7;
            			}
            		    break;
            		case WORD:
            			{
            				alt17=11;
            			}
            		    break;
            		case 23:
            			{
            				alt17=15;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 17;
            		    EXCEPTION->state        = 3;


            		    goto ruleother_redirEx;

            		}

            	}
                break;
            case 31:
            	{
            		alt17=13;
            	}
                break;
            case 18:
            	{
            		alt17=19;
            	}
                break;
            case 33:
            	{
            		alt17=21;
            	}
                break;
            case 38:
            	{
            		alt17=22;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruleother_redirEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // SimpleBashSQL.g:514:20: NUMBER '>' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir355);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(36, &FOLLOW_36_in_other_redir357);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir359);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:515:20: NUMBER '<' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir380);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(29, &FOLLOW_29_in_other_redir382);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir384);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:516:20: NUMBER '>>' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir405);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(37, &FOLLOW_37_in_other_redir407);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir409);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // SimpleBashSQL.g:517:20: NUMBER '<<' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir430);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(30, &FOLLOW_30_in_other_redir432);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir434);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // SimpleBashSQL.g:518:20: '<&' NUMBER
        	    {
        	         MATCHT(28, &FOLLOW_28_in_other_redir455);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir457);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // SimpleBashSQL.g:519:20: NUMBER '<&' NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir478);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(28, &FOLLOW_28_in_other_redir480);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir482);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // SimpleBashSQL.g:520:20: '>&' NUMBER
        	    {
        	         MATCHT(35, &FOLLOW_35_in_other_redir503);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir505);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // SimpleBashSQL.g:521:20: NUMBER '>&' NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir526);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(35, &FOLLOW_35_in_other_redir528);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir530);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 9:
        	    // SimpleBashSQL.g:522:20: '<&' WORD
        	    {
        	         MATCHT(28, &FOLLOW_28_in_other_redir551);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir553);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 10:
        	    // SimpleBashSQL.g:523:20: NUMBER '<&' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir574);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(28, &FOLLOW_28_in_other_redir576);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir578);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // SimpleBashSQL.g:524:20: '>&' WORD
        	    {
        	         MATCHT(35, &FOLLOW_35_in_other_redir599);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir601);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 12:
        	    // SimpleBashSQL.g:525:20: NUMBER '>&' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir622);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(35, &FOLLOW_35_in_other_redir624);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir626);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 13:
        	    // SimpleBashSQL.g:526:20: '<<-' WORD
        	    {
        	         MATCHT(31, &FOLLOW_31_in_other_redir647);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir649);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 14:
        	    // SimpleBashSQL.g:527:20: NUMBER '<<-' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir670);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(31, &FOLLOW_31_in_other_redir672);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir674);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 15:
        	    // SimpleBashSQL.g:528:20: '>&' '-'
        	    {
        	         MATCHT(35, &FOLLOW_35_in_other_redir695);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(23, &FOLLOW_23_in_other_redir697);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 16:
        	    // SimpleBashSQL.g:529:20: NUMBER '>&' '-'
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir718);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(35, &FOLLOW_35_in_other_redir720);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(23, &FOLLOW_23_in_other_redir722);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 17:
        	    // SimpleBashSQL.g:530:20: '<&' '-'
        	    {
        	         MATCHT(28, &FOLLOW_28_in_other_redir743);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(23, &FOLLOW_23_in_other_redir745);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 18:
        	    // SimpleBashSQL.g:531:20: NUMBER '<&' '-'
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir766);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(28, &FOLLOW_28_in_other_redir768);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(23, &FOLLOW_23_in_other_redir770);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 19:
        	    // SimpleBashSQL.g:532:20: '&>' WORD
        	    {
        	         MATCHT(18, &FOLLOW_18_in_other_redir791);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir793);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 20:
        	    // SimpleBashSQL.g:533:20: NUMBER '<>' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir814);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(33, &FOLLOW_33_in_other_redir816);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir818);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 21:
        	    // SimpleBashSQL.g:534:20: '<>' WORD
        	    {
        	         MATCHT(33, &FOLLOW_33_in_other_redir839);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir841);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 22:
        	    // SimpleBashSQL.g:535:20: '>|' WORD
        	    {
        	         MATCHT(38, &FOLLOW_38_in_other_redir862);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir864);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;
        	case 23:
        	    // SimpleBashSQL.g:536:20: NUMBER '>|' WORD
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_other_redir885);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(38, &FOLLOW_38_in_other_redir887);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	         MATCHT(WORD, &FOLLOW_WORD_in_other_redir889);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_redirEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleother_redirEx; /* Prevent compiler warnings */
    ruleother_redirEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end other_redir */

/**
 * $ANTLR start shell_cmd
 * SimpleBashSQL.g:539:1: shell_cmd : ( for_command | case_command | 'while' compound_list 'do' compound_list 'done' | 'until' compound_list 'do' compound_list 'done' | if_command | subshell | group_command | function_def );
 */
static void
shell_cmd(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  SimpleBashSQL.g:539:10: ( for_command | case_command | 'while' compound_list 'do' compound_list 'done' | 'until' compound_list 'do' compound_list 'done' | if_command | subshell | group_command | function_def )

            ANTLR3_UINT32 alt18;

            alt18=8;

            switch ( LA(1) )
            {
            case 51:
            	{
            		alt18=1;
            	}
                break;
            case 42:
            	{
            		alt18=2;
            	}
                break;
            case 63:
            	{
            		alt18=3;
            	}
                break;
            case 61:
            	{
            		alt18=4;
            	}
                break;
            case 54:
            	{
            		alt18=5;
            	}
                break;
            case 19:
            	{
            		alt18=6;
            	}
                break;
            case 64:
            	{
            		alt18=7;
            	}
                break;
            case WORD:
            case 52:
            	{
            		alt18=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleshell_cmdEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // SimpleBashSQL.g:539:13: for_command
        	    {
        	        FOLLOWPUSH(FOLLOW_for_command_in_shell_cmd898);
        	        for_command(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:540:22: case_command
        	    {
        	        FOLLOWPUSH(FOLLOW_case_command_in_shell_cmd921);
        	        case_command(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:541:22: 'while' compound_list 'do' compound_list 'done'
        	    {
        	         MATCHT(63, &FOLLOW_63_in_shell_cmd944);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_compound_list_in_shell_cmd946);
        	        compound_list(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         MATCHT(45, &FOLLOW_45_in_shell_cmd948);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_compound_list_in_shell_cmd950);
        	        compound_list(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         MATCHT(46, &FOLLOW_46_in_shell_cmd952);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // SimpleBashSQL.g:542:22: 'until' compound_list 'do' compound_list 'done'
        	    {
        	         MATCHT(61, &FOLLOW_61_in_shell_cmd975);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_compound_list_in_shell_cmd977);
        	        compound_list(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         MATCHT(45, &FOLLOW_45_in_shell_cmd979);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_compound_list_in_shell_cmd981);
        	        compound_list(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	         MATCHT(46, &FOLLOW_46_in_shell_cmd983);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // SimpleBashSQL.g:543:22: if_command
        	    {
        	        FOLLOWPUSH(FOLLOW_if_command_in_shell_cmd1006);
        	        if_command(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // SimpleBashSQL.g:544:22: subshell
        	    {
        	        FOLLOWPUSH(FOLLOW_subshell_in_shell_cmd1029);
        	        subshell(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // SimpleBashSQL.g:545:22: group_command
        	    {
        	        FOLLOWPUSH(FOLLOW_group_command_in_shell_cmd1052);
        	        group_command(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // SimpleBashSQL.g:546:22: function_def
        	    {
        	        FOLLOWPUSH(FOLLOW_function_def_in_shell_cmd1075);
        	        function_def(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleshell_cmdEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleshell_cmdEx; /* Prevent compiler warnings */
    ruleshell_cmdEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end shell_cmd */

/**
 * $ANTLR start for_command
 * SimpleBashSQL.g:548:1: for_command : for_header compound_list ( 'done' | '}' ) ;
 */
static void
for_command(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_for_header_return for_header4;
    #undef	RETURN_TYPE_for_header4
    #define	RETURN_TYPE_for_header4 SimpleBashSQLParser_for_header_return

    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:548:12: ( for_header compound_list ( 'done' | '}' ) )
        // SimpleBashSQL.g:548:15: for_header compound_list ( 'done' | '}' )
        {
            FOLLOWPUSH(FOLLOW_for_header_in_for_command1083);
            for_header4=for_header(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefor_commandEx;
            }


            {
                printf("%s",(STRSTREAM->toStringTT(STRSTREAM, for_header4.start, for_header4.stop))
                ->chars);
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_for_command1090);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefor_commandEx;
            }


            if ( LA(1) == 46 || LA(1) == 66 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_for_command1092;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_for_command1092);
                goto rulefor_commandEx;
            }


            {
                printf("done\n");tobeprint=0;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefor_commandEx; /* Prevent compiler warnings */
    rulefor_commandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end for_command */

/**
 * $ANTLR start for_header
 * SimpleBashSQL.g:553:1: for_header : 'for' WORD 'in' ( WORD )* ( ALCHAR )* ( '\\n' | ';' ) ( 'do' | '{' ) ;
 */
static SimpleBashSQLParser_for_header_return
for_header(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_for_header_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // SimpleBashSQL.g:553:11: ( 'for' WORD 'in' ( WORD )* ( ALCHAR )* ( '\\n' | ';' ) ( 'do' | '{' ) )
        // SimpleBashSQL.g:553:14: 'for' WORD 'in' ( WORD )* ( ALCHAR )* ( '\\n' | ';' ) ( 'do' | '{' )
        {
             MATCHT(51, &FOLLOW_51_in_for_header1110);
            if  (HASEXCEPTION())
            {
                goto rulefor_headerEx;
            }


             MATCHT(WORD, &FOLLOW_WORD_in_for_header1112);
            if  (HASEXCEPTION())
            {
                goto rulefor_headerEx;
            }


             MATCHT(55, &FOLLOW_55_in_for_header1114);
            if  (HASEXCEPTION())
            {
                goto rulefor_headerEx;
            }


            // SimpleBashSQL.g:553:30: ( WORD )*

            for (;;)
            {
                int alt19=2;
                switch ( LA(1) )
                {
                case WORD:
                	{
                		alt19=1;
                	}
                    break;

                }

                switch (alt19)
                {
            	case 1:
            	    // SimpleBashSQL.g:553:30: WORD
            	    {
            	         MATCHT(WORD, &FOLLOW_WORD_in_for_header1116);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefor_headerEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:553:36: ( ALCHAR )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) )
                {
                case ALCHAR:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // SimpleBashSQL.g:553:36: ALCHAR
            	    {
            	         MATCHT(ALCHAR, &FOLLOW_ALCHAR_in_for_header1119);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefor_headerEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


            if ( LA(1) == 26 || LA(1) == 40 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_for_header1122;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_for_header1122);
                goto rulefor_headerEx;
            }


            if ( LA(1) == 45 || LA(1) == 64 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_for_header1128;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_for_header1128);
                goto rulefor_headerEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefor_headerEx; /* Prevent compiler warnings */
    rulefor_headerEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end for_header */

/**
 * $ANTLR start if_command
 * SimpleBashSQL.g:555:1: if_command : 'if' compound_list 'then' compound_list ( 'elif' compound_list )* 'else' compound_list 'fi' ;
 */
static void
if_command(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:555:11: ( 'if' compound_list 'then' compound_list ( 'elif' compound_list )* 'else' compound_list 'fi' )
        // SimpleBashSQL.g:555:13: 'if' compound_list 'then' compound_list ( 'elif' compound_list )* 'else' compound_list 'fi'
        {
             MATCHT(54, &FOLLOW_54_in_if_command1142);
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_if_command1144);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


             MATCHT(59, &FOLLOW_59_in_if_command1146);
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_if_command1148);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


            // SimpleBashSQL.g:555:53: ( 'elif' compound_list )*

            for (;;)
            {
                int alt21=2;
                switch ( LA(1) )
                {
                case 47:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21)
                {
            	case 1:
            	    // SimpleBashSQL.g:555:54: 'elif' compound_list
            	    {
            	         MATCHT(47, &FOLLOW_47_in_if_command1151);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_commandEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_compound_list_in_if_command1153);
            	        compound_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleif_commandEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


             MATCHT(48, &FOLLOW_48_in_if_command1157);
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_if_command1159);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


             MATCHT(50, &FOLLOW_50_in_if_command1161);
            if  (HASEXCEPTION())
            {
                goto ruleif_commandEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleif_commandEx; /* Prevent compiler warnings */
    ruleif_commandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end if_command */

/**
 * $ANTLR start group_command
 * SimpleBashSQL.g:557:1: group_command : '{' compound_list '}' ;
 */
static void
group_command(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:557:15: ( '{' compound_list '}' )
        // SimpleBashSQL.g:557:17: '{' compound_list '}'
        {
             MATCHT(64, &FOLLOW_64_in_group_command1169);
            if  (HASEXCEPTION())
            {
                goto rulegroup_commandEx;
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_group_command1171);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegroup_commandEx;
            }


             MATCHT(66, &FOLLOW_66_in_group_command1173);
            if  (HASEXCEPTION())
            {
                goto rulegroup_commandEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegroup_commandEx; /* Prevent compiler warnings */
    rulegroup_commandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end group_command */

/**
 * $ANTLR start function_def
 * SimpleBashSQL.g:559:1: function_def : ( 'function' )* WORD '(' ')' ( '\\n' | ';' ) group_command ;
 */
static void
function_def(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:559:14: ( ( 'function' )* WORD '(' ')' ( '\\n' | ';' ) group_command )
        // SimpleBashSQL.g:559:17: ( 'function' )* WORD '(' ')' ( '\\n' | ';' ) group_command
        {
            // SimpleBashSQL.g:559:17: ( 'function' )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) )
                {
                case 52:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22)
                {
            	case 1:
            	    // SimpleBashSQL.g:559:18: 'function'
            	    {
            	         MATCHT(52, &FOLLOW_52_in_function_def1183);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunction_defEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


             MATCHT(WORD, &FOLLOW_WORD_in_function_def1187);
            if  (HASEXCEPTION())
            {
                goto rulefunction_defEx;
            }


             MATCHT(19, &FOLLOW_19_in_function_def1189);
            if  (HASEXCEPTION())
            {
                goto rulefunction_defEx;
            }


             MATCHT(20, &FOLLOW_20_in_function_def1191);
            if  (HASEXCEPTION())
            {
                goto rulefunction_defEx;
            }


            if ( LA(1) == 26 || LA(1) == 40 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_function_def1193;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_function_def1193);
                goto rulefunction_defEx;
            }


            FOLLOWPUSH(FOLLOW_group_command_in_function_def1202);
            group_command(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunction_defEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunction_defEx; /* Prevent compiler warnings */
    rulefunction_defEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end function_def */

/**
 * $ANTLR start case_command
 * SimpleBashSQL.g:561:1: case_command : 'case' WORD ( '\\n' | ';' ) 'in' ( '\\n' | ';' ) ( case_clause )* 'esac' ;
 */
static void
case_command(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:561:13: ( 'case' WORD ( '\\n' | ';' ) 'in' ( '\\n' | ';' ) ( case_clause )* 'esac' )
        // SimpleBashSQL.g:561:16: 'case' WORD ( '\\n' | ';' ) 'in' ( '\\n' | ';' ) ( case_clause )* 'esac'
        {
             MATCHT(42, &FOLLOW_42_in_case_command1212);
            if  (HASEXCEPTION())
            {
                goto rulecase_commandEx;
            }


             MATCHT(WORD, &FOLLOW_WORD_in_case_command1214);
            if  (HASEXCEPTION())
            {
                goto rulecase_commandEx;
            }


            if ( LA(1) == 26 || LA(1) == 40 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_case_command1216;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_case_command1216);
                goto rulecase_commandEx;
            }


             MATCHT(55, &FOLLOW_55_in_case_command1224);
            if  (HASEXCEPTION())
            {
                goto rulecase_commandEx;
            }


            if ( LA(1) == 26 || LA(1) == 40 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_case_command1226;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_case_command1226);
                goto rulecase_commandEx;
            }


            // SimpleBashSQL.g:561:59: ( case_clause )*

            for (;;)
            {
                int alt23=2;
                switch ( LA(1) )
                {
                case NUMBER:
                case WORD:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23)
                {
            	case 1:
            	    // SimpleBashSQL.g:561:59: case_clause
            	    {
            	        FOLLOWPUSH(FOLLOW_case_clause_in_case_command1234);
            	        case_clause(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecase_commandEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


             MATCHT(49, &FOLLOW_49_in_case_command1237);
            if  (HASEXCEPTION())
            {
                goto rulecase_commandEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecase_commandEx; /* Prevent compiler warnings */
    rulecase_commandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end case_command */

/**
 * $ANTLR start case_clause
 * SimpleBashSQL.g:563:1: case_clause : pattern ')' compound_list ';;' ;
 */
static void
case_clause(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:563:12: ( pattern ')' compound_list ';;' )
        // SimpleBashSQL.g:563:14: pattern ')' compound_list ';;'
        {
            FOLLOWPUSH(FOLLOW_pattern_in_case_clause1244);
            pattern(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecase_clauseEx;
            }


             MATCHT(20, &FOLLOW_20_in_case_clause1246);
            if  (HASEXCEPTION())
            {
                goto rulecase_clauseEx;
            }


            FOLLOWPUSH(FOLLOW_compound_list_in_case_clause1248);
            compound_list(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecase_clauseEx;
            }


             MATCHT(27, &FOLLOW_27_in_case_clause1250);
            if  (HASEXCEPTION())
            {
                goto rulecase_clauseEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecase_clauseEx; /* Prevent compiler warnings */
    rulecase_clauseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end case_clause */

/**
 * $ANTLR start cmd
 * SimpleBashSQL.g:566:1: cmd returns [query *r] : ( 'cut' ( OPTS | WORD | from_redir | '- ' )+ | 'cat' ( OPTS | WORD | from_redir | '- ' )* | 'grep' (o1= OPTS )* p= WORD (o2= OPTS |f= WORD | from_redir | '- ' )* | 'sort' ( OPTS | WORD | from_redir | '- ' )* | 'join' ( ( '-1' n1= NUMBER ) | ( '-2' n2= NUMBER ) | OPTS | WORD | '- ' | from_redir )+ | 'uniq' ( OPTS | WORD | from_redir | '- ' )* | 'wc -l' ( OPTS | WORD | from_redir | '- ' )* | 'awk' ( OPTS )* '\\'' awkbody[r] '\\'' ( OPTS )* | words );
 */
static query *
cmd(pSimpleBashSQLParser ctx)
{
    query * r;


    pANTLR3_COMMON_TOKEN    o1;
    pANTLR3_COMMON_TOKEN    p;
    pANTLR3_COMMON_TOKEN    o2;
    pANTLR3_COMMON_TOKEN    f;
    pANTLR3_COMMON_TOKEN    n1;
    pANTLR3_COMMON_TOKEN    n2;
    pANTLR3_COMMON_TOKEN    OPTS5;
    pANTLR3_COMMON_TOKEN    WORD6;
    pANTLR3_COMMON_TOKEN    WORD8;
    pANTLR3_COMMON_TOKEN    OPTS11;
    pANTLR3_COMMON_TOKEN    WORD12;
    pANTLR3_COMMON_TOKEN    WORD14;
    pANTLR3_COMMON_TOKEN    OPTS16;
    pANTLR3_COMMON_TOKEN    WORD17;
    pANTLR3_COMMON_TOKEN    OPTS19;
    pANTLR3_COMMON_TOKEN    WORD20;
    char* from_redir7;
    #undef	RETURN_TYPE_from_redir7
    #define	RETURN_TYPE_from_redir7 char*

    char* from_redir9;
    #undef	RETURN_TYPE_from_redir9
    #define	RETURN_TYPE_from_redir9 char*

    char* from_redir10;
    #undef	RETURN_TYPE_from_redir10
    #define	RETURN_TYPE_from_redir10 char*

    char* from_redir13;
    #undef	RETURN_TYPE_from_redir13
    #define	RETURN_TYPE_from_redir13 char*

    char* from_redir15;
    #undef	RETURN_TYPE_from_redir15
    #define	RETURN_TYPE_from_redir15 char*

    char* from_redir18;
    #undef	RETURN_TYPE_from_redir18
    #define	RETURN_TYPE_from_redir18 char*

    char* from_redir21;
    #undef	RETURN_TYPE_from_redir21
    #define	RETURN_TYPE_from_redir21 char*

    /* Initialize rule variables
     */


    	/* neue Query r, vorherige Abfrage als FROM-Tabelle
    		NULL, wenn erstes Kommando */
    	char tmp=0; //zaehlt args
    	r=(query*) malloc(sizeof(query));
    	r->src=lastquery;
    	reset(r);

    o1       = NULL;
    p       = NULL;
    o2       = NULL;
    f       = NULL;
    n1       = NULL;
    n2       = NULL;
    OPTS5       = NULL;
    WORD6       = NULL;
    WORD8       = NULL;
    OPTS11       = NULL;
    WORD12       = NULL;
    WORD14       = NULL;
    OPTS16       = NULL;
    WORD17       = NULL;
    OPTS19       = NULL;
    WORD20       = NULL;

    {
        {
            //  SimpleBashSQL.g:578:2: ( 'cut' ( OPTS | WORD | from_redir | '- ' )+ | 'cat' ( OPTS | WORD | from_redir | '- ' )* | 'grep' (o1= OPTS )* p= WORD (o2= OPTS |f= WORD | from_redir | '- ' )* | 'sort' ( OPTS | WORD | from_redir | '- ' )* | 'join' ( ( '-1' n1= NUMBER ) | ( '-2' n2= NUMBER ) | OPTS | WORD | '- ' | from_redir )+ | 'uniq' ( OPTS | WORD | from_redir | '- ' )* | 'wc -l' ( OPTS | WORD | from_redir | '- ' )* | 'awk' ( OPTS )* '\\'' awkbody[r] '\\'' ( OPTS )* | words )

            ANTLR3_UINT32 alt34;

            alt34=9;

            switch ( LA(1) )
            {
            case 44:
            	{
            		alt34=1;
            	}
                break;
            case 43:
            	{
            		alt34=2;
            	}
                break;
            case 53:
            	{
            		alt34=3;
            	}
                break;
            case 58:
            	{
            		alt34=4;
            	}
                break;
            case 56:
            	{
            		alt34=5;
            	}
                break;
            case 60:
            	{
            		alt34=6;
            	}
                break;
            case 62:
            	{
            		alt34=7;
            	}
                break;
            case 41:
            	{
            		alt34=8;
            	}
                break;
            case ALCHAR:
            case NUMBER:
            case PIPE:
            case WORD:
            case 16:
            case 17:
            case 18:
            case 20:
            case 26:
            case 27:
            case 28:
            case 31:
            case 33:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 45:
            case 46:
            case 47:
            case 48:
            case 50:
            case 59:
            case 65:
            case 66:
            	{
            		alt34=9;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 34;
                EXCEPTION->state        = 0;


                goto rulecmdEx;

            }

            switch (alt34)
            {
        	case 1:
        	    // SimpleBashSQL.g:579:4: 'cut' ( OPTS | WORD | from_redir | '- ' )+
        	    {
        	         MATCHT(44, &FOLLOW_44_in_cmd1276);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:579:11: ( OPTS | WORD | from_redir | '- ' )+
        	        {
        	            int cnt24=0;

        	            for (;;)
        	            {
        	                int alt24=5;
        	        	switch ( LA(1) )
        	        	{
        	        	case OPTS:
        	        		{
        	        			alt24=1;
        	        		}
        	        	    break;
        	        	case WORD:
        	        		{
        	        			alt24=2;
        	        		}
        	        	    break;
        	        	case 29:
        	        	case 30:
        	        	case 32:
        	        		{
        	        			alt24=3;
        	        		}
        	        	    break;
        	        	case 22:
        	        		{
        	        			alt24=4;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt24)
        	        	{
        	        	    case 1:
        	        	        // SimpleBashSQL.g:579:13: OPTS
        	        	        {
        	        	            OPTS5 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1281);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                 optscut((OPTS5->getText(OPTS5))->chars,r); 
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // SimpleBashSQL.g:581:6: WORD
        	        	        {
        	        	            WORD6 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1296);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                 r=makeunion((WORD6->getText(WORD6))->chars,r); 
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 3:
        	        	        // SimpleBashSQL.g:583:6: from_redir
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_from_redir_in_cmd1309);
        	        	            from_redir7=from_redir(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                /* fname!=NULL, wenn Dateiname */
        	        	                				if (from_redir7
        	        	                )
        	        	                					r=makeunion(from_redir7
        	        	                ,r);
        	        	                				else /* sonst subshell */
        	        	                					r=makeunion_query(lastquery,r);
        	        	                				
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 4:
        	        	        // SimpleBashSQL.g:590:6: '- '
        	        	        {
        	        	             MATCHT(22, &FOLLOW_22_in_cmd1322);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt24 >= 1 )
        	        		{
        	        		    goto loop24;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulecmdEx;
        	        	}
        	        	cnt24++;
        	            }
        	            loop24: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:592:4: 'cat' ( OPTS | WORD | from_redir | '- ' )*
        	    {
        	         MATCHT(43, &FOLLOW_43_in_cmd1331);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:592:11: ( OPTS | WORD | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt25=5;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt25=1;
        	            	}
        	                break;
        	            case WORD:
        	            	{
        	            		alt25=2;
        	            	}
        	                break;
        	            case 29:
        	            case 30:
        	            case 32:
        	            	{
        	            		alt25=3;
        	            	}
        	                break;
        	            case 22:
        	            	{
        	            		alt25=4;
        	            	}
        	                break;

        	            }

        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:592:13: OPTS
        	        	    {
        	        	         MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1336);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:593:6: WORD
        	        	    {
        	        	        WORD8 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1343);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             r=makeunion((WORD8->getText(WORD8))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:595:6: from_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_from_redir_in_cmd1357);
        	        	        from_redir9=from_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (from_redir9
        	        	            )
        	        	            					r=makeunion(from_redir9
        	        	            ,r);
        	        	            				else /* sonst subshell */
        	        	            					r=makeunion_query(lastquery,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:602:6: '- '
        	        	    {
        	        	         MATCHT(22, &FOLLOW_22_in_cmd1370);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop25;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop25: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 3:
        	    // SimpleBashSQL.g:604:4: 'grep' (o1= OPTS )* p= WORD (o2= OPTS |f= WORD | from_redir | '- ' )*
        	    {
        	         MATCHT(53, &FOLLOW_53_in_cmd1378);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:604:12: (o1= OPTS )*

        	        for (;;)
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;

        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:604:14: o1= OPTS
        	        	    {
        	        	        o1 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1385);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             optsgrep((o1->getText(o1))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop26;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop26: ; /* Jump out to here if this rule does not match */


        	        p = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1397);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        {
        	             zugrep((p->getText(p))->chars,r); 
        	        }


        	        // SimpleBashSQL.g:606:4: (o2= OPTS |f= WORD | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt27=5;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt27=1;
        	            	}
        	                break;
        	            case WORD:
        	            	{
        	            		alt27=2;
        	            	}
        	                break;
        	            case 29:
        	            case 30:
        	            case 32:
        	            	{
        	            		alt27=3;
        	            	}
        	                break;
        	            case 22:
        	            	{
        	            		alt27=4;
        	            	}
        	                break;

        	            }

        	            switch (alt27)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:606:6: o2= OPTS
        	        	    {
        	        	        o2 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1410);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             optsgrep((o2->getText(o2))->chars,r);   
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:607:6: f= WORD
        	        	    {
        	        	        f = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1422);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             r=makeunion((f->getText(f))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:608:6: from_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_from_redir_in_cmd1432);
        	        	        from_redir10=from_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (from_redir10
        	        	            )
        	        	            					r=makeunion(from_redir10
        	        	            ,r);
        	        	            				else /* sonst subshell */
        	        	            					r=makeunion_query(lastquery,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:615:6: '- '
        	        	    {
        	        	         MATCHT(22, &FOLLOW_22_in_cmd1445);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop27;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop27: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 4:
        	    // SimpleBashSQL.g:617:4: 'sort' ( OPTS | WORD | from_redir | '- ' )*
        	    {
        	         MATCHT(58, &FOLLOW_58_in_cmd1454);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:617:11: ( OPTS | WORD | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt28=5;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt28=1;
        	            	}
        	                break;
        	            case WORD:
        	            	{
        	            		alt28=2;
        	            	}
        	                break;
        	            case 29:
        	            case 30:
        	            case 32:
        	            	{
        	            		alt28=3;
        	            	}
        	                break;
        	            case 22:
        	            	{
        	            		alt28=4;
        	            	}
        	                break;

        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:617:13: OPTS
        	        	    {
        	        	        OPTS11 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1458);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             optssort((OPTS11->getText(OPTS11))->chars,r);
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:618:6: WORD
        	        	    {
        	        	        WORD12 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1467);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             r=makeunion((WORD12->getText(WORD12))->chars,r);
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:619:6: from_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_from_redir_in_cmd1476);
        	        	        from_redir13=from_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (from_redir13
        	        	            )
        	        	            					r=makeunion(from_redir13
        	        	            ,r);
        	        	            				else /* sonst subshell */
        	        	            					r=makeunion_query(lastquery,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:626:6: '- '
        	        	    {
        	        	         MATCHT(22, &FOLLOW_22_in_cmd1489);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop28;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop28: ; /* Jump out to here if this rule does not match */


        	        {
        	            r->sort=1;
        	        }


        	    }
        	    break;
        	case 5:
        	    // SimpleBashSQL.g:627:4: 'join' ( ( '-1' n1= NUMBER ) | ( '-2' n2= NUMBER ) | OPTS | WORD | '- ' | from_redir )+
        	    {
        	         MATCHT(56, &FOLLOW_56_in_cmd1499);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:627:11: ( ( '-1' n1= NUMBER ) | ( '-2' n2= NUMBER ) | OPTS | WORD | '- ' | from_redir )+
        	        {
        	            int cnt29=0;

        	            for (;;)
        	            {
        	                int alt29=7;
        	        	switch ( LA(1) )
        	        	{
        	        	case 24:
        	        		{
        	        			alt29=1;
        	        		}
        	        	    break;
        	        	case 25:
        	        		{
        	        			alt29=2;
        	        		}
        	        	    break;
        	        	case OPTS:
        	        		{
        	        			alt29=3;
        	        		}
        	        	    break;
        	        	case WORD:
        	        		{
        	        			alt29=4;
        	        		}
        	        	    break;
        	        	case 22:
        	        		{
        	        			alt29=5;
        	        		}
        	        	    break;
        	        	case 29:
        	        	case 30:
        	        	case 32:
        	        		{
        	        			alt29=6;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt29)
        	        	{
        	        	    case 1:
        	        	        // SimpleBashSQL.g:627:12: ( '-1' n1= NUMBER )
        	        	        {
        	        	            // SimpleBashSQL.g:627:12: ( '-1' n1= NUMBER )
        	        	            // SimpleBashSQL.g:627:13: '-1' n1= NUMBER
        	        	            {
        	        	                 MATCHT(24, &FOLLOW_24_in_cmd1503);
        	        	                if  (HASEXCEPTION())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	                n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_cmd1507);
        	        	                if  (HASEXCEPTION())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	                {
        	        	                    r->f1=atoi((n1->getText(n1))->chars);
        	        	                }


        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // SimpleBashSQL.g:628:5: ( '-2' n2= NUMBER )
        	        	        {
        	        	            // SimpleBashSQL.g:628:5: ( '-2' n2= NUMBER )
        	        	            // SimpleBashSQL.g:628:6: '-2' n2= NUMBER
        	        	            {
        	        	                 MATCHT(25, &FOLLOW_25_in_cmd1518);
        	        	                if  (HASEXCEPTION())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	                n2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_cmd1522);
        	        	                if  (HASEXCEPTION())
        	        	                {
        	        	                    goto rulecmdEx;
        	        	                }


        	        	                {
        	        	                    r->f2=atoi((n2->getText(n2))->chars);
        	        	                }


        	        	            }


        	        	        }
        	        	        break;
        	        	    case 3:
        	        	        // SimpleBashSQL.g:629:5: OPTS
        	        	        {
        	        	             MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1532);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 4:
        	        	        // SimpleBashSQL.g:630:5: WORD
        	        	        {
        	        	            WORD14 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1538);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                	if(tmp++==0) /* erstes Argument*/
        	        	                					strcpy(r->from,(WORD14->getText(WORD14))->chars);
        	        	                				else
        	        	                					strcpy(r->t2,(WORD14->getText(WORD14))->chars);
        	        	                				
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 5:
        	        	        // SimpleBashSQL.g:635:5: '- '
        	        	        {
        	        	             MATCHT(22, &FOLLOW_22_in_cmd1546);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                	if (tmp++==0){ /*erstes Arg? => swap*/
        	        	                					r->src2=r->src; r->src=NULL;
        	        	                				}
        	        	                			
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 6:
        	        	        // SimpleBashSQL.g:639:5: from_redir
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_from_redir_in_cmd1554);
        	        	            from_redir15=from_redir(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecmdEx;
        	        	            }


        	        	            {
        	        	                /* fname!=NULL, wenn Dateiname */
        	        	                			if (from_redir15
        	        	                )
        	        	                				r=makeunion(from_redir15
        	        	                ,r);
        	        	                			else /* sonst subshell */
        	        	                				r=makeunion_query(lastquery,r);
        	        	                			
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt29 >= 1 )
        	        		{
        	        		    goto loop29;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulecmdEx;
        	        	}
        	        	cnt29++;
        	            }
        	            loop29: ;	/* Jump to here if this rule does not match */
        	        }

        	        {
        	            r->join=1;
        	        }


        	    }
        	    break;
        	case 6:
        	    // SimpleBashSQL.g:647:4: 'uniq' ( OPTS | WORD | from_redir | '- ' )*
        	    {
        	         MATCHT(60, &FOLLOW_60_in_cmd1571);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:647:11: ( OPTS | WORD | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt30=5;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt30=1;
        	            	}
        	                break;
        	            case WORD:
        	            	{
        	            		alt30=2;
        	            	}
        	                break;
        	            case 29:
        	            case 30:
        	            case 32:
        	            	{
        	            		alt30=3;
        	            	}
        	                break;
        	            case 22:
        	            	{
        	            		alt30=4;
        	            	}
        	                break;

        	            }

        	            switch (alt30)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:647:13: OPTS
        	        	    {
        	        	        OPTS16 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1575);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             optsuniq((OPTS16->getText(OPTS16))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:649:6: WORD
        	        	    {
        	        	        WORD17 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1590);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             r=makeunion((WORD17->getText(WORD17))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:651:6: from_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_from_redir_in_cmd1603);
        	        	        from_redir18=from_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (from_redir18
        	        	            )
        	        	            					r=makeunion(from_redir18
        	        	            ,r);
        	        	            				else /* sonst subshell */
        	        	            					r=makeunion_query(lastquery,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:658:6: '- '
        	        	    {
        	        	         MATCHT(22, &FOLLOW_22_in_cmd1616);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop30;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop30: ; /* Jump out to here if this rule does not match */


        	        {
        	            r->group=1;
        	        }


        	    }
        	    break;
        	case 7:
        	    // SimpleBashSQL.g:660:4: 'wc -l' ( OPTS | WORD | from_redir | '- ' )*
        	    {
        	         MATCHT(62, &FOLLOW_62_in_cmd1629);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:660:12: ( OPTS | WORD | from_redir | '- ' )*

        	        for (;;)
        	        {
        	            int alt31=5;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt31=1;
        	            	}
        	                break;
        	            case WORD:
        	            	{
        	            		alt31=2;
        	            	}
        	                break;
        	            case 29:
        	            case 30:
        	            case 32:
        	            	{
        	            		alt31=3;
        	            	}
        	                break;
        	            case 22:
        	            	{
        	            		alt31=4;
        	            	}
        	                break;

        	            }

        	            switch (alt31)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:660:14: OPTS
        	        	    {
        	        	        OPTS19 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1633);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             optswc((OPTS19->getText(OPTS19))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // SimpleBashSQL.g:662:6: WORD
        	        	    {
        	        	        WORD20 = (pANTLR3_COMMON_TOKEN) MATCHT(WORD, &FOLLOW_WORD_in_cmd1648);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	             r=makeunion((WORD20->getText(WORD20))->chars,r); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // SimpleBashSQL.g:664:6: from_redir
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_from_redir_in_cmd1661);
        	        	        from_redir21=from_redir(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	        {
        	        	            /* fname!=NULL, wenn Dateiname */
        	        	            				if (from_redir21
        	        	            )
        	        	            					r=makeunion(from_redir21
        	        	            ,r);
        	        	            				else /* sonst subshell */
        	        	            					r=makeunion_query(lastquery,r);
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // SimpleBashSQL.g:671:6: '- '
        	        	    {
        	        	         MATCHT(22, &FOLLOW_22_in_cmd1674);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop31;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop31: ; /* Jump out to here if this rule does not match */


        	        {
        	            strcpy(r->select,"count(*) ");
        	        }


        	    }
        	    break;
        	case 8:
        	    // SimpleBashSQL.g:673:4: 'awk' ( OPTS )* '\\'' awkbody[r] '\\'' ( OPTS )*
        	    {
        	         MATCHT(41, &FOLLOW_41_in_cmd1687);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:673:10: ( OPTS )*

        	        for (;;)
        	        {
        	            int alt32=2;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt32=1;
        	            	}
        	                break;

        	            }

        	            switch (alt32)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:673:10: OPTS
        	        	    {
        	        	         MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1689);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop32;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop32: ; /* Jump out to here if this rule does not match */


        	         MATCHT(39, &FOLLOW_39_in_cmd1692);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_awkbody_in_cmd1694);
        	        awkbody(ctx, r);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	         MATCHT(39, &FOLLOW_39_in_cmd1697);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        // SimpleBashSQL.g:673:37: ( OPTS )*

        	        for (;;)
        	        {
        	            int alt33=2;
        	            switch ( LA(1) )
        	            {
        	            case OPTS:
        	            	{
        	            		alt33=1;
        	            	}
        	                break;

        	            }

        	            switch (alt33)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:673:37: OPTS
        	        	    {
        	        	         MATCHT(OPTS, &FOLLOW_OPTS_in_cmd1699);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecmdEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop33;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop33: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 9:
        	    // SimpleBashSQL.g:674:4: words
        	    {
        	        FOLLOWPUSH(FOLLOW_words_in_cmd1705);
        	        words(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecmdEx;
        	        }


        	        {

        	            			if(lastquery!=NULL)
        	            				ausgeben(lastquery);
        	            			r=NULL;
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecmdEx; /* Prevent compiler warnings */
    rulecmdEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                    	lastquery=r;

                }
            }


    return r;
}
/* $ANTLR end cmd */

/**
 * $ANTLR start words
 * SimpleBashSQL.g:681:1: words : ( ALCHAR )* ( WORD )* ;
 */
static void
words(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:681:6: ( ( ALCHAR )* ( WORD )* )
        // SimpleBashSQL.g:681:8: ( ALCHAR )* ( WORD )*
        {
            // SimpleBashSQL.g:681:8: ( ALCHAR )*

            for (;;)
            {
                int alt35=2;
                switch ( LA(1) )
                {
                case ALCHAR:
                	{
                		alt35=1;
                	}
                    break;

                }

                switch (alt35)
                {
            	case 1:
            	    // SimpleBashSQL.g:681:8: ALCHAR
            	    {
            	         MATCHT(ALCHAR, &FOLLOW_ALCHAR_in_words1716);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewordsEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop35;	/* break out of the loop */
            	    break;
                }
            }
            loop35: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:681:16: ( WORD )*

            for (;;)
            {
                int alt36=2;
                switch ( LA(1) )
                {
                case WORD:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36)
                {
            	case 1:
            	    // SimpleBashSQL.g:681:16: WORD
            	    {
            	         MATCHT(WORD, &FOLLOW_WORD_in_words1719);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewordsEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewordsEx; /* Prevent compiler warnings */
    rulewordsEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end words */

/**
 * $ANTLR start assignment
 * SimpleBashSQL.g:683:1: assignment : ( ALCHAR | WORD ) '=' ( ALCHAR | WORD ) ;
 */
static void
assignment(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:683:11: ( ( ALCHAR | WORD ) '=' ( ALCHAR | WORD ) )
        // SimpleBashSQL.g:683:13: ( ALCHAR | WORD ) '=' ( ALCHAR | WORD )
        {
            if ( LA(1) == ALCHAR || LA(1) == WORD )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_assignment1727;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_assignment1727);
                goto ruleassignmentEx;
            }


             MATCHT(34, &FOLLOW_34_in_assignment1732);
            if  (HASEXCEPTION())
            {
                goto ruleassignmentEx;
            }


            if ( LA(1) == ALCHAR || LA(1) == WORD )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_assignment1733;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_assignment1733);
                goto ruleassignmentEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end assignment */

/**
 * $ANTLR start word
 * SimpleBashSQL.g:685:1: word : ( '\"' ( ALCHAR )* '\"' | '\\'' ( ALCHAR )* '\\'' );
 */
static void
word(pSimpleBashSQLParser ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  SimpleBashSQL.g:685:6: ( '\"' ( ALCHAR )* '\"' | '\\'' ( ALCHAR )* '\\'' )

            ANTLR3_UINT32 alt39;

            alt39=2;

            switch ( LA(1) )
            {
            case 14:
            	{
            		alt39=1;
            	}
                break;
            case 39:
            	{
            		alt39=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulewordEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // SimpleBashSQL.g:685:8: '\"' ( ALCHAR )* '\"'
        	    {
        	         MATCHT(14, &FOLLOW_14_in_word1745);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewordEx;
        	        }


        	        // SimpleBashSQL.g:685:12: ( ALCHAR )*

        	        for (;;)
        	        {
        	            int alt37=2;
        	            switch ( LA(1) )
        	            {
        	            case ALCHAR:
        	            	{
        	            		alt37=1;
        	            	}
        	                break;

        	            }

        	            switch (alt37)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:685:12: ALCHAR
        	        	    {
        	        	         MATCHT(ALCHAR, &FOLLOW_ALCHAR_in_word1747);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewordEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop37;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop37: ; /* Jump out to here if this rule does not match */


        	         MATCHT(14, &FOLLOW_14_in_word1750);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewordEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SimpleBashSQL.g:686:4: '\\'' ( ALCHAR )* '\\''
        	    {
        	         MATCHT(39, &FOLLOW_39_in_word1755);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewordEx;
        	        }


        	        // SimpleBashSQL.g:686:9: ( ALCHAR )*

        	        for (;;)
        	        {
        	            int alt38=2;
        	            switch ( LA(1) )
        	            {
        	            case ALCHAR:
        	            	{
        	            		alt38=1;
        	            	}
        	                break;

        	            }

        	            switch (alt38)
        	            {
        	        	case 1:
        	        	    // SimpleBashSQL.g:686:9: ALCHAR
        	        	    {
        	        	         MATCHT(ALCHAR, &FOLLOW_ALCHAR_in_word1757);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewordEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop38;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop38: ; /* Jump out to here if this rule does not match */


        	         MATCHT(39, &FOLLOW_39_in_word1760);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewordEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulewordEx; /* Prevent compiler warnings */
    rulewordEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end word */

/**
 * $ANTLR start awkbody
 * SimpleBashSQL.g:689:1: awkbody[query* r] : ( pattern )? '{' ( 'print' ( NUMBER )* ( ',' NUMBER )* )* ( WORD )* ( NUMBER )* '}' ;
 */
static void
awkbody(pSimpleBashSQLParser ctx, query* r)
{
    SimpleBashSQLParser_pattern_return pattern22;
    #undef	RETURN_TYPE_pattern22
    #define	RETURN_TYPE_pattern22 SimpleBashSQLParser_pattern_return

    /* Initialize rule variables
     */

    {
        // SimpleBashSQL.g:689:18: ( ( pattern )? '{' ( 'print' ( NUMBER )* ( ',' NUMBER )* )* ( WORD )* ( NUMBER )* '}' )
        // SimpleBashSQL.g:689:20: ( pattern )? '{' ( 'print' ( NUMBER )* ( ',' NUMBER )* )* ( WORD )* ( NUMBER )* '}'
        {
            // SimpleBashSQL.g:689:20: ( pattern )?
            {
                int alt40=2;
                switch ( LA(1) )
                {
                    case NUMBER:
                    case WORD:
                    	{
                    		alt40=1;
                    	}
                        break;
                }

                switch (alt40)
                {
            	case 1:
            	    // SimpleBashSQL.g:689:21: pattern
            	    {
            	        FOLLOWPUSH(FOLLOW_pattern_in_awkbody1770);
            	        pattern22=pattern(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleawkbodyEx;
            	        }


            	        {
            	            strcat(r->where, (STRSTREAM->toStringTT(STRSTREAM, pattern22.start, pattern22.stop))
            	            ->chars);
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(64, &FOLLOW_64_in_awkbody1786);
            if  (HASEXCEPTION())
            {
                goto ruleawkbodyEx;
            }


            // SimpleBashSQL.g:692:7: ( 'print' ( NUMBER )* ( ',' NUMBER )* )*

            for (;;)
            {
                int alt43=2;
                switch ( LA(1) )
                {
                case 57:
                	{
                		alt43=1;
                	}
                    break;

                }

                switch (alt43)
                {
            	case 1:
            	    // SimpleBashSQL.g:692:8: 'print' ( NUMBER )* ( ',' NUMBER )*
            	    {
            	         MATCHT(57, &FOLLOW_57_in_awkbody1789);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleawkbodyEx;
            	        }


            	        // SimpleBashSQL.g:692:16: ( NUMBER )*

            	        for (;;)
            	        {
            	            int alt41=2;
            	            switch ( LA(1) )
            	            {
            	            case NUMBER:
            	            	{
            	            		alt41=1;
            	            	}
            	                break;

            	            }

            	            switch (alt41)
            	            {
            	        	case 1:
            	        	    // SimpleBashSQL.g:692:16: NUMBER
            	        	    {
            	        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_awkbody1791);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleawkbodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop41;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop41: ; /* Jump out to here if this rule does not match */


            	        // SimpleBashSQL.g:692:24: ( ',' NUMBER )*

            	        for (;;)
            	        {
            	            int alt42=2;
            	            switch ( LA(1) )
            	            {
            	            case 21:
            	            	{
            	            		alt42=1;
            	            	}
            	                break;

            	            }

            	            switch (alt42)
            	            {
            	        	case 1:
            	        	    // SimpleBashSQL.g:692:25: ',' NUMBER
            	        	    {
            	        	         MATCHT(21, &FOLLOW_21_in_awkbody1795);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleawkbodyEx;
            	        	        }


            	        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_awkbody1797);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleawkbodyEx;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop42;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop42: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

            	default:
            	    goto loop43;	/* break out of the loop */
            	    break;
                }
            }
            loop43: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:692:40: ( WORD )*

            for (;;)
            {
                int alt44=2;
                switch ( LA(1) )
                {
                case WORD:
                	{
                		alt44=1;
                	}
                    break;

                }

                switch (alt44)
                {
            	case 1:
            	    // SimpleBashSQL.g:692:40: WORD
            	    {
            	         MATCHT(WORD, &FOLLOW_WORD_in_awkbody1803);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleawkbodyEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop44;	/* break out of the loop */
            	    break;
                }
            }
            loop44: ; /* Jump out to here if this rule does not match */


            // SimpleBashSQL.g:692:46: ( NUMBER )*

            for (;;)
            {
                int alt45=2;
                switch ( LA(1) )
                {
                case NUMBER:
                	{
                		alt45=1;
                	}
                    break;

                }

                switch (alt45)
                {
            	case 1:
            	    // SimpleBashSQL.g:692:46: NUMBER
            	    {
            	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_awkbody1806);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleawkbodyEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop45;	/* break out of the loop */
            	    break;
                }
            }
            loop45: ; /* Jump out to here if this rule does not match */


             MATCHT(66, &FOLLOW_66_in_awkbody1811);
            if  (HASEXCEPTION())
            {
                goto ruleawkbodyEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleawkbodyEx; /* Prevent compiler warnings */
    ruleawkbodyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end awkbody */

/**
 * $ANTLR start pattern
 * SimpleBashSQL.g:696:1: pattern : ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) ( ( '&&' | '||' ) ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) )* ;
 */
static SimpleBashSQLParser_pattern_return
pattern(pSimpleBashSQLParser ctx)
{
    SimpleBashSQLParser_pattern_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        // SimpleBashSQL.g:696:8: ( ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) ( ( '&&' | '||' ) ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) )* )
        // SimpleBashSQL.g:696:10: ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) ( ( '&&' | '||' ) ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) )*
        {
            if ( LA(1) == NUMBER || LA(1) == WORD )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1821;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1821);
                goto rulepatternEx;
            }


            if ( LA(1) == 29 || LA(1) == 34 || LA(1) == 36 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1827;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1827);
                goto rulepatternEx;
            }


            // SimpleBashSQL.g:696:37: ( '=' )?
            {
                int alt46=2;
                switch ( LA(1) )
                {
                    case 34:
                    	{
                    		alt46=1;
                    	}
                        break;
                }

                switch (alt46)
                {
            	case 1:
            	    // SimpleBashSQL.g:696:38: '='
            	    {
            	         MATCHT(34, &FOLLOW_34_in_pattern1835);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepatternEx;
            	        }


            	    }
            	    break;

                }
            }

            if ( LA(1) == NUMBER || LA(1) == WORD )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1839;

                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1839);
                goto rulepatternEx;
            }


            // SimpleBashSQL.g:697:2: ( ( '&&' | '||' ) ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER ) )*

            for (;;)
            {
                int alt48=2;
                switch ( LA(1) )
                {
                case 16:
                case 65:
                	{
                		alt48=1;
                	}
                    break;

                }

                switch (alt48)
                {
            	case 1:
            	    // SimpleBashSQL.g:697:3: ( '&&' | '||' ) ( WORD | NUMBER ) ( '<' | '>' | '=' ) ( '=' )? ( WORD | NUMBER )
            	    {
            	        if ( LA(1) == 16 || LA(1) == 65 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1847;

            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1847);
            	            goto rulepatternEx;
            	        }


            	        if ( LA(1) == NUMBER || LA(1) == WORD )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1857;

            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1857);
            	            goto rulepatternEx;
            	        }


            	        if ( LA(1) == 29 || LA(1) == 34 || LA(1) == 36 )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1863;

            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1863);
            	            goto rulepatternEx;
            	        }


            	        // SimpleBashSQL.g:698:29: ( '=' )?
            	        {
            	            int alt47=2;
            	            switch ( LA(1) )
            	            {
            	                case 34:
            	                	{
            	                		alt47=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt47)
            	            {
            	        	case 1:
            	        	    // SimpleBashSQL.g:698:30: '='
            	        	    {
            	        	         MATCHT(34, &FOLLOW_34_in_pattern1871);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepatternEx;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        if ( LA(1) == NUMBER || LA(1) == WORD )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	        }
            	        else
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_pattern1875;

            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_pattern1875);
            	            goto rulepatternEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop48;	/* break out of the loop */
            	    break;
                }
            }
            loop48: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepatternEx; /* Prevent compiler warnings */
    rulepatternEx: ;
    retval.stop = LT(-1);


            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end pattern */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
